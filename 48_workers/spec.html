<!DOCTYPE html>

<html lang="ja">

<head>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="description" content="[仕様]WebWorkers有無の共通化" />
  <meta name="author" content="online-simulator.github.io" />
  <noscript>Javascript is not enabled on your browser.</noscript>
  <link rel="stylesheet" type="text/css" href="../00_common/css/common.css" />
  <link rel="stylesheet" type="text/css" href="../00_common/css/color.css" />
  <link rel="stylesheet" type="text/css" href="../00_common/css/size.css" />
  <link rel="stylesheet" type="text/css" href="css/common.css" />
  <link rel="stylesheet" type="text/css" href="css/color.css" />
  <link rel="stylesheet" type="text/css" href="css/size.css" />
</head>

<body>
  <div>
    <table class="border">
      <caption>[reference]developer.mozilla.org</caption>
      <thead>
        <tr class="border">
          <td class="border">
項目
          </td>
          <td class="border">
WebWorkers有無で共通化する仕様
          </td>
        </tr>
      </thead>
      <tbody>
        <tr class="border">
          <td class="border">
Worker宣言のURL
          </td>
          <td class="border">
mainスクリプト内で宣言する外部スクリプトfor_url.jsのURLは
<br>
index.htmlからの相対パスで記述する
<br>
<pre><code>
self.worker = new Worker("js/for_url.js");
</code></pre>
<br>
なお、main内の関数をcreateObjectURLで指定する方法は
<br>
次に示すimportScriptsを使用しない場合に限られる
          </td>
        </tr>
        <tr class="border">
          <td class="border">
外部スクリプト
          </td>
          <td class="border">
共通化する処理jobを別のスクリプトfor_importScripts.jsで定義してimportする
<br>
importするスクリプトのパスは外部スクリプトfor_url.jsからの相対パスで記述する
<br>
importするスクリプトが複数ある場合、カンマ区切りで読み込み順に並べる
<br>
これより外部スクリプトは最も単純に次のように記述される
<br>
なお、e.dataがmainから受け取るコピーdata（参照を持たないJSON形式）
<pre><code>
importScripts("for_importScripts.js");

onmessage = function(e){
  postMessage(My_job_imported(e.data));
};
</code></pre>
          </td>
        </tr>
        <tr class="border">
          <td class="border">
共通化するjob定義
          </td>
          <td class="border">
mainとworkerそれぞれでimportする共通のスクリプトにjobを定義する
<br>
mainから受け取ったdataを処理した後、同様のdataを返却する
<br>
いずれかのエラー発生場所を特定するためにwindowオブジェクトの存在可否を判定する
<br>
workerからはmainのwindowやdocumentにアクセスできないことに留意する
<br>
そのため、ここで定義するjobは並列化向きの画像処理や数値計算が一般的と考えられる
<pre><code>
var My_job_imported = function(_data){
  var out = null;
  var isWorker = (typeof window === "undefined");
  try{
    out = Math[_data.sw_job](_data.in);
  }
  catch(e){
    out = e.message;
    out += (isWorker)? "@worker": "@main";
    throw new Error(out);
  }
  _data.out = out;
  return _data;
};
</code></pre>
          </td>
        </tr>
        <tr class="border">
          <td class="border">
main依頼処理
          </td>
          <td class="border">
mainからworkerにまとめてarr_dataを渡すhandler_workerを用意し、排他処理を実施する
<br>
追加依頼を受けないロック状態にすることで並列処理のスレッド数に制限を設ける
<br>
さらに、スレッドの終了処理を確実に実施してからロック状態を解除する
<br>
他方、WebWorkersに対応していない環境ではシングルスレッドで実行する
<br>
共通化したMy_job_imported(data_in)をforEachで順番に実行し、
<br>
後述する受取り処理self.handlers.onmessageに返却dataを渡す
<pre><code>
  if(self.handler_worker.isLocked) return false;
  if(hasWorker){
    self.handler_worker.run(self.arr_data_in);
  }
  else{
    self.arr_data_in.forEach(function(data_in){
      self.handlers.onmessage({data: My_job_imported(data_in)});
    });
  }
</code></pre>
          </td>
        </tr>
        <tr class="border">
          <td class="border">
handler_worker
          </td>
          <td class="border">
上記のself.handler_worker.runの関数を以下に示す
<br>
WebWorkers非対応かロック状態の場合は即座にfalseを返却する
<br>
それ以外の場合はロックした後、
<br>
予め宣言したself.workerのpostMessageで外部スクリプトに繰り返しdataを送信する
<br>
なお、繰り返しnew Worker()を宣言する必要はないことに留意する
<pre><code>
My_handler_worker.prototype.run = function(arr_data){
  var self = this;
  if(!(self.hasWorker) || self.isLocked) return false;
  self.isLocked = true;
  arr_data.forEach(function(data){
    self.worker.postMessage(data);
  });
  return self;
};
</code></pre>
          </td>
        </tr>
        <tr class="border">
          <td class="border">
main受取り処理
          </td>
          <td class="border">
workerに登録する受取り処理とエラー処理のハンドラself.handlersをmain内に定義する
<br>
workerからはmain依頼順とは順不同にdataが返却されるため、
<br>
依頼順data.iに結果が並ぶように配列に代入してarr_data_out[data.i] = data
<br>
Object.keys(self.arr_data_out).lengthが
<br>
依頼したデータの長さself.arr_data_in.lengthに一致すれば終了判定する
<br>
また、終了処理を実施する
<br>
エラー発生時や中断時、body.onbeforeunload時も同様の終了処理を実施する
<br>
なお、このhandlerは別のスコープから呼ばれるので、thisをインスタンスselfでbindする
<pre><code>
  self.arr_data_out = [];
  self.handlers = {};
  self.handlers.onmessage = function(e){
    var self = this;
    var data = e.data;
    self.arr_data_out[data.i] = data;
    if(Object.keys(self.arr_data_out).length === self.arr_data_in.length){
      self.stop(true);
    }
    return self;
  };
  self.handlers.onerror = function(e){
    var self = this;
    self.stop(true);
    return self;
  };
  My$bind_objs(self, self.handlers);
</code></pre>
          </td>
        </tr>
        <tr class="border">
          <td class="border">
終了処理
          </td>
          <td class="border">
終了処理の関数を以下に示す
<br>
self.worker.terminate()を呼び出して全スレッドを強制終了する
<br>
また、メモリを解放するself.worker = null
<br>
さらに、ロック状態を解除する
<br>
再度利用する場合isReset時は再初期化re_initしてself.workerを再宣言する

<pre><code>
My_handler_worker.prototype.terminate = function(isReset){
  var self = this;
  self.worker.terminate();
  self.worker = null;
  self.isLocked = false;
  if(isReset){
    self.re_init();
  }
  return self;
};

My_handler_worker.prototype.re_init = function(){
  var self = this;
  self.init(self.url, self.handlers);
  return self;
};
</code></pre>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</body>

</html>
