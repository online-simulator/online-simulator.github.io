<!DOCTYPE html>

<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="description" content="[manual]Calculator">
  <meta name="author" content="online-simulator.github.io">
  <noscript>JavaScript is not enabled on browser.</noscript>
  <link rel="stylesheet" type="text/css" href="../00_common/css/common.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/color.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/size.css">
  <link rel="stylesheet" type="text/css" href="css/common.css">
  <link rel="stylesheet" type="text/css" href="css/color.css">
  <link rel="stylesheet" type="text/css" href="css/size.css">
</head>

<body>
  <div class="absolute">

<div>
<h2>[manual]Calculator</h2>
</div>

<hr>
<div>
<table>
<caption>初期表示の<a href="#span-out-com">複素数</a>演算の解は<a href="#span-out-options">外部option</a>の条件設定によって異なる</caption>
<thead>
  <tr>
    <th>
<a href="#span-out-option1">Associativity</a>
    </th>
    <th>
<a href="#span-out-option2">/prior2omitted*</a>
    </th>
    <th>
条件設定に依らない括弧明示
    </th>
    <th>
Answer
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td colspan="2">
下記4種類
    </td>
    <td>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
    </td>
    <td>
=e^(i{t})
   </td>
  </tr>
  <tr>
    <td class="condition">
left
    </td>
    <td class="condition">
false
    </td>
    <td class="condition">
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
    </td>
    <td class="condition">
=e^(i{-pi/4})
    </td>
  </tr>
  <tr>
    <td>
right
    </td>
    <td>
false
    </td>
    <td>
e^(-i({1pi()2}/{{2i(5-{3-1})i}/(-4)}))
    </td>
    <td>
=e^(i{-4pi/3})
    </td>
  </tr>
  <tr>
    <td>
left
    </td>
    <td>
true
    </td>
    <td>
e^(-i(1pi(){2/2i}({5-3}-1){i/(-4)}))
    </td>
    <td>
=e^(i{pi/4})
    </td>
  </tr>
  <tr>
    <td>
right
    </td>
    <td>
true
    </td>
    <td>
e^(-i(1pi(){2/2i}(5-{3-1}){i/(-4)}))
    </td>
    <td>
=e^(i{3pi/4})
    </td>
  </tr>
  <tr>
    <td colspan="4">
<a href="#span-out-ope">実数演算</a>不可（0*Infinity->NaN発生）
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption>[manual]Calculatorの前書き</caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
目次
    </th>
    <td>
<span id="span-index"></span>
本manualの目次を列挙する
<br>
<br>
前提
<br>
・
<a href="#span-pre-out">
外部仕様
</a>
<br>
・
<a href="#span-pre-in">
内部仕様
</a>
<br>
・
<a href="#span-pre-ref">
参考文献
</a>
<br>
・
<a href="#span-pre-paper">
参考論文
</a>
<br>
・
<a href="#span-pre-pat">
参考特許文献
</a>
<br>
<br>
<a href="#span-out">
外部仕様
</a>
<br>
・操作UI
<br>
　・
<a href="#span-out-UI-simple">
Simple Calculator
</a>
<br>
　・
<a href="#span-out-UI-graphing">
Graphing Calculator
</a>
<br>
　　・
<a href="#span-out-UI-graphing-color-space">
color空間
</a>
<br>
　　・
<a href="#span-out-UI-graphing-color">
color入力仕様
</a>
<br>
　　・
<a href="#span-out-UI-graphing-z">
z入力仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-legend">
legend-dataset
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-bgcolor">
bgcolor特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-gdcolor">
gdcolor特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-title">
graph-title特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-labels">
axis-labels特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-origin">
origin特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-string-path">
string-path特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-gradation">
gradation特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-transform">
transform特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-blur">
blur特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-filter">
filter特定項目仕様
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-filter-average">
averageぼかし
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-filter-average-asym">
非対称averageぼかし
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-filter-Gaussian">
Gaussぼかし
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-filter-tone-curve">
tone-curve特定項目仕様
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-post-transformer">
post-transformer特定項目仕様
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-post-compressor">
post-compressor特定項目仕様
</a>
<br>
　　　　・
<a href="#span-out-UI-graphing-post-processor">
post-processor特定項目仕様
</a>
<br>
　　　　　・
<a href="#span-out-UI-graphing-post-processor-encode">
encode仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-tile">
tile特定項目仕様
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-cut">
cut特定項目仕様
</a>
<br>
　　・
<a href="#span-out-UI-graphing-layer">
layer描画順
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-layer-background">
背景優先順
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-layer-grid">
grid-layer描画順
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-layer-plot">
plot-layer描画順
</a>
<br>
　　・
<a href="#span-out-UI-graphing-post">
post処理順
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-post1">
layer合成順
</a>
<br>
　　　・
<a href="#span-out-UI-graphing-post2">
post最終処理順
</a>
<br>
　　・
<a href="#span-out-UI-graphing-config">
plot-config
</a>
<br>
　　・
<a href="#span-out-UI-graphing-list">
strict-mode equation-list
</a>
<br>
・
<a href="#span-out-log-stamp">
log-stamp仕様
</a>
<br>
・
<a href="#span-out-log">
log表示仕様
</a>
<br>
・
<a href="#span-out-options">
外部option
</a>
<br>
　・
<a href="#span-out-option1">
2項演算子のassociativity
</a>
<br>
　・
<a href="#span-out-option2">
記号省略乗算
</a>
<br>
　・
<a href="#span-out-option4">
comma演算子
</a>
<br>
　・
<a href="#span-out-option3">
Multi-thread実行
</a>
<br>
・
<a href="#span-out-type-ope">
演算子の大分類
</a>
<br>
・
<a href="#span-out-associativity">
2項演算子のassociativity
</a>
<br>
・
<a href="#span-out-prec">
演算のprecedence
</a>
<br>
　・
<a href="#span-out-prec-ope">
演算子のprecedence
</a>
<br>
　　・
<a href="#span-out-prec-ope-arithmetic">
算術演算子
</a>
<br>
　　・
<a href="#span-out-prec-ope-bit">
bit演算子
</a>
<br>
　　・
<a href="#span-out-prec-ope-comparison">
比較演算子
</a>
<br>
　　・
<a href="#span-out-prec-ope-relational">
関係演算子
</a>
<br>
　　・
<a href="#span-out-prec-ope-logical">
論理演算子
</a>
<br>
・
<a href="#span-out-float">
浮動小数点演算
</a>
<br>
　・
<a href="#span-out-epsilon">
Machine epsilon
</a>
<br>
　・
<a href="#span-out-number">
Number型定数
</a>
<br>
・
<a href="#span-out-error">
誤差の扱い
</a>
<br>
　・
<a href="#span-out-error-numerical">
数値解の数値誤差
</a>
<br>
・
<a href="#span-out-config">
裏設定
</a>
<br>
　・
<a href="#span-out-config-strict">
strict-mode
</a>
<br>
・
<a href="#span-out-ope">
演算仕様
</a>
<br>
　・
<a href="#span-out-ope-extended">
拡張行列演算
</a>
<br>
　　・
<a href="#span-out-ope-extended-history">
拡張履歴
</a>
<br>
・
<a href="#span-out-types">
型の種類
</a>
<br>
・
<a href="#span-out-types-vars">
変数の種類
</a>
<br>
・
<a href="#span-out-scope-vars">
変数のscope
</a>
<br>
　・
<a href="#span-out-scope-inherited-call">
式変数のscope継承call
</a>
<br>
・
<a href="#span-out-storage">
storage
</a>
<br>
・
<a href="#span-out-bracket">
階層とscopeの関係
</a>
<br>
・
<a href="#span-out-eqns-args">
式変数のarguments
</a>
<br>
　・
<a href="#span-out-eqns-re-use">
scope付式変数の再利用
</a>
<br>
　・
<a href="#span-out-scope-inherited-call-memo">
式変数のscope継承callまとめ
</a>
<br>
・
<a href="#span-out-flow">
演算flow
</a>
<br>
・
<a href="#span-out-development">
開発環境
</a>
<br>
　・
<a href="#span-out-development-additional">
実装の特徴
</a>
<br>
　・
<a href="#span-out-development-problems">
仕様上の問題点
</a>
<br>
　　・
<a href="#span-out-development-problems-type">
型定義の問題点
</a>
<br>
　　・
<a href="#span-out-development-problems-complex">
複素数演算の問題点
</a>
<br>
　　・
<a href="#span-out-development-problems-CBR">
未実装の参照渡し
</a>
<br>
　　・
<a href="#span-out-development-problems-CAS">
未実装のCAS
</a>
<br>
・
<a href="#span-out-system">
動作test環境
</a>
<br>
　・
<a href="#span-out-system-test">
実機online-test手順
</a>
<br>
・
<a href="#span-out-requirements">
動作要件
</a>
<br>
　・
<a href="#span-out-browsers">
browser間の相違
</a>
<br>
　・
<a href="#span-out-browsers-ie">
Internet Explorer非対応の機能
</a>
<br>
・graph出力仕様
<br>
　・
<a href="#span-out-plot2d">
plot2d
</a>
<br>
・入力仕様
<br>
　・
<a href="#span-out-plot2d-command">
plot2d-command
</a>
<br>
　・
<a href="#span-out-comment">
comment文
</a>
<br>
　・
<a href="#span-out-command">
命令文
</a>
<br>
　・
<a href="#span-out-SR">
区切り文字
</a>
<br>
　・
<a href="#span-out-FNc">
最上位関数
</a>
<br>
　・
<a href="#span-out-BT">
括弧
</a>
<br>
　　・
<a href="#span-out-BT-associativity">
括弧のassociativity
</a>
<br>
　　・
<a href="#span-out-BT-square">
角括弧
</a>
<br>
　　　・
<a href="#span-out-BT-square-row">
行参照
</a>
<br>
　　　・
<a href="#span-out-BT-square-col">
列参照
</a>
<br>
　　　・
<a href="#span-out-BT-square-area">
area参照
</a>
<br>
　・
<a href="#span-out-RW">
予約語
</a>
<br>
　・
<a href="#span-out-FN0">
定数
</a>
<br>
　・
<a href="#span-out-BRmo">
記号省略乗算
</a>
<br>
　・
<a href="#span-out-com">
複素数
</a>
<br>
　・
<a href="#span-out-FN">
関数
</a>
<br>
　　・
<a href="#span-out-FN-args">
関数の引数
</a>
<br>
　　・
<a href="#span-out-FN-ope">
演算子代替関数
</a>
<br>
　　・
<a href="#span-out-FN-rand">
乱数関数
</a>
<br>
　　・
<a href="#span-out-FN-fact">
階乗関数
</a>
<br>
　　・
<a href="#span-out-FN-log">
log関数
</a>
<br>
　　・
<a href="#span-out-FN-atan2">
atan2関数
</a>
<br>
　・
<a href="#span-out-FNspecial">
特殊関数
</a>
<br>
　・
<a href="#span-out-mat">
行列
</a>
<br>
　・
<a href="#span-out-FNm0">
定数扱いの行列
</a>
<br>
　・
<a href="#span-out-FNm">
行列関数
</a>
<br>
　　・
<a href="#span-out-FNm-trans">
転置行列関数
</a>
<br>
　　・
<a href="#span-out-FNm-last">
last行列関数
</a>
<br>
　・
<a href="#span-out-array">
行列操作
</a>
<br>
　　・
<a href="#span-out-substitution-mat">
行列への代入
</a>
<br>
　　　・
<a href="#span-out-substitution-mat-row">
行代入
</a>
<br>
　　　・
<a href="#span-out-substitution-mat-col">
列代入
</a>
<br>
　　　・
<a href="#span-out-substitution-mat-area">
area代入
</a>
<br>
　　・
<a href="#span-out-concatination">
行列結合
</a>
<br>
　・
<a href="#span-out-FNmspecial">
特殊行列関数
</a>
<br>
　・
<a href="#span-out-vars">
変数
</a>
<br>
　　・
<a href="#span-out-vars-symbol">
変数名symbol
</a>
<br>
　　・
<a href="#span-out-ans">
予約変数
</a>
<br>
　　・
<a href="#span-out-substitution">
変数への代入
</a>
<br>
　・
<a href="#span-out-matching">
行列要素pattern matching
</a>
<br>
　・
<a href="#span-out-eqns">
式変数
</a>
<br>
　　・
<a href="#span-out-eqns-call">
式読出し
</a>
<br>
　　・
<a href="#span-out-call-by-equation">
式渡し
</a>
<br>
　　・
<a href="#span-out-substitution-equation">
式変数への式代入
</a>
<br>
　・
<a href="#span-out-FNh">
高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-switch">
switch高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-SX">
総和高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-PX">
総乗・総積高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-RX">
再帰高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-DX">
微分高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-IX">
積分高階関数
</a>
<br>
　・
<a href="#span-out-FNmh">
高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-jacobian">
Jacobi高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-newtonian">
Newton高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-OX">
ODE高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-EX">
symbolic高階行列関数
</a>
<br>
・解法
<br>
　・
<a href="#span-out-mat-product">
行列積
</a>
<br>
　・
<a href="#span-out-fdm">
有限差分法
</a>
<br>
　　・
<a href="#span-out-fdm-differential">
微分の数値解法
</a>
<br>
　　・
<a href="#span-out-fdm-integral">
積分の数値解法
</a>
<br>
　・
<a href="#span-out-fvm">
有限体積法
</a>
<br>
　　・
<a href="#span-out-fvm-about">
有限体積法の概要
</a>
<br>
　・
<a href="#span-out-modelling">
simplified modelling
</a>
<br>
　　・
<a href="#span-out-modelling-usefulness">
simplified modellingの有用性
</a>
<br>
　　・
<a href="#span-out-modelling-trade-off">
simplified modellingのtrade-off
</a>
<br>
　　・
<a href="#span-out-modelling-application1">
RC並列回路simplified modelling
</a>
<br>
　　・
<a href="#span-out-modelling-application2">
拡散方程式simplified modelling
</a>
<br>
　　・
<a href="#span-out-modelling-application3">
1D-cell simplified modelling
</a>
<br>
　・
<a href="#span-out-simulation">
simulation
</a>
<br>
　　・
<a href="#span-out-simulation-EIS">
EIS simulation
</a>
<br>
　　・
<a href="#span-out-simulation-EIS-1D-cell">
1D-cell EIS simulation
</a>
<br>
　　・
<a href="#span-out-simulation-IV-1D-cell">
1D-cell IV simulation
</a>
<br>
　・
<a href="#span-out-evolution">
時間発展
</a>
<br>
　・
<a href="#span-out-linear">
連立線形方程式
</a>
<br>
　・
<a href="#span-out-inverse">
逆行列
</a>
<br>
　・
<a href="#span-out-non-linear">
連立非線形方程式
</a>
<br>
　・
<a href="#span-out-transform">
信号変換
</a>
<br>
　　・
<a href="#span-out-transform-fft">
高速Fourier変換
</a>
<br>
　　・
<a href="#span-out-transform-dft">
離散Fourier変換
</a>
<br>
　　・
<a href="#span-out-transform-dwt">
離散Wavelet変換
</a>
<br>
　　・
<a href="#span-out-transform-dwt-col">
離散Wavelet変換（列代入）
</a>
<br>
　・
<a href="#span-out-series">
級数展開
</a>
<br>
　　・
<a href="#span-out-series-Taylor">
Taylor級数・Maclaurin級数
</a>
<br>
　　・
<a href="#span-out-series-Fourier">
Fourier級数
</a>
<br>
　・
<a href="#span-out-limit">
極限
</a>
<br>
・
<a href="#span-out-special">
特殊仕様
</a>
<br>
・
<a href="#span-out-application">
application
</a>
<br>
　・
<a href="#span-out-application-output">
最終output
</a>
<br>
・
<a href="#span-out-remain">
残課題
</a>
<br>
<br>
<a href="#span-in">
内部仕様
</a>
<br>
・
<a href="#span-in-tree">
単位tree構造
</a>
<br>
・
<a href="#span-in-scope-vars">
変数のscope
</a>
<br>
・
<a href="#span-in-options">
内部option
</a>
<br>
・
<a href="#span-in-myeval">
独自eval
</a>
<br>
・
<a href="#span-in-prec">
変数・関数・区切り文字・演算子のprecedence
</a>
<br>
・
<a href="#span-in-FN">
定義済みの関数・予約語
</a>
<br>
<br>
<a href="#span-eqn">
strict-mode式変数list
</a>
<br>
・
<a href="#span-eqn-template">
template
</a>
<br>
・
<a href="#span-eqn-average">
average
</a>
<br>
・
<a href="#span-eqn-average-asym">
average_asym
</a>
<br>
・
<a href="#span-eqn-Gaussian">
Gaussian
</a>
<br>
・
<a href="#span-eqn-plot2d_circle">
plot2d_circle
</a>
<br>
・
<a href="#span-eqn-plot2d_evolution">
plot2d_evolution
</a>
<br>
・
<a href="#span-eqn-SND_Px_erfx_erfcx">
SND/P(x)/erf(x)/erfc(x)
</a>
<br>
・
<a href="#span-eqn-matrix_product">
matrix_product
</a>
<br>
・
<a href="#span-eqn-rotationxyz">
rotationx/rotationy/rotationz-Right-Handed-System
</a>
<br>
・
<a href="#span-eqn-rotationxyz_LHS">
rotationx/rotationy/rotationz-Left-Handed-System
</a>
<br>
・
<a href="#span-eqn-solvex_Gauss">
solvex_Gauss
</a>
<br>
・
<a href="#span-eqn-solvex_pivotting">
solvex_pivotting
</a>
<br>
・
<a href="#span-eqn-solvex_no_pivotting">
solvex_no_pivotting
</a>
<br>
・
<a href="#span-eqn-solvex_iteration">
solvex_iteration
</a>
<br>
・
<a href="#span-eqn-solveAinv">
solveAinv
</a>
<br>
・
<a href="#span-eqn-solvex_non_linear">
solvex_non_linear
</a>
<br>
・
<a href="#span-eqn-implicit-Euler_method">
implicit Euler_method
</a>
<br>
・
<a href="#span-eqn-explicit-Euler_method">
explicit Euler_method
</a>
<br>
・
<a href="#span-eqn-explicit-ODE_RK4">
explicit ODE_RK4
</a>
<br>
・
<a href="#span-eqn-DFT1d">
DFT1d
</a>
<br>
・
<a href="#span-eqn-DFT2d_xy">
DFT2d_xy
</a>
<br>
・
<a href="#span-eqn-DFT2d_yx">
DFT2d_yx
</a>
<br>
・
<a href="#span-eqn-DWT1d">
DWT1d
</a>
<br>
・
<a href="#span-eqn-DWT2d_xy">
DWT2d_xy
</a>
<br>
・
<a href="#span-eqn-DWT2d_yx">
DWT2d_yx
</a>
<br>
・
<a href="#span-eqn-MaclaurinN">
MaclaurinN
</a>
<br>
・
<a href="#span-eqn-TaylorN">
TaylorN
</a>
<br>
・
<a href="#span-eqn-FourierN">
FourierN
</a>
<br>
・
<a href="#span-eqn-plot2d_EIS">
plot2d_EIS
</a>
<br>
・
<a href="#span-eqn-plot2d_EIS_DFT">
plot2d_EIS_DFT
</a>
<br>
・
<a href="#span-eqn-plot2d_IV">
plot2d_IV
</a>
    </td>
  </tr>
  <tr>
    <th>
外部仕様の前提
    </th>
    <td>
<span id="span-pre-out"></span>
外部仕様の前提について記述する
<br>
<br>
主として数値計算の基本となるCalculatorの仕様とtest caseを記録
<br>
<br>
説明上の前提を列挙する
<br>
・論理記号||は、ORを意味する
<br>
・arrow記号->の左側に入力の演算内容、右側に出力の演算結果を示す
<br>
　入力演算内容 -> 出力演算結果
<br>
　入力演算内容case1 || 入力演算内容case2 -> 出力演算結果
<br>
・誤差のOrderをLandauの記号O(指数表記1e-16等)で表記する
<br>
・vector||行列の成分を要素と表記する
<br>
・方程式||関数式を引数に取る関数を高階関数と表記する
<br>
　この場合の引数を通常の値渡しに対して式渡しと表記する
    </td>
  </tr>
  <tr>
    <th>
内部仕様の前提
    </th>
    <td>
<span id="span-pre-in"></span>
内部仕様の前提について記述する
<br>
<br>
任意scriptを実行可能なeval()不使用
<br>
Non-use of JavaScript's eval()
<br>
<br>
Calculator用途に特化した実装項目とfile名の対応関係を列挙する
<br>
・構文解析・字句解析・単位tree構造: parser.js/operation.js/DATA.js
<br>
・変数・関数・区切り文字・演算子のprecedence: operation.js
<br>
・演算unit: operation.js/unit.js
<br>
・定義済みの関数・予約語: parser.js/math.js/math_com.js/math_mat.js
<br>
　その他、built-inの関数・演算子を使用
<br>
・連立方程式の解法: solver.js
    </td>
  </tr>
  <tr>
    <th>
参考文献
    </th>
    <td>
<span id="span-pre-ref"></span>
参考文献について記述する
<br>
<br>
developer.mozilla.org/ja/docs/項目を列挙する
<br>
・浮動小数点数
<br>
・Number
<br>
・SVG要素リファレンス
<br>
<br>
en.m.wikipedia.org/wiki/項目を列挙する
<br>
・Von_Neumann_stability_analysis
<br>
・Fisher-Yates_shuffle
<br>
・Enigma_machine
<br>
・Rotation_formalisms_in_three_dimensions
<br>
・CIE_1931_color_space
<br>
・HSL_and_HSV
<br>
・Rainbow
<br>
<br>
ja.m.wikipedia.org/wiki/項目を列挙する
<br>
・JavaScriptエンジン
<br>
・演算子の優先順位
<br>
・IEEE_754
<br>
・誤差
<br>
・行列
<br>
・行列の乗法
<br>
・クロス積
<br>
・総和
<br>
・有限差分
<br>
・ルンゲ＝クッタ法
<br>
・ラグランジュ補間
<br>
・シンプソンの公式
<br>
・ラプラス変換
<br>
・フーリエ変換
<br>
・フーリエ級数
<br>
・ハールウェーブレット
<br>
・多重解像度解析
<br>
・ガンマ補正
<br>
・グレースケール
    </td>
  </tr>
  <tr>
    <th>
参考論文
    </th>
    <td>
<span id="span-pre-paper"></span>
参考論文について記述する
<br>
<br>
title/発行元(発行年)を列挙する
<br>
<span id="span-pre-paper1"></span>
1. THERMAL-ELECTROCHEMICAL COUPLED MODELING OF A LITHIUM-ION CELL
<br>
　Proceedings of the ECS(2000)
    </td>
  </tr>
  <tr>
    <th>
参考特許文献
    </th>
    <td>
<span id="span-pre-pat"></span>
参考特許文献について記述する
<br>
<br>
公開番号/発明の名称を列挙する
<br>
<span id="span-pre-pat1"></span>
1. WO2013128652
<br>
　リチウム二次電池用液保持体およびリチウム二次電池
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-out">Calculatorの設定項目と入力仕様に関する外部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Simple
<br>
Calculator
<br>
UI
    </th>
    <td>
<span id="span-out-UI-simple"></span>
Simple Calculatorの操作panelについて記述する
<br>
<br>
panel上段について記述する
<br>
・draggable checked時、drag移動有効化
<br>
・log出力欄に入力欄の演算結果のlogを表示
<br>
　文字数制限5000字以内
<br>
・入力欄に演算内容を入力
<br>
・sw checked時、push/pop入力と直接入力を切替え可
<br>
・0x checked時、16進数のa-f-buttonを追加表示
<br>
・complex checked時、<a href="#span-out-com">虚数単位</a>i-buttonを追加表示
<br>
・左側に0-9の数字と小数点.-buttonを表示
<br>
・右側に四則演算の演算子記号-buttonを表示
<br>
<br>
panel右側について記述する
<br>
・C-buttonは入力欄&amp;log出力欄の内容とglobal <a href="#span-out-storage">storage</a>のClear実行を確定する
<br>
　<a href="#span-out-option3">Multi-thread実行</a>の場合、演算を中断する
<br>
・BS-buttonは入力欄の選択位置の1字前を消去する
<br>
・ans-buttonはlog出力欄の演算結果を入力欄に確定する
<br>
　演算結果が実数以外の場合、入力欄を消去して<a href="#span-out-ans">予約変数</a>ansのtextを挿入
<br>
・＝-buttonは入力欄の内容で演算実行を確定する
<br>
<br>
panel中段について記述する
<br>
・complex checked時、<a href="#span-out-com">複素数</a>演算を有効化
<br>
　<a href="#span-out-com">虚数単位</a>i-buttonを追加表示
<br>
・matrix checked時、<a href="#span-out-mat">行列</a>演算を有効化
<br>
　定義可能な2項演算のみ
<br>
・演算結果の小数表記と指数表記を選択可
<br>
　小数表記: 0.1
<br>
　指数表記: 1e-1 -> 0.1
<br>
<br>
panel下段について記述する
<br>
・history欄に最新を上にして演算履歴を表示
<br>
　文字数制限5000字以内
<br>
・history欄下のlinkから演算履歴の全文をtext保存可
<br>
　入力欄のspell-check等でbrowser-busy状態の場合、download開始の待ち時間が生じる
<br>
<br>
一般的な電卓の操作性を再現する場合、all checkbox unchecked
<br>
・遅延しないSingle-threadの<a href="#span-out-ope">実数演算</a>
<br>
・応答時間=log表示待機時間50msec+<a href="#span-out-ope">演算量</a>に応じた演算時間
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Graphing
<br>
Calculator
<br>
UI
    </th>
    <td>
<span id="span-out-UI-graphing"></span>
Graphing Calculatorの操作panelについて記述する
<br>
<br>
panel上段について記述する
<br>
・canvas上部のlinkから描画結果のpng||svg||csvを保存可
<br>
　・pngは描画終了||中断後に保存可（逐次<a href="#span-out-UI-graphing-post1">layer合成</a>しない）
<br>
　・右click||long-tapによるpng保存不可（<a href="#span-out-UI-graphing-layer">最前面固定layer</a>は範囲選択領域の描画用）
<br>
　・svg||csvは<a href="#span-out-option3">Multi-thread実行</a>の場合、逐次保存可
<br>
　・png||svg出力共通でcanvas座標小数点以下floorの出力桁数0~9桁を選択可
<br>
・canvasにplot2dの演算&amp;描画結果を表示
<br>
　・mouse||touchによる範囲選択で拡大表示
<br>
　・single click||one tapで<del>拡大表示reset</del><span class="run">Ver.2.39.18</span>以降、その場でcentering
<br>
・log出力欄にplot2dの演算&amp;描画結果のlogを表示
<br>
・plot-buttonは演算&amp;描画実行を確定する
<br>
・stop-buttonは演算&amp;描画実行を中断する・軸scaleを初期化する
<br>
・l-checkboxはlegend表示を選択
<br>
・t入力欄に媒介変数の範囲下限t0と範囲上限t1の複素数値を入力
<br>
・<span class="run">Ver.2.34.18</span>以降、t-checkboxはlinear||logarithmicの軸scaleを選択
<br>
　<span class="run">Ver.2.50.25</span>以降、checked時、t0||t1の入力規則を緩和（実部||虚部のみに対応）
<br>
　<span class="run">Ver.2.50.25</span>以降、副次的にcomplex unchecked時、logarithmic-scale選択不能の不具合を解消
<br>
・媒介変数tの範囲等分割数Nを選択
<br>
・x(t)入力欄に横軸xの演算内容をsemi-colon;区切りで入力
<br>
　・tは媒介変数で上書き可能なlocal変数
<br>
　・直下のx-checkboxは<a href="#span-out-UI-graphing-labels">x-label</a>/x-values表示を選択
<br>
　　<span class="clear">Ver.2.53.26</span>以降、unchecked時、<a href="#span-out-UI-graphing-z">z入力欄</a>の<a href="#span-out-UI-graphing-labels">x-label</a>特定項目が残存する不具合を修正
<br>
　・log-checkboxは対数表示を選択
<br>
　・i-checkboxは虚数表示を選択
<br>
　・x(t)のplot範囲のaxis最小値~最大値を入力可
<br>
・y(t)入力欄に縦軸yの演算内容をsemi-colon;区切りで入力
<br>
　・tは媒介変数で上書き可能なlocal変数
<br>
　・直下のy-checkboxは<a href="#span-out-UI-graphing-labels">y-label</a>/y-values表示を選択
<br>
　　<span class="clear">Ver.2.53.26</span>以降、unchecked時、<a href="#span-out-UI-graphing-z">z入力欄</a>の<a href="#span-out-UI-graphing-labels">y-label</a>特定項目が残存する不具合を修正
<br>
　・log-checkboxは対数表示を選択
<br>
　・i-checkboxは虚数表示を選択
<br>
　・y(t)のplot範囲のaxis最小値~最大値を入力可
<br>
・<span class="run">Ver.2.36.18</span>以降、z-checkboxは<a href="#span-out-UI-graphing-gradation">gradation</a>/<a href="#span-out-UI-graphing-string-path">string-path</a>以外の表示を選択
<br>
　最終frameまでの特定項目を除く描画待ち時間||描画負荷を省略する場合、unchecked
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、gridのscalingに対応
<br>
・canvas範囲選択でx(t)||yt(t)のplot範囲の各axis最小値~最大値をlinear-scaleで自動更新
<br>
　複数の方程式||関数式の交点等を求める際に有効
<br>
<br>
<span class="run">Ver.2.39.18</span>以降、x0.1/x0.5/x1/x2/x10-buttonsは指定のzoom倍率でscalingを確定する
<br>
・zoom倍率はlinear-scale
<br>
・x1-buttonはscalingをresetする
<br>
・rel.-checkboxは原点に対してzoom中心位置を相対的に移動するrelative zoomingを選択
<br>
<br>
<span class="run">Ver.2.39.18</span>以降、gridのsnappingに対応
<br>
・long-tap||clickの300msec後にsnapping開始
<br>
　・canvas範囲選択でscaling
<br>
　・その場releaseでcentering
<br>
　・<span class="run">Ver.2.40.19</span>以降、x||y方向の移動なしで選択cancel
<br>
・snap-checkboxはgrid snappingを選択
<br>
<br>
<span class="clear">Ver.2.40.19</span>以降、click||tap連打による描画の排他処理を修正
<br>
・連打による副作用をonmouseup-handlerでlock判定して回避
<br>
・checkbox等UI操作も同様にlock判定されるため、弾かれた場合、unlock後に再描画が必要
<br>
・lock判定のreturn false直後にisLocked=true
<br>
・<span class="clear">Ver.2.40.20</span>以降、error終了時、isLocked=falseでdeadlockを回避
<br>
・以上より、副次的に2本指での範囲選択に対応
<br>
<br>
<span class="clear">Ver.2.40.20</span>以降、plot2d isNaN||isInfのerror終了時、描画resetから描画lockに変更
<br>
<br>
panel中段について記述する
<br>
・C-input-buttonは入力欄のtextを消去する
<br>
・list-vars-buttonはglobal変数の変数名listをlog出力欄に表示する
<br>
・list-eqns-buttonはglobal式変数の変数名listをlog出力欄に表示する
<br>
・plot2d(,)-buttonは入力欄の選択位置に<del>plot2d(,)</del>
<br>
　<span class="run">Ver.2.50.25</span>以降、plot2d(xt,yt)のtextを挿入する
<br>
・&lt;&lt;-buttonは入力欄の選択位置を最初に移動する
<br>
・&lt;-buttonは入力欄の選択位置を1字前に移動する
<br>
・&gt;-buttonは入力欄の選択位置を1字後に移動する
<br>
・&gt;&gt;-buttonは入力欄の選択位置を最後に移動する
<br>
・=-buttonは入力欄の内容で演算実行を確定する
<br>
・C-buttonは入力欄&amp;log出力欄の内容とglobal <a href="#span-out-storage">storage</a>のClear実行を確定する
<br>
　<a href="#span-out-option3">Multi-thread実行</a>の場合、演算を中断する
<br>
・BS-buttonは入力欄の選択位置の1字前を消去する
<br>
・DEL-buttonは入力欄の選択位置の1字後を消去する
<br>
・i-buttonは入力欄の選択位置に<a href="#span-out-com">虚数単位</a>iのtextを挿入する
<br>
・()-buttonは入力欄の選択位置に丸括弧()のtextを挿入する
<br>
・{}-buttonは入力欄の選択位置に波括弧{}のtextを挿入する
<br>
・ans-buttonは入力欄の選択位置に<a href="#span-out-ans">予約変数</a>ansのtextを挿入する
<br>
<br>
<a href="#span-out-option3">Multi-thread実行</a>の場合、plot-buttonと=-buttonは並列に実行可
<br>
・shared storage checked時、global <a href="#span-out-storage">storage</a>を共有
<br>
・plot-buttonによる演算はglobal storage readonly
<br>
<br>
panel下段は<a href="#span-out-UI-simple">Simple Calculator UI</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
color空間
    </th>
    <td>
<span id="span-out-UI-graphing-color-space"></span>
color空間について記述する
<br>
<br>
RGB-color空間
<br>
・Red（赤）
<br>
・Green（緑）
<br>
・Blue（青）
<br>
　主な用途は光の三原色による加法混合のdisplay
<br>
<br>
RGBA-color空間
<br>
・Alpha（不透明度）
<br>
　主な用途はcomputer graphics（HTML5描画canvas標準の場合、sRGBA-color空間）
<br>
<br>
HSV-color空間
<br>
・Hue（色相）
<br>
・Saturation（彩度∝RGB最大値-RGB最小値）
<br>
・Value（明度=RGB最大値）
<br>
　主な用途は直感的な操作のcolor-picker
<br>
　・SaturationをValueで正規化する場合、円柱model（色相環内側のpicker領域がsquare）
<br>
　・Saturationを正規化しない場合、円錐model（色相環内側のpicker領域がtriangle）
<br>
<br>
HSL-color空間
<br>
・Lightness（輝度=(RGB最小値+RGB最大値)/2）
<br>
　主な用途は直感的な操作のcolor-picker
<br>
<br>
XYZ-color空間（CIE 1931表色系）
<br>
・XYZ（Yを輝度とする3刺激値）
<br>
　主な用途は<a href="#span-out-UI-graphing-filter-tone-curve">gamma補正</a>前の仕様違いcolor空間の相互変換における包括的な中継
<br>
・CIE RGB->CIE XYZ線形変換
<br>
{$X,$Y,$Z}=scalars(3,1/0.17697)*(
<br>
0.49000,0.31000,0.20000:
<br>
0.17697,0.81240,0.010630:
<br>
0.0000,0.010000,0.99000
<br>
)*{R,G,B}
<br>
・CIE XYZ->CIE RGB線形逆変換（有効桁数5桁）
<br>
{$R,$G,$B}=(
<br>
0.4184657124218945,-0.15866078480379903,-0.08283492761809548:
<br>
-0.09116896390902272,0.2524314421394651,0.015707521769557607:
<br>
0.0009208986253436638,-0.0025498125468632836,0.1785989139215196
<br>
)*{X,Y,Z}
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
color
<br>
入力仕様
    </th>
    <td>
<span id="span-out-UI-graphing-color"></span>
color入力仕様について記述する
<br>
<br>
HTML5/CSS3準拠のcolor入力方法を次に示す
<br>
color名||HEX表記RGB||RGBA||rgb(r,g,b=0~255)||rgba(r,g,b,不透明度a=0~1)
<br>
<br>
透明黒色の初期状態を定義する
<br>
#0000||#00000000||rgba(0,0,0,0)
<br>
<br>
<a href="#span-out-UI-graphing-layer">最背面固定layer</a>に描画する千鳥格子の配色を定義する※格子size(8px)x(8px)
<br>
rgba(211,211,211,1)||lightgray
<br>
rgba(240,240,240,1)
<br>
<br>
color入力の一例を示す
<br>
・white
<br>
white||#fff||#ffff||#ffffff||#ffffffff||rgb(255,255,255)||rgba(255,255,255,1)
<br>
・black
<br>
black||#000||#000f||#000000||#000000ff||rgb(0,0,0)||rgba(0,0,0,1)
<br>
・gray
<br>
gray||#808080||#808080ff
<br>
・red
<br>
red||#f00||#f00f||#ff0000||#ff0000ff||rgb(255,0,0)||rgba(255,0,0,1)
<br>
・blueの不透明度a=0.333333333333333
<br>
#00f5||#0000ff55||rgba(0,0,255,0.333333333333333)
<br>
<br>
color-dataset入力の一例を示す
<br>
・<a href="#span-out-UI-graphing-gradation">gradation-colors</a>の7色rainbow入力の場合
<br>
・Newton説（音階analogyによる）
<br>
violet:indigo:blue:green:yellow:orange:red
<br>
#ee82ee:#4b0082:#0000ff:#00ff00:#ffff00:#ffa500:#ff0000
<br>
#ee82eecc:#4b0082cc:#0000ffcc:#00ff00cc:#ffff00cc:#ffa500cc:#ff0000cc
<br>
・<span class="run">Ver.2.42.20</span>以降、modern風
<br>
violet:blue:cyan:green:yellow:orange:red
<br>
#ee82ee:#0000ff:#00ffff:#00ff00:#ffff00:#ffa500:#ff0000
<br>
#ee82eecc:#0000ffcc:#00ffffcc:#00ff00cc:#ffff00cc:#ffa500cc:#ff0000cc
<br>
・<span class="run">Ver.2.44.22</span>以降、fade-in/out境界条件を追加
<br>
#ee82ee00:#ee82eecc:#0000ffcc:#00ffffcc:#00ff00cc:#ffff00cc:#ffa500cc:#ff0000cc:#ff000000
<br>
・近年、短波長側のindigo||cyanを消去して6色と数えるcaseが多い（虹の特殊文字等）
<br>
・主虹を裸眼で目視する場合、長波長で屈折率の低いredを外周とする（反射回数1回）
<br>
・主虹の外側に薄く映る副虹はその逆でredを内周とする（反射回数2回）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
z入力仕様
    </th>
    <td>
<span id="span-out-UI-graphing-z"></span>
z入力欄の入力仕様について記述する
<br>
<br>
<a href="#span-out-UI-graphing-legend">legend-dataset</a>をsemi-colon;区切りで入力
<br>
・空欄で既定の描画
<br>
・datasetは設定値をcolon:区切りで入力
<br>
markerType:markerColor:markerSize:markerLineWidth:plotLineWidth:fillPath:
<br>
str:strFontSize
<br>
<br>
以降、その他の特定項目を抽出順に列挙する
<br>
<br>
<span class="run">Ver.2.66.27</span>以降、<a href="#span-out-UI-graphing-bgcolor">bgcolor</a>を追加
<br>
bgcolor||BGCOLOR{<a href="#span-out-UI-graphing-color">color</a>}
<br>
・任意位置に挿入可
<br>
・<a href="#span-out-UI-graphing-layer-background">background-layer</a>に<a href="#span-out-UI-graphing-color">color</a>指定値を適用
<br>
<br>
<span class="run">Ver.2.66.27</span>以降、<a href="#span-out-UI-graphing-gdcolor">gdcolor</a>を追加
<br>
gdcolor||GDCOLOR{<a href="#span-out-UI-graphing-color">color</a>}
<br>
・任意位置に挿入可
<br>
・<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に<a href="#span-out-UI-graphing-color">color</a>指定値を適用
<br>
<br>
<span class="run">Ver.2.34.18</span>以降、<a href="#span-out-UI-graphing-title">graph-title</a>を追加
<br>
title||TITLE{graph-title}
<br>
・任意位置に挿入可
<br>
・graph-titleはcanvas上部に表示するtitleの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、<a href="#span-out-UI-graphing-labels">x-label</a>を追加
<br>
xlabel||XLABEL{x-label}
<br>
・任意位置に挿入可
<br>
・x-labelはx軸余白に表示するlabelの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、<a href="#span-out-UI-graphing-labels">y-label</a>を追加
<br>
ylabel||YLABEL{y-label}
<br>
・任意位置に挿入可
<br>
・y-labelはy軸余白に表示するlabelの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
<br>
<span class="run">Ver.2.67.27</span>以降、<a href="#span-out-UI-graphing-origin">origin</a>を追加
<br>
origin||ORIGIN{args}
<br>
・任意位置に挿入可
<br>
・originはorigin-labelと原点を通るorigin-lineで<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
・argsは設定値をcomma,区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>の設定値）
<br>
lineWidth,<a href="#span-out-UI-graphing-color">color</a>,labelSize
<br>
<br>
<span class="run">Ver.2.34.18</span>以降、<a href="#span-out-UI-graphing-string-path">string-path</a>を追加
<br>
string||STRING{config[]string-path}
<br>
・各<a href="#span-out-UI-graphing-legend">legend-dataset</a>の任意位置に挿入可
<br>
・string-pathはplot-lines上のpathに表示する任意文字列で<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>に描画
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>の設定値）
<br>
fontFamily:fontSize:isBold:isItalic:isReverse:
<br>
fillStyle:strokeStyle:fillStr:spacingX:spacingY:
<br>
shadowOffsetX:shadowOffsetY:shadowBlur:deg0
<br>
<br>
<span class="run">Ver.2.35.18</span>以降、<a href="#span-out-UI-graphing-title">graph-title</a>/<a href="#span-out-UI-graphing-legend">legend-string</a>/<a href="#span-out-UI-graphing-string-path">string-path</a>のwhite space enabled
<br>
<br>
<span class="run">Ver.2.36.18</span>以降、<a href="#span-out-UI-graphing-gradation">gradation</a>を追加
<br>
gradation||GRADATION{config[]colors}
<br>
・各<a href="#span-out-UI-graphing-legend">legend-dataset</a>の任意位置に挿入可
<br>
・gradationは<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>に描画
<br>
・colorsは<a href="#span-out-UI-graphing-color">color-dataset</a>をcolon:区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>のmarkerColor）
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略不可）
<br>
originX:originY:offsetR:orderR:NrandR:NrandT:isMin:isRound:Nrender:Ncycle
<br>
<br>
<span class="run">Ver.2.52.25</span>以降、<a href="#span-out-UI-graphing-transform">transform</a>を追加
<br>
transform||TRANSFORM{args}
<br>
・任意位置に挿入可
<br>
・transformは<a href="#span-out-UI-graphing-post1">layer合成</a>時の<a href="#span-out-UI-graphing-post">post処理</a>（<span class="run">Ver.2.56.26</span>以降、svg出力に対応）
<br>
・argsはcanvas座標変換の引数をcomma,区切りで入力
<br>
<br>
<span class="run">Ver.2.45.23</span>以降、<a href="#span-out-UI-graphing-blur">blur</a>を追加
<br>
blur||BLUR{<span class="condition">asym[]</span>config[]strengths}
<br>
・任意位置に挿入可
<br>
・blurは<a href="#span-out-UI-graphing-filter">filtering</a>直前の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・strengthsはfilter(2n-1)x(2n-1)sizeのn=0~20の数値をcolon:区切りで入力（省略時、0:10）
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略不可）
<br>
originX:originY:offsetR:orderR:NrandR:NrandT:isMin:isRound:Nrender:Ncycle:
<br>
isCyclic:<span class="jF">isSquare</span>:Nlegend（<span class="run">Ver.2.55.26</span>以降、項目名を変更）
<br>
・<span class="run">Ver.2.57.26</span>以降、<span class="condition">asym[]</span>内datasetは設定値をcomma,区切りで入力（省略時、0,0,1,0）
<br>
x,y,k,Nrad
<br>
<br>
<span class="run">Ver.2.44.22</span>以降、<a href="#span-out-UI-graphing-filter">filter</a>を追加
<br>
filter||FILTER{filters}
<br>
・任意位置に挿入可
<br>
・filterは<a href="#span-out-UI-graphing-post1">layer合成</a>後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・filtersは<span class="jF">mask[]</span><span class="condition">area[]</span>filterを適用順にcolon:区切りで入力
<br>
・<span class="run">Ver.2.52.25</span>以降、<span class="condition">area[]</span>内datasetは設定値をcomma,区切りで入力（省略時、全体に適用）
<br>
・<span class="run">Ver.2.63.27</span>以降、<span class="jF">mask[]</span>内datasetは設定値をcomma,区切りで入力（省略時、全体に適用）
<br>
<br>
<span class="run">Ver.2.68.27</span>以降、<a href="#span-out-UI-graphing-tile">tile</a>を追加
<br>
tile||TILE{args}
<br>
・任意位置に挿入可
<br>
・tileは<a href="#span-out-UI-graphing-filter">filtering</a>直後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・argsはtile領域を指定する条件をcomma,区切りで入力
<br>
<br>
<span class="run">Ver.2.63.27</span>以降、<a href="#span-out-UI-graphing-cut">cut</a>を追加
<br>
cut||CUT{args}
<br>
・任意位置に挿入可
<br>
・cutは<a href="#span-out-UI-graphing-filter">filtering</a>直後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は<a href="#span-out-UI-graphing-post1">layer合成</a>）
<br>
・argsはcut領域を指定する条件をcomma,区切りで入力
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
legend
<br>
-dataset
    </th>
    <td>
<span id="span-out-UI-graphing-legend"></span>
legend-datasetについて記述する
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にlegend-datasetをsemi-colon;区切りで入力
<br>
・legendは<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>に描画
<br>
・datasetは設定値をcolon:区切りで入力
<br>
markerType:markerColor:markerSize:markerLineWidth:plotLineWidth:fillPath:
<br>
str:strFontSize
<br>
・markerTypeはnone||circle||triangle||triangle2||square||diamond||cross
<br>
・markerColorはmarker-colorの入力値
<br>
・markerSizeはmarkerTypeの目安size
<br>
・markerLineWidthはmarker-line-widthのpx数値
<br>
・plotLineWidthはplot-line-widthのpx数値
<br>
・fillPathは0以外を指定でplot線を閉じてfill
<br>
・strはlegend-string
<br>
・strFontSizeはlegend-stringのfont-sizeのpx数値
<br>
・字句解析の都合上、legend-stringのsemi-colon; disabled
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
bgcolor
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-bgcolor"></span>
bgcolor特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.66.27</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にbgcolorを入力
<br>
bgcolor||BGCOLOR{<a href="#span-out-UI-graphing-color">color</a>}
<br>
・任意位置に挿入可
<br>
・<a href="#span-out-UI-graphing-layer-background">background-layer</a>に<a href="#span-out-UI-graphing-color">color</a>指定値を適用
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
gdcolor
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-gdcolor"></span>
gdcolor特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.66.27</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にgdcolorを入力
<br>
gdcolor||GDCOLOR{<a href="#span-out-UI-graphing-color">color</a>}
<br>
・任意位置に挿入可
<br>
・<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に<a href="#span-out-UI-graphing-color">color</a>指定値を適用
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
graph-title
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-title"></span>
graph-title特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.34.18</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にgraph-titleを入力
<br>
title||TITLE{graph-title}
<br>
・任意位置に挿入可
<br>
・graph-titleはcanvas上部に表示するtitleの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
axis-labels
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-labels"></span>
axis-labels特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にx-labelを入力
<br>
xlabel||XLABEL{x-label}
<br>
・任意位置に挿入可
<br>
・x-labelはx軸余白に表示するlabelの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にy-labelを入力
<br>
ylabel||YLABEL{y-label}
<br>
・任意位置に挿入可
<br>
・y-labelはy軸余白に表示するlabelの任意文字列で<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
origin
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-origin"></span>
origin特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.67.27</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にoriginを入力
<br>
origin||ORIGIN{args}
<br>
・任意位置に挿入可
<br>
・originはorigin-labelと原点を通るorigin-lineで<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
<br>
・argsは設定値をcomma,区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>の設定値）
<br>
lineWidth,<a href="#span-out-UI-graphing-color">color</a>,labelSize
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
string-path
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-string-path"></span>
string-path特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.34.18</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>にstring-pathを入力
<br>
string||STRING{config[]string-path}
<br>
・各<a href="#span-out-UI-graphing-legend">legend-dataset</a>の任意位置に挿入可
<br>
・string-pathはplot-lines上のpathに表示する任意文字列で<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>に描画
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>の設定値）
<br>
fontFamily:fontSize:isBold:isItalic:isReverse:
<br>
fillStyle:strokeStyle:fillStr:spacingX:spacingY:
<br>
shadowOffsetX:shadowOffsetY:shadowBlur:deg0
<br>
<span class="run">Ver.2.37.18</span>以降、各設定値のlimiterを追加
<br>
・fontFamilyはfont-family名（<span class="run">Ver.2.35.18</span>以降、white space付family名に対応）
<br>
・fontSize=0~32767はstring-pathのfont-sizeのpx数値
<br>
・isBold=0||white space以外でbold typeを使用
<br>
・isItalic=0||white space以外でitalic typeを使用
<br>
・isReverse=0||white spaceで始点から順送り・それ以外は終点から順送り
<br>
・fillStyleはfill-style
<br>
・strokeStyleはstroke-style
<br>
・fillStr=falseでstrokeのみ・fillStr=trueでfillのみ・それ以外はstroke&amp;fill
<br>
・spacingX=-32768~32767は文字送り空白部分のpx数値
<br>
・spacingY=-32768~32767は高さ方向空白部分のpx数値
<br>
・shadowBlur&gt;0でshadow有効（png/svg出力の互換性なし）
<br>
・shadowColorはfillStr=falseでstrokeStyle・fillStr=trueでfillStyle
<br>
・それ以外はfillStr=0~255を比例係数とするstrokeStyleとfillStyleのRGBA値の線形補間
<br>
・R値の一例を次に示す
<br>
shadowColor.r = strokeStyle.r+(fillStyle.r-strokeStyle.r)*Math.min(1, Math.abs(fillStr)/255)
<br>
・shadowOffsetX=-32768~32767はshadowのx方向offsetのpx数値
<br>
・shadowOffsetY=-32768~32767はshadowのy方向offsetのpx数値
<br>
・shadowBlur=-32768~32767はshadowの偏差
<br>
・character毎にsvg出力の度数degをpng出力の弧度数radに変換して互換性を確保
<br>
・以上の座標変換はcharacterのbottom-left基準
<br>
　<span class="run">Ver.2.37.18</span>以降、path上の回転角のみ、svg-&lt;textPath&gt;準拠のbottom基準に変更
<br>
・<span class="run">Ver.2.37.18</span>以降、config[]内datasetに設定項目deg0を追加
<br>
・deg0=0~360はcharacterのbottom-left基準の回転角の度数deg
<br>
　deg0=0||省略時・spacingX/Y=0||省略時、path上の回転角を使用
<br>
・字句解析の都合上、string-pathのsemi-colon; disabled
<br>
・仕様上、string-pathの4Bytes character disabled
<br>
・svg出力のみ、4Bytes characterを含む特殊文字等、直接file編集可（group化済み）
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、spacingX/Y=0||省略時、&lt;textPath&gt;によるsvg出力に対応
<br>
・回転角を含む座標変換のalgorithmが異なるため、png出力と若干の互換性を失う
<br>
・svg出力は縮小表示でtextPathが非表示になるが、png出力は非表示にならない
<br>
・string-pathにwhite spacesを含む場合、spellの扱いが異なる（1字に変換すれば統一可）
<br>
・&lt;textPath&gt;以外への流用等、利便性を考慮し、既定で&lt;path&gt;を出力する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
gradation
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-gradation"></span>
gradation特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.36.18</span>以降、指向性のない<a href="#span-out-UI-graphing-filter-Gaussian">Gaussぼかし</a>では再現困難な機能としてgradationを追加する
<br>
・<span class="run">Ver.2.40.18</span>以降、legend間のgradation合成に対応
<br>
・<span class="run">Ver.2.60.26</span>以降、<span class="selection">circle-mode@Ncycle=0</span>を追加
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にgradationを入力
<br>
gradation||GRADATION{config[]colors}
<br>
・各<a href="#span-out-UI-graphing-legend">legend-dataset</a>の任意位置に挿入可
<br>
・gradationは<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>に描画
<br>
・gradation起点からplot-lineまでの半径方向に生成
<br>
・colorsは<a href="#span-out-UI-graphing-color">color-dataset</a>をcolon:区切りで入力（省略時、<a href="#span-out-UI-graphing-legend">legend-dataset</a>のmarkerColor）
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略不可）
<br>
originX:originY:offsetR:<span class="clear">orderR:NrandR:NrandT:isMin:isRound:Nrender</span>:Ncycle
<br>
・svg出力は<span class="clear">orderR:NrandR:NrandT:isMin:isRound:Nrender</span> disabled
<br>
・originXはplot座標系x方向linear-scaleのgradation起点
<br>
・originYはplot座標系y方向linear-scaleのgradation起点
<br>
・offsetR=0~1はgradation代表長さのoffset係数
<br>
　offsetR=0の場合、最外周を除く内周にgradationの周期境界条件を課す
<br>
・orderR=0~10は半径方向の補間次数
<br>
　orderR=0の場合、svg出力相当のuniform
<br>
　orderR=1の場合、既定の線形補間
<br>
・NrandR=0~255はgradation代表長さの<a href="#span-out-FN-rand">乱数</a>
<br>
・NrandT=0~255はgradation分布の<a href="#span-out-FN-rand">乱数</a>
<br>
・isMin=false||true||&lt;0(auto)はgradation代表長さの一意な決め方を指定する
<br>
　falseの場合、gradation起点から各周plot点までの最大値を保持
<br>
　trueの場合、gradation起点から各周plot点までの最小値を保持
<br>
　負の場合、成行きで保持
<br>
・isRound=false||trueはplot点の存在しない領域の補間方法を選択する
<br>
　falseの場合、plot座標系で線形補間（<span class="clear">plot間vectorを等分割して回転角に変換する誤差あり</span>）
<br>
　trueの場合、gradation起点からplot点までの長さ空間で線形補間（<span class="clear">false同様の誤差あり</span>）
<br>
・Nrender=1~32767は周方向のrendering分割数（数値以外を指定時、tの範囲等分割数N）
<br>
・Ncycle=0~127は半径方向のrendering周期数
<br>
<br>
<span class="run">Ver.2.60.26</span>以降、<span class="selection">circle-mode@Ncycle=0</span>を追加
<br>
・canvas座標でgradation起点を中心にplot-lineの周方向に生成（<a href="#span-out-UI-graphing-config">canvas-size</a>に依存）
<br>
・config[]内datasetの変化点を示す
<br>
originX:originY:offsetR:orderR:NrandR:NrandT:isMin:<span class="clear">isRound</span>:Nrender:<span class="selection">Ncycle=0</span>
<br>
・<span class="clear">isRound</span> disabled
<br>
・offsetR=0~1は1周のoffset係数
<br>
　offsetR=0の場合、gradationの周期境界条件を課す
<br>
・NrandR=0~255はgradation間隔の<a href="#span-out-FN-rand">乱数</a>
<br>
・isMin=false||trueはrenderingの重複を判定する
<br>
　falseの場合、成行きでrendering
<br>
　trueの場合、重複判定でrenderingをskip
<br>
<br>
algorithmが異なるため、png/svg出力の互換性なし
<br>
<br>
svg出力の特徴を列挙する
<br>
・Nrender無効
<br>
・plot点に比例係数を演算してgradationを作るため、意図に近い結果が得られる
<br>
・legend間のgradation合成可（source-over）
<br>
・<a href="#span-out-FN-rand">乱数</a>使用不可
<br>
・<span class="selection">circle-mode@Ncycle=0</span>の場合、周方向の分割数=(NrandT||10)*colors.length
<br>
・gradation精度を上げる場合、colorsを細かく刻んで指定する
<br>
<br>
png出力の特徴を列挙する
<br>
・rendering方式でRGBA値を補間するため、gradation精度が高い
<br>
・isMin設定値によってcyclic star||spiral等、意図した結果が得られるとは限らない
<br>
・isRound設定項目の変換誤差を許容するため、
<br>
　svg出力同等||完全に意図通りの結果は得られない（<span class="clear">Ver.2.44.23</span>追記）
<br>
・<span class="run">Ver.2.40.18</span>以降、legend間のgradation合成に対応
<br>
<del>・legend間のgradation合成不可（合成する場合、複数回の分割出力が必要）
<br>
・putImageData()同期出力のため、<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>無効（source-over）</del>
<br>
・<a href="#span-out-FN-rand">乱数</a>使用可
<br>
・Nrender=1で真円のgradationが比較的簡単に得られる
<br>
<br>
形状再現精度||gradation精度に関係する設定項目を列挙する
<br>
・媒介変数tの範囲等分割数N
<br>
・周方向のrendering分割数Nrender
<br>
・png||svg出力桁数
<br>
・<span class="selection">circle-mode@Ncycle=0</span>の場合
<br>
　・<a href="#span-out-UI-graphing">plot範囲の各axis最小値~最大値</a>
<br>
　・<a href="#span-out-UI-graphing-config">canvas-size</a>@<a href="#span-out-UI-graphing">z-checkbox</a> unchecked
<br>
<br>
留意事項を列挙する
<br>
・上記精度を上げ過ぎた場合、svg出力のfile sizeや<a href="#span-out-UI-graphing-post">post処理</a>の負荷が増大する
<br>
・<a href="#span-out-FN-rand">乱数</a>設定時、flickering防止のため、plot終了の最終frameまで逐次描画しない
<br>
・drawImage()非同期出力のため、最終frameにlegend順を保証してgradationを合成する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
transform
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-transform"></span>
transform特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.52.25</span>以降、<a href="#span-out-UI-graphing-post1">layer合成</a>時の座標変換機能を追加する
<br>
・<span class="clear">Ver.2.53.25</span>以降、<span class="run">せん断変形の結果</span>から<span class="condition">座標変換行列</span>の一部(<span class="clear">b:c</span>)の位置関係を交換して訂正
<br>
・<span class="run">Ver.2.56.26</span>以降、設定項目withBackgroundを追加
<br>
・<span class="run">Ver.2.56.26</span>以降、svg出力に対応
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にtransformを入力
<br>
transform||TRANSFORM{args}
<br>
・任意位置に挿入可
<br>
・transformは<a href="#span-out-UI-graphing-post1">layer合成</a>時の<a href="#span-out-UI-graphing-post">post処理</a>（<span class="run">Ver.2.56.26</span>以降、svg出力に対応）
<br>
・argsはcanvas座標変換ctx.setTransform(<span class="selection">a,b,c,d,e,f</span>)の引数をcomma,区切りで入力
<br>
transform{<span class="selection">a,b,c,d,e,f</span>,withBackground||0}
<br>
・各引数の定義
<br>
2次元Euclid実空間の<a href="#span-out-FNmspecial">回転行列</a>(<span class="selection">a</span>,<span class="clear">c:b</span>,<span class="selection">d</span>)
<br>
px数値の並進vector{<span class="selection">e,f</span>}
<br>
・withBackground=0||1（<a href="#span-out-UI-graphing-layer-background">background-layer</a>にtransformを適用する場合、1）
<br>
・<span class="condition">座標変換行列</span>の定義
<br>
transform3x3=(
<br>
<span class="selection">
a,c,e:
<br>
b,d,f:
</span>
<br>
0,0,1
<br>
)
<br>
transpose(transform3x3) -> (
<br>
<span class="selection">a,b,</span>0:
<br>
<span class="selection">c,d,</span>0:
<br>
<span class="selection">e,f,</span>1
<br>
)
<br>
・列vectorの場合
<br>
{x_after,y_after,1}=transform3x3*{x_before,y_before,1}
<br>
・行vectorの場合
<br>
(x_after,y_after,1)=(x_before,y_before,1)*transpose(transform3x3)
<br>
・同義
<br>
x_after=x_before<span class="selection">*a</span>+y_before<span class="selection">*c</span>+1<span class="selection">*e</span>
<br>
y_after=x_before<span class="selection">*b</span>+y_before<span class="selection">*d</span>+1<span class="selection">*f</span>
<br>
・逆変換
<br>
determinant=(<span class="selection">a*d-b*c</span>)
<br>
inverse(transform3x3) -> (
<br>
(1/determinant)*(d,-c,c*f-e*d):
<br>
(1/determinant)*(-b,a,e*b-a*f):
<br>
(1/determinant)*(0,0,a*d-c*b)
<br>
)
<br>
x_before=(1/determinant)*(x_after<span class="selection">*d</span>+y_after<span class="selection">*(-c)</span>+1<span class="selection">*(c*f-e*d)</span>)
<br>
y_before=(1/determinant)*(x_after<span class="selection">*(-b)</span>+y_after<span class="selection">*a</span>+1<span class="selection">*(e*b-a*f)</span>)
<br>
・演算に使用する場合、<a href="#span-out-com">Napier数</a>eと区別が必要
<br>
<br>
test caseを列挙する
<br>
・基準{x_before,y_before,1}={1,1,1}
<br>
{1,0,0,1,0,0}
<br>
args={1,0,0,1,0,0};
<br>
transform3x3=(args[0],args[2],args[4]:args[1],args[3],args[5]:0,0,1);
<br>
{$x_before,$y_before,1}={1,1,1};
<br>
{$x_after,$y_after,1}=transform3x3*{x_before,y_before,1};
<br>
{x_after,y_after,1} -> (1:1:1)
<br>
・x方向2倍(a,d)=(2,1)
<br>
{2,0,0,1,0,0}
<br>
{x_after,y_after,1} -> (2:1:1)
<br>
・y方向2倍(a,d)=(1,2)
<br>
{1,0,0,2,0,0}
<br>
{x_after,y_after,1} -> (1:2:1)
<br>
・並進(e,f)=(-100,100)
<br>
{1,0,0,1,-100,100}
<br>
{x_after,y_after,1} -> (-99:101:1)
<br>
・x方向反転並進(a,e)=(-1,100)
<br>
{-1,0,0,1,100,0}
<br>
{x_after,y_after,1} -> (99:1:1)
<br>
・y方向反転並進(d,f)=(-1,100)
<br>
{1,0,0,-1,0,100}
<br>
{x_after,y_after,1} -> (1:99:1)
<br>
・x/y方向反転並進(a,d,e,f)=(-1,-1,100,100)
<br>
{-1,0,0,-1,100,100}
<br>
{x_after,y_after,1} -> (99:99:1)
<br>
・回転(a,b)=(d,-c)
<br>
　・回転角=pi/4
<br>
<a href="#span-eqn-rotationxyz_LHS">rotz_LHS(psi)</a>=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;;
<br>
Rz=rotz_LHS(pi/4); Rz[0][0],Rz[0][1],Rz[1][0],Rz[1][1]
<br>
-> 0.7071067811865476,0.7071067811865475,-0.7071067811865475,0.7071067811865476
<br>
{0.7071067811865476,0.7071067811865475,-0.7071067811865475,0.7071067811865476,0,0}
<br>
{x_after,y_after,1} -> (1.1102230246251565e-16:1.414213562373095:1)
<br>
　・(a,b)=(0.5,0.2)
<br>
{0.5,0.2,-0.2,0.5,0,0}
<br>
{x_after,y_after,1} -> (0.3:0.7:1)
<br>
・<span class="run">x方向せん断変形</span>(b,c)=(0,0.5)
<br>
{1,0,0.5,1,0,0}
<br>
{x_after,y_after,1} -> (<span class="run">1.5</span>:1:1)
<br>
・<span class="run">y方向せん断変形</span>(b,c)=(0.5,0)
<br>
{1,0.5,0,1,0,0}
<br>
{x_after,y_after,1} -> (1:<span class="run">1.5</span>:1)
<br>
・視線変更
<br>
{1,0.1,-0.5,0.5,50,50}
<br>
{x_after,y_after,1} -> (50.5:50.6:1)
<br>
<br>
留意事項を列挙する
<br>
・<a href="#span-out-UI-graphing-post1">layer合成</a>後の<a href="#span-out-UI-graphing-blur">blurring</a>||<a href="#span-out-UI-graphing-filter">filtering</a>はputImageData()同期出力のため、transform無効
<br>
・<a href="#span-out-UI-graphing-post1">layer合成</a>後の<a href="#span-out-UI-graphing-blur">blurring</a>||<a href="#span-out-UI-graphing-filter">filtering</a>にtransformを適用する場合、<a href="#span-out-UI-graphing-post-transformer">post-transformer</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
blur
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-blur"></span>
blur特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.45.23</span>以降、<a href="#span-out-UI-graphing-filter-average">averageぼかし</a>を応用して指向性のblurを追加する
<br>
・<span class="clear">Ver.2.45.24</span>以降、strength=0で正常に機能しない致命的な不具合を修正
<br>
・<span class="run">Ver.2.55.26</span>以降、一部の設定項目名を<span class="jF">isSquare</span>に変更
<br>
・<span class="run">Ver.2.57.26</span>以降、<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>に対応（<span class="condition">asym[]</span>の設定項目を追加）
<br>
・<span class="run">Ver.2.60.26</span>以降、<span class="selection">circle-mode@Ncycle=0</span>を追加
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にblurを入力
<br>
blur||BLUR{<span class="condition">asym[]</span>config[]strengths}
<br>
・任意位置に挿入可
<br>
・blurは<a href="#span-out-UI-graphing-filter">filtering</a>直前の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・strengthsはfilter(2n-1)x(2n-1)sizeのn=0~20の数値をcolon:区切りで入力（省略時、0:10）
<br>
・config[]内datasetは設定値をcolon:区切りで入力（省略不可）
<br>
<span class="selection">originX:originY:offsetR:orderR:NrandR:NrandT:isMin:isRound:Nrender:Ncycle</span>:
<br>
isCyclic:<span class="jF">isSquare</span>:Nlegend（<span class="run">Ver.2.55.26</span>以降、項目名を変更）
<br>
・<span class="selection">上段</span>は<a href="#span-out-UI-graphing-gradation">gradation</a>参照
<br>
・<span class="run">Ver.2.57.26</span>以降、<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>の場合、下流側で<span class="selection">Nrender</span>=1~2560に上限値を圧縮
<br>
　<a href="#span-out-UI-graphing-filter-average">averageぼかし</a>の場合、memory size&lt;20MB
<br>
　<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>の場合、memory size&lt;200MB
<br>
・isCyclic=false||trueは1周期外（2周期目以降）のblur条件を選択する
<br>
　falseの場合、strengthsの最終値で固定してblurを適用
<br>
　trueの場合、周期的にblurを適用
<br>
・<span class="jF">isSquare</span>=false||trueは適用する<a href="#span-out-UI-graphing-filter">filter</a>の種類を選択する
<br>
　falseの場合、<a href="#span-out-UI-graphing-filter-average">average_circle</a>
<br>
　trueの場合、<a href="#span-out-UI-graphing-filter-average">average_square</a>
<br>
・Nlegend=1~lastはblurを適用するplot-lineのlegend番号
<br>
　範囲外の数値||数値以外を指定した場合、最終legendを選択
<br>
・<span class="run">Ver.2.57.26</span>以降、<span class="condition">asym[]</span>内datasetは設定値をcomma,区切りで入力（省略時、0,0,1,0）
<br>
asym[x||0,y||0,k||0,Nrad||0]
<br>
・各設定値の詳細は<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>参照
<br>
・Nradは<a href="#span-out-FNmspecial">回転行列</a>の弧度数rad=pi/Nradに換算するpiの分割数（Nrad=0の場合、rad=0）
<br>
・radはplot-lineの接線方向（1次近似）を基準とする独立変数
<br>
<br>
test caseを列挙する
<br>
・strength分布に<a href="#span-out-FN-rand">乱数</a>を適用（glass morphism効果を模擬）
<br>
config[0:0:0:1:0:50:false:false:2560:4:true:false:last]
<br>
・glass morphism効果を強化して密に適用
<br>
config[0:0:0:1:0:200:false:false:2560:4:true:false:last]0:10:0:10:0:10:0:10:0:10:0:10
<br>
config[0:0:0:1:0:200:false:false:2560:4:true:false:last]10:0:10:0:10:0:10:0:10:0:10:0
<br>
<span class="run">Ver.2.60.26</span>以降、<span class="selection">circle-mode@Ncycle=0</span>を追加
<br>
・Nlegend=1のplot-line上でstrength=0の周期境界条件を適用
<br>
config[0:0:0:1:0:0:false:false:2560:0:true:false:1]0:8
<br>
config[0:0:0:1:0:0:false:false:2560:0:true:false:1]0:8:8
<br>
・Nlegend=1のplot-line上でstrength=0の非周期境界条件を適用
<br>
config[0:0:0:1:0:0:false:false:2560:0:false:false:1]0:8:0
<br>
config[0:0:0:1:0:0:false:false:2560:0:false:false:1]0:8:8:0
<br>
・Nlegend=1のplot-line上でstrength=8の周期境界条件を適用
<br>
config[0:0:0:1:0:0:false:false:2560:0:true:false:1]8:0
<br>
config[0:0:0:1:0:0:false:false:2560:0:true:false:1]8:0:0
<br>
・Nlegend=1のplot-line上でstrength=8の非周期境界条件を適用
<br>
config[0:0:0:1:0:0:false:false:2560:0:false:false:1]8:0:8
<br>
config[0:0:0:1:0:0:false:false:2560:0:false:false:1]8:0:0:8
<br>
・<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>を適用
<br>
<span class="condition">asym[0,0,3,0]</span>config[0:0:0:1:0:0:false:false:2560:0:true:false:1]0:8:8
<br>
<br>
形状再現精度||blur精度に関係する設定項目を列挙する
<br>
・媒介変数tの範囲等分割数N
<br>
・周方向のrendering分割数Nrender
<br>
<br>
留意事項を列挙する
<br>
・svg出力は無効
<br>
・putImageData()同期出力のため、<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>無効（source-over）
<br>
・strengthsの数値に応じて<a href="#span-out-UI-graphing-post">post処理</a>の負荷がexponentialに増大する（中断不可）
<br>
・strengthsに数値以外を指定した場合、該当のstrength=0とする
<br>
・<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>の場合、strength&lt;max(x,y)の領域で空白発生の可能性がある
<br>
・同様に、ImageDataが欠落する描画canvas境界で空白発生の可能性がある
<br>
・空白部分は<a href="#span-out-UI-graphing-color">透明黒色</a>とする
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
filter
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-filter"></span>
filter特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.44.22</span>以降、<a href="#span-out-UI-graphing-post">post処理</a>の付録機能（未最適化）としてfilterを追加する
<br>
・<span class="clear">Ver.2.44.23</span>以降、各RGBA値=0で正常に機能しない致命的な不具合を修正
<br>
・<span class="run">Ver.2.46.24</span>以降、HSV-<a href="#span-out-UI-graphing-color-space">color空間</a>に対応
<br>
・<span class="clear">Ver.2.48.25</span>以降、描画canvas境界で正常に機能しない不具合を修正
<br>
・<span class="run">Ver.2.52.25</span>以降、filterを適用する<span class="condition">canvas-area</span>の設定項目を追加
<br>
・<span class="clear">Ver.2.60.27</span>以降、<span class="condition">canvas-area</span>のlimiter-<a href="#span-out-UI-graphing-config">canvas-size(canvas-width,canvas-height)</a>を追加
<br>
・<span class="run">Ver.2.63.27</span>以降、filter適用前後のmask領域を指定する<span class="jF">canvas-mask</span>の設定項目を追加
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にfilterを入力
<br>
filter||FILTER{filters}
<br>
・任意位置に挿入可
<br>
・filterは<a href="#span-out-UI-graphing-post1">layer合成</a>後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・filtersは<span class="jF">mask[]</span><span class="condition">area[]</span>filterを適用順にcolon:区切りで入力
<br>
・<span class="run">Ver.2.52.25</span>以降、<span class="condition">area[]</span>内datasetは設定値をcomma,区切りで入力（省略時、全体に適用）
<br>
area[x||0,y||0,w||<a href="#span-out-UI-graphing-config">canvas-width</a>,h||<a href="#span-out-UI-graphing-config">canvas-height</a>]
<br>
・<span class="condition">canvas-area</span>は始点(x,y)とarea-size(w,h)を直列化してpx数値で指定する
<br>
・<span class="clear">Ver.2.60.27</span>以降、下流側で致命的な不具合に繋がる入力を回避
<br>
area[0,0,<span class="clear">1e13</span>] -> Value is outside the 'long' value range.
<br>
area[<span class="clear">-1e9,,1e9</span>] -> Out of memory at ImageData creation
<br>
　⇒　area[0,0,<a href="#span-out-UI-graphing-config">canvas-width,canvas-height</a>]
<br>
・<span class="run">Ver.2.63.27</span>以降、<span class="jF">mask[]</span>内datasetは設定値をcomma,区切りで入力（省略時、全体に適用）
<br>
mask[Nlegend||last,isInverse||false,isClear||false]
<br>
・Nlegend=1~lastはmask領域を指定するplot-lineのlegend番号
<br>
　範囲外の数値||数値以外を指定した場合、最終legendを選択
<br>
・isInverse=false||trueはmask領域の内外を反転する
<br>
　falseの場合、mask領域の内側のみにfilterを適用
<br>
　trueの場合、mask領域の外側のみにfilterを適用
<br>
・isClear=false||trueはfilter適用範囲外の処理を選択する
<br>
　falseの場合、filter適用前のRGBA値を保持
<br>
　trueの場合、<a href="#span-out-UI-graphing-color">透明黒色</a>にRGBA値をclear
<br>
<br>
filterは上下左右対称(2n-1)x(2n-1)sizeの2次元配列を1次元に直列化して定義する
<br>
・2次元配列の中央要素をfilter対象pixelとして周囲pixelを含む重みを数値で指定する
<br>
・非対称(2n)x(2n)sizeのfilterは対称(2n+1)x(2n+1)sizeを基準に設定する
<br>
・filterを適用するRGBAの組合せは任意に選択可（順不同）
<br>
・<span class="run">Ver.2.46.24</span>以降、円柱HSV||円錐HSV_coneの組合せを追加
<br>
・RGBA/HSVの組合せを併記した場合、filtering手順を次に示す
<br>
　最終frameを取得　⇒　RGB->HSV非線形順変換　⇒　HSV-<a href="#span-out-UI-graphing-color-space">color空間</a>でfiltering
<br>
　⇒　HSV->RGB非線形逆変換　⇒　RGBA-<a href="#span-out-UI-graphing-color-space">color空間</a>でfiltering　⇒　処理結果を出力
<br>
<br>
加重平均filterの一例を示す
<br>
・RGBA値Gaussian3x3（<a href="#span-out-UI-graphing-filter-Gaussian">簡易なGaussぼかし</a>）
<br>
rgba[1,2,1,2,<span class="selection">4</span>,2,1,2,1]
<br>
・<span class="selection">対象pixel</span>の重みを最大値4として周囲pixelを含む次の重み平均を正規化する
<br>
[
<br>
1,2,1,
<br>
2,<span class="selection">4</span>,2,
<br>
1,2,1
<br>
]
<br>
・RGBA値x方向average3x3
<br>
rgba[0,0,0,1,<span class="selection">1</span>,1,0,0,0]
<br>
[
<br>
0,0,0,
<br>
1,<span class="selection">1</span>,1,
<br>
0,0,0
<br>
]
<br>
・RGBA値y方向average3x3
<br>
rgba[0,1,0,0,<span class="selection">1</span>,0,0,1,0]
<br>
[
<br>
0,1,0,
<br>
0,<span class="selection">1</span>,0,
<br>
0,1,0
<br>
]
<br>
・RGBA値x/y方向average3x3
<br>
rgba[0,1,0,1,<span class="selection">1</span>,1,0,1,0]
<br>
[
<br>
0,1,0,
<br>
1,<span class="selection">1</span>,1,
<br>
0,1,0
<br>
]
<br>
・RGB値<a href="#span-out-UI-graphing-filter-average">average_square</a>3x3
<br>
rgb[1,1,1,1,<span class="selection">1</span>,1,1,1,1]
<br>
[
<br>
1,1,1,
<br>
1,<span class="selection">1</span>,1,
<br>
1,1,1
<br>
]
<br>
・<a href="#span-out-UI-graphing-filter-average">average_square</a>4x4は<span class="clear">定義不可</span>（<a href="#span-out-UI-graphing-filter-average">average_square</a>3x3に同義）
<br>
rgb[1,1,1,1,<span class="selection">1</span>,1,1,1,1<span class="clear">,1,1,1,1,1,1,1</span>]
<br>
[
<br>
1,1,1,
<br>
1,<span class="selection">1</span>,1,
<br>
1,1,1
<br>
]
<br>
・RGB値<a href="#span-out-UI-graphing-filter-average">average_circle</a>3x3
<br>
rgb[0,1,0,1,<span class="selection">1</span>,1,0,1,0]
<br>
[
<br>
0,1,0,
<br>
1,<span class="selection">1</span>,1,
<br>
0,1,0
<br>
]
<br>
・RGB値sharpness3x3
<br>
rgb[-1,-1,-1,-1,<span class="selection">9</span>,-1,-1,-1,-1]
<br>
[
<br>
-1,-1,-1,
<br>
-1,<span class="selection">9</span>,-1,
<br>
-1,-1,-1
<br>
]
<br>
<br>
edge抽出filter（重みの総和=0）の一例を示す
<br>
・RGB値edge3x3
<br>
rgb[-1,-1,-1,-1,<span class="selection">8</span>,-1,-1,-1,-1]
<br>
[
<br>
-1,-1,-1,
<br>
-1,<span class="selection">8</span>,-1,
<br>
-1,-1,-1
<br>
]
<br>
・R値edge強化3x3
<br>
r[-10,-10,-10,-10,<span class="selection">80</span>,-10,-10,-10,-10]
<br>
[
<br>
-10,-10,-10,
<br>
-10,<span class="selection">80</span>,-10,
<br>
-10,-10,-10
<br>
]
<br>
・R値Laplacian3x3
<br>
r[0,-1,0,-1,<span class="selection">4</span>,-1,0,-1,0]
<br>
[
<br>
0,-1,0,
<br>
-1,<span class="selection">4</span>,-1,
<br>
0,-1,0
<br>
]
<br>
・G値Laplacian強化3x3
<br>
g[0,-10,0,-10,<span class="selection">40</span>,-10,0,-10,0]
<br>
[
<br>
0,-10,0,
<br>
-10,<span class="selection">40</span>,-10,
<br>
0,-10,0
<br>
]
<br>
・G値emboss3x3
<br>
g[-1,0,0,0,<span class="selection">1</span>,0,0,0,0]
<br>
[
<br>
-1,0,0,
<br>
0,<span class="selection">1</span>,0,
<br>
0,0,0
<br>
]
<br>
・B値emboss強化3x3
<br>
b[-10,0,0,0,<span class="selection">10</span>,0,0,0,0]
<br>
[
<br>
-10,0,0,
<br>
0,<span class="selection">10</span>,0,
<br>
0,0,0
<br>
]
<br>
・B値zero化1x1
<br>
b[<span class="selection">0</span>]
<br>
・S値zero化1x1（monotone化）
<br>
s[<span class="selection">0</span>] || s_cone[<span class="selection">0</span>]
<br>
<br>
<span class="clear">Ver.2.44.23</span>以降、irregular入力に対応
<br>
r || rr || rrr || r[] || []r || [0]r || [string]r -> r[0]
<br>
[1]rgb || r[1]gb || rg[1]b -> rgb[1]
<br>
r[1]g[2]b || g[1]r[2]b || b[1]g[2]r -> rgb[1]
<br>
[]r[1]g[2]b || [0]r[1]g[2]b -> rgb[0]
<br>
[0xa]r[1]g[2]b[3] -> rgb[10]
<br>
<br>
<span class="run">Ver.2.46.24</span>以降、HSV-<a href="#span-out-UI-graphing-color-space">color空間</a>に対応
<br>
・円柱model
<br>
rgba[1]hsv || hsv[1]:rgba[1] -> hsvrgba[1]
<br>
・円錐model
<br>
hsv_cone[1]:rgba[1] -> hsvrgba_cone[1]
<br>
・HSV-<a href="#span-out-UI-graphing-color-space">color空間</a>よりRGBA-<a href="#span-out-UI-graphing-color-space">color空間</a>を優先する場合
<br>
rgba[1]:hsv[1]
<br>
<br>
<span class="run">Ver.2.52.25</span>以降、filterを適用する<span class="condition">canvas-area</span>の設定項目を追加
<br>
・<span class="condition">canvas-area</span>は始点(x,y)とarea-size(w,h)を直列化してpx数値で指定する
<br>
area[x||0,y||0,w||<a href="#span-out-UI-graphing-config">canvas-width</a>,h||<a href="#span-out-UI-graphing-config">canvas-height</a>]
<br>
・始点(x,y)=(10,20)・area-size(w,h)=(30,40)　⇒　終点(x,y)=(10+30-1,20+40-1)
<br>
area[10,20,30,40]
<br>
<br>
留意事項を列挙する
<br>
・svg出力は無効
<br>
・putImageData()同期出力のため、<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>無効（source-over）
<br>
・filter sizeに応じて<a href="#span-out-UI-graphing-post">post処理</a>の負荷がexponentialに増大する（中断不可）
<br>
・加重平均filterは重みを正規化するが、edge抽出filterは正規化しない（白黒飛びを許容）
<br>
・ImageDataが欠落する描画canvas境界は加重平均filterとして扱う（意図とは異なる可能性）
<br>
・<a href="#span-out-UI-graphing-config">canvas-background</a>にtransparent選択の場合、背景色は<a href="#span-out-UI-graphing-color">透明黒色</a>とする
<br>
・<span class="clear">Ver.2.44.23</span>以降、filter配列要素に数値以外を指定した場合、該当の重み=0とする
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
average
<br>
ぼかし
    </th>
    <td>
<span id="span-out-UI-graphing-filter-average"></span>
averageぼかしについて記述する
<br>
<br>
<a href="#span-out-UI-graphing-filter">filter</a>を代用してaverageぼかしを定義する
<br>
・単純な<a href="#span-out-UI-graphing-filter">加重平均filter</a>として<a href="#span-out-UI-graphing-blur">指向性のblurring</a>に応用する
<br>
<br>
averageぼかしの仕様を列挙する
<br>
・ぼかし強度は<a href="#span-out-UI-graphing-filter">filter</a>(N)x(N)sizeのNに比例する
<br>
・高速化のため、<a href="#span-out-UI-graphing-filter">filter配列</a>要素の重みを0||1で2値化する
<br>
<br>
2値化の分布形状を固定してN違いの<a href="#span-out-UI-graphing-filter">filter配列</a>を以下の<a href="#span-out-ope">実数演算</a>で生成する
<br>
・average_square
<br>
[N=3,N2=int(N/2),filter=vectorc(N*N),
<br>
calc_w(s2)=&lt;1,
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
・average_circle
<br>
[N=3,N2=int(N/2),filter=vectorc(N*N),
<br>
calc_w(s2)=&lt;switch(s2&gt;N2**2,0:1,1),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
<br>
average_squareの<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・N=1
<br>
[
<br>
<span class="selection">1</span>
<br>
]
<br>
・N=3
<br>
[
<br>
1,1,1,
<br>
1,<span class="selection">1</span>,1,
<br>
1,1,1
<br>
]
<br>
・N=5
<br>
[
<br>
1,1,1,1,1,
<br>
1,1,1,1,1,
<br>
1,1,<span class="selection">1</span>,1,1,
<br>
1,1,1,1,1,
<br>
1,1,1,1,1
<br>
]
<br>
・N=7
<br>
[
<br>
1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,
<br>
1,1,1,<span class="selection">1</span>,1,1,1,
<br>
1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1
<br>
]
<br>
・N=9
<br>
[
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,<span class="selection">1</span>,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=11
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=13
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=15
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=17
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=19
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=21
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=23
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=25
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=27
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=29
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=31
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=33（以降、<a href="#span-out-config">裏設定</a>で<a href="#span-in-options">matSizeMax</a>の上限値を解放）
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=35
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=37
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・N=39
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
<br>
average_circleの<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・N=1
<br>
[
<br>
<span class="selection">1</span>
<br>
]
<br>
・N=3
<br>
[
<br>
0,1,0,
<br>
1,<span class="selection">1</span>,1,
<br>
0,1,0
<br>
]
<br>
・N=5
<br>
[
<br>
0,0,1,0,0,
<br>
0,1,1,1,0,
<br>
1,1,<span class="selection">1</span>,1,1,
<br>
0,1,1,1,0,
<br>
0,0,1,0,0
<br>
]
<br>
・N=7
<br>
[
<br>
0,0,0,1,0,0,0,
<br>
0,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,0,
<br>
1,1,1,<span class="selection">1</span>,1,1,1,
<br>
0,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,0,
<br>
0,0,0,1,0,0,0
<br>
]
<br>
・N=9
<br>
[
<br>
0,0,0,0,1,0,0,0,0,
<br>
0,0,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,<span class="selection">1</span>,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,0,0,
<br>
0,0,0,0,1,0,0,0,0
<br>
]
<br>
・N=11
<br>
[
<br>
0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,1,0,0,0,0,0
<br>
]
<br>
・N=13
<br>
[
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0
<br>
]
<br>
・N=15
<br>
[
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
<br>
]
<br>
・N=17
<br>
[
<br>
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=19
<br>
[
<br>
0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=21
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=23
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=25
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=27
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=29
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=31
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=33（以降、<a href="#span-out-config">裏設定</a>で<a href="#span-in-options">matSizeMax</a>の上限値を解放）
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=35
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=37
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=39
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
非対称
<br>
average
<br>
ぼかし
    </th>
    <td>
<span id="span-out-UI-graphing-filter-average-asym"></span>
非対称averageぼかしについて記述する
<br>
<br>
<a href="#span-out-UI-graphing-filter">filter</a>を代用して非対称averageぼかしを定義する
<br>
・単純な<a href="#span-out-UI-graphing-filter">加重平均filter</a>として<a href="#span-out-UI-graphing-blur">指向性のblurring</a>に応用する
<br>
<br>
非対称averageぼかしの仕様を列挙する
<br>
・ぼかし強度は<a href="#span-out-UI-graphing-filter">filter</a>(N)x(N)sizeのNに比例する
<br>
・高速化のため、<a href="#span-out-UI-graphing-filter">filter配列</a>要素の重みを0||1で2値化する
<br>
<br>
2値化の分布形状を可変してN違いの<a href="#span-out-UI-graphing-filter">filter配列</a>を以下の<a href="#span-out-ope">実数演算</a>で生成する
<br>
・average_square
<br>
[N=13,N2=int(N/2),filter=vectorc(N*N),
<br>
x=0,y=0,k=1,rad=0,
<br>
<a href="#span-eqn-rotationxyz_LHS">rotz_LHS(psi)</a>=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;,
<br>
Rz=rotz_LHS(rad)=&gt;,
<br>
isOutOfArea(x)=&lt;(x[0]**2&gt;N2**2)|((x[1]*k)**2&gt;N2**2),
<br>
calc_w(ir,ic)=&lt;switch(isOutOfArea(=&lt;Rz*{ic-x,ir-y,1})=&gt;,0:1,1),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir,ic)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
・average_circle
<br>
[N=13,N2=int(N/2),filter=vectorc(N*N),
<br>
x=0,y=0,k=1,rad=0,
<br>
<a href="#span-eqn-rotationxyz_LHS">rotz_LHS(psi)</a>=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;,
<br>
Rz=rotz_LHS(rad)=&gt;,
<br>
isOutOfArea(x)=&lt;x[0]**2+(x[1]*k)**2&gt;N2**2,
<br>
calc_w(ir,ic)=&lt;switch(isOutOfArea(=&lt;Rz*{ic-x,ir-y,1})=&gt;,0:1,1),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir,ic)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
<br>
<a href="#span-out-UI-graphing-filter">filter配列</a>生成の各設定値の定義を列挙する
<br>
・(x,y)は<span class="selection">対象pixel</span>に対する回転中心の相対座標のpx数値
<br>
・kは非対称性を作るy方向の比例係数の実数値
<br>
・radは分布を回転する<a href="#span-out-FNmspecial">回転行列</a>の弧度数値
<br>
<br>
average_asym_square13x13の<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・基準(x,y,k,rad)=(0,0,1,0)
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(0,0,0,0)
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,0,0)
<br>
[
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,0.5,0)
<br>
[
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,1,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,1.5,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,2,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,pi/4)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,<span class="selection">1</span>,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,pi/2)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,<span class="selection">1</span>,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,pi/2)
<br>
[
<br>
0,0,0,0,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,<span class="selection">1</span>,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,3pi/4)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,1,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,<span class="selection">1</span>,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,1,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,5,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,7,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
<br>
average_asym_circle13x13の<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・基準(x,y,k,rad)=(0,0,1,0)
<br>
[
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,0,0)
<br>
[
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
1,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,0,0)
<br>
[
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,0.5,0)
<br>
[
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1
<br>
]
<br>
・(x,y,k,rad)=(1,2,1,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,1.5,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,1,1,0,0,
<br>
0,0,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,0,1,1,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,2,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,1,1,1,<span class="selection">1</span>,1,1,1,1,1,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,0)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,<span class="selection">0</span>,1,0,0,0,0,0,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,1,1,1,1,1,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,pi/4)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,<span class="selection">1</span>,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,1,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,1,0,
<br>
0,0,0,0,0,0,0,0,0,1,1,1,0
<br>
]
<br>
・(x,y,k,rad)=(1,2,3,pi/2)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,<span class="selection">1</span>,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0,
<br>
0,0,0,0,0,0,1,1,1,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,pi/2)
<br>
[
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,1,1,<span class="selection">1</span>,1,1,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,1,1,1,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,3pi/4)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,1,1,1,0,0,
<br>
0,0,0,0,0,0,0,1,1,1,1,0,0,
<br>
0,0,0,0,0,0,1,1,1,1,1,0,0,
<br>
0,0,0,0,0,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,1,1,<span class="selection">1</span>,1,1,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,0,0,0,0,0,
<br>
0,0,1,1,1,1,1,0,0,0,0,0,0,
<br>
0,0,1,1,1,1,0,0,0,0,0,0,0,
<br>
0,0,1,1,1,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,3,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,1,1,1,1,1,1,1,1,1,1,1,0,
<br>
0,0,0,0,0,0,1,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,5,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,0,1,1,1,1,1,1,1,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
・(x,y,k,rad)=(0,0,7,pi)
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
1,1,1,1,1,1,<span class="selection">1</span>,1,1,1,1,1,1,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,0,0
<br>
]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Gauss
<br>
ぼかし
    </th>
    <td>
<span id="span-out-UI-graphing-filter-Gaussian"></span>
Gaussぼかしについて記述する
<br>
<br>
<a href="#span-out-UI-graphing-filter">filter</a>を代用してGaussぼかしを再現する
<br>
・高速な<a href="#span-out-UI-graphing-blur">blurring</a>の<a href="#span-out-UI-graphing-filter">加重平均filter</a>として多用されるが、仕様上、高速化の恩恵は受けられない
<br>
<br>
Gaussぼかしの仕様を列挙する
<br>
・Gauss分布の再現精度は<a href="#span-out-UI-graphing-filter">filter</a>(N)x(N)sizeのNに依存する
<br>
・ぼかし強度は<a href="#span-out-UI-graphing-filter">filter</a>の適用回数で変更する（例えば、<a href="#span-out-UI-graphing-post-transformer">post-transformer</a>参照）
<br>
<br>
σ=1pxの分布関数を固定してN違いの<a href="#span-out-UI-graphing-filter">filter配列</a>を以下の<a href="#span-out-ope">実数演算</a>で生成する
<br>
・簡易なGaussぼかしの場合、配列要素の重みを丸める（量子化bit数=N-1を仮定）
<br>
[N=3,N2=int(N/2),filter=vectorc(N*N),Nbit=N-1,wmax=2**Nbit,
<br>
calc_w(s2)=&lt;round(wmax*exp(-0.5*s2)),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
・厳密なGaussぼかしの場合、配列要素の重みを丸めない
<br>
[N=3,N2=int(N/2),filter=vectorc(N*N),
<br>
calc_w(s2)=&lt;exp(-0.5*s2),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;
<br>
<br>
簡易なGaussぼかしの<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・N=1
<br>
[
<br>
<span class="selection">1</span>
<br>
]
<br>
・N=3
<br>
[
<br>
1,2,1,
<br>
2,<span class="selection">4</span>,2,
<br>
1,2,1
<br>
]
<br>
・N=5
<br>
[
<br>
0,1,2,1,0,
<br>
1,6,10,6,1,
<br>
2,10,<span class="selection">16</span>,10,2,
<br>
1,6,10,6,1,
<br>
0,1,2,1,0
<br>
]
<br>
・N=7
<br>
[
<br>
0,0,0,1,0,0,0,
<br>
0,1,5,9,5,1,0,
<br>
0,5,24,39,24,5,0,
<br>
1,9,39,<span class="selection">64</span>,39,9,1,
<br>
0,5,24,39,24,5,0,
<br>
0,1,5,9,5,1,0,
<br>
0,0,0,1,0,0,0
<br>
]
<br>
・N=9
<br>
[
<br>
0,0,0,0,0,0,0,0,0,
<br>
0,0,0,2,3,2,0,0,0,
<br>
0,0,5,21,35,21,5,0,0,
<br>
0,2,21,94,155,94,21,2,0,
<br>
0,3,35,155,<span class="selection">256</span>,155,35,3,0,
<br>
0,2,21,94,155,94,21,2,0,
<br>
0,0,5,21,35,21,5,0,0,
<br>
0,0,0,2,3,2,0,0,0,
<br>
0,0,0,0,0,0,0,0,0
<br>
]
<br>
・N=11
<br>
[
<br>
0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,2,7,11,7,2,0,0,0,
<br>
0,0,2,19,84,139,84,19,2,0,0,
<br>
0,0,7,84,377,621,377,84,7,0,0,
<br>
0,0,11,139,621,<span class="selection">1024</span>,621,139,11,0,0,
<br>
0,0,7,84,377,621,377,84,7,0,0,
<br>
0,0,2,19,84,139,84,19,2,0,0,
<br>
0,0,0,2,7,11,7,2,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0,
<br>
0,0,0,0,0,0,0,0,0,0,0
<br>
]
<br>
<br>
厳密なGaussぼかしの<a href="#span-out-UI-graphing-filter">filter配列</a>を列挙する
<br>
・N=1
<br>
[
<br>
<span class="selection">1</span>
<br>
]
<br>
・N=3
<br>
[
<br>
0.36787944117144233,0.6065306597126334,0.36787944117144233,
<br>
0.6065306597126334,<span class="selection">1</span>,0.6065306597126334,
<br>
0.36787944117144233,0.6065306597126334,0.36787944117144233
<br>
]
<br>
・N=5
<br>
[
<br>
0.01831563888873418,0.0820849986238988,0.1353352832366127,
<br>
0.0820849986238988,0.01831563888873418,
<br>
0.0820849986238988,0.36787944117144233,0.6065306597126334,
<br>
0.36787944117144233,0.0820849986238988,
<br>
0.1353352832366127,0.6065306597126334,<span class="selection">1</span>,
<br>
0.6065306597126334,0.1353352832366127,
<br>
0.0820849986238988,0.36787944117144233,0.6065306597126334,
<br>
0.36787944117144233,0.0820849986238988,
<br>
0.01831563888873418,0.0820849986238988,0.1353352832366127,
<br>
0.0820849986238988,0.01831563888873418
<br>
]
<br>
・N=7
<br>
[
<br>
0.00012340980408667956,0.0015034391929775724,0.006737946999085467,
<br>
0.011108996538242306,0.006737946999085467,0.0015034391929775724,
<br>
0.00012340980408667956,
<br>
0.0015034391929775724,0.01831563888873418,0.0820849986238988,
<br>
0.1353352832366127,0.0820849986238988,0.01831563888873418,
<br>
0.0015034391929775724,
<br>
0.006737946999085467,0.0820849986238988,0.36787944117144233,
<br>
0.6065306597126334,0.36787944117144233,0.0820849986238988,
<br>
0.006737946999085467,
<br>
0.011108996538242306,0.1353352832366127,0.6065306597126334,
<br>
<span class="selection">1</span>,0.6065306597126334,0.1353352832366127,
<br>
0.011108996538242306,
<br>
0.006737946999085467,0.0820849986238988,0.36787944117144233,
<br>
0.6065306597126334,0.36787944117144233,0.0820849986238988,
<br>
0.006737946999085467,
<br>
0.0015034391929775724,0.01831563888873418,0.0820849986238988,
<br>
0.1353352832366127,0.0820849986238988,0.01831563888873418,
<br>
0.0015034391929775724,
<br>
0.00012340980408667956,0.0015034391929775724,0.006737946999085467,
<br>
0.011108996538242306,0.006737946999085467,0.0015034391929775724,
<br>
0.00012340980408667956
<br>
]
<br>
・N=9
<br>
[
<br>
1.1253517471925912e-7,0.000003726653172078671,0.00004539992976248485,
<br>
0.00020346836901064417,0.00033546262790251185,0.00020346836901064417,
<br>
0.00004539992976248485,0.000003726653172078671,1.1253517471925912e-7,
<br>
0.000003726653172078671,0.00012340980408667956,0.0015034391929775724,
<br>
0.006737946999085467,0.011108996538242306,0.006737946999085467,
<br>
0.0015034391929775724,0.00012340980408667956,0.000003726653172078671,
<br>
0.00004539992976248485,0.0015034391929775724,0.01831563888873418,
<br>
0.0820849986238988,0.1353352832366127,0.0820849986238988,
<br>
0.01831563888873418,0.0015034391929775724,0.00004539992976248485,
<br>
0.00020346836901064417,0.006737946999085467,0.0820849986238988,
<br>
0.36787944117144233,0.6065306597126334,0.36787944117144233,
<br>
0.0820849986238988,0.006737946999085467,0.00020346836901064417,
<br>
0.00033546262790251185,0.011108996538242306,0.1353352832366127,
<br>
0.6065306597126334,<span class="selection">1</span>,0.6065306597126334,
<br>
0.1353352832366127,0.011108996538242306,0.00033546262790251185,
<br>
0.00020346836901064417,0.006737946999085467,0.0820849986238988,
<br>
0.36787944117144233,0.6065306597126334,0.36787944117144233,
<br>
0.0820849986238988,0.006737946999085467,0.00020346836901064417,
<br>
0.00004539992976248485,0.0015034391929775724,0.01831563888873418,
<br>
0.0820849986238988,0.1353352832366127,0.0820849986238988,
<br>
0.01831563888873418,0.0015034391929775724,0.00004539992976248485,
<br>
0.000003726653172078671,0.00012340980408667956,0.0015034391929775724,
<br>
0.006737946999085467,0.011108996538242306,0.006737946999085467,
<br>
0.0015034391929775724,0.00012340980408667956,0.000003726653172078671,
<br>
1.1253517471925912e-7,0.000003726653172078671,0.00004539992976248485,
<br>
0.00020346836901064417,0.00033546262790251185,0.00020346836901064417,
<br>
0.00004539992976248485,0.000003726653172078671,1.1253517471925912e-7
<br>
]
<br>
・N=11
<br>
[
<br>
1.3887943864964021e-11,1.2501528663867426e-9,4.139937718785167e-8,
<br>
5.04347662567888e-7,0.0000022603294069810542,0.000003726653172078671,
<br>
0.0000022603294069810542,5.04347662567888e-7,4.139937718785167e-8,
<br>
1.2501528663867426e-9,1.3887943864964021e-11,
<br>
1.2501528663867426e-9,1.1253517471925912e-7,0.000003726653172078671,
<br>
0.00004539992976248485,0.00020346836901064417,0.00033546262790251185,
<br>
0.00020346836901064417,0.00004539992976248485,0.000003726653172078671,
<br>
1.1253517471925912e-7,1.2501528663867426e-9,
<br>
4.139937718785167e-8,0.000003726653172078671,0.00012340980408667956,
<br>
0.0015034391929775724,0.006737946999085467,0.011108996538242306,
<br>
0.006737946999085467,0.0015034391929775724,0.00012340980408667956,
<br>
0.000003726653172078671,4.139937718785167e-8,
<br>
5.04347662567888e-7,0.00004539992976248485,0.0015034391929775724,
<br>
0.01831563888873418,0.0820849986238988,0.1353352832366127,
<br>
0.0820849986238988,0.01831563888873418,0.0015034391929775724,
<br>
0.00004539992976248485,5.04347662567888e-7,
<br>
0.0000022603294069810542,0.00020346836901064417,0.006737946999085467,
<br>
0.0820849986238988,0.36787944117144233,0.6065306597126334,
<br>
0.36787944117144233,0.0820849986238988,0.006737946999085467,
<br>
0.00020346836901064417,0.0000022603294069810542,
<br>
0.000003726653172078671,0.00033546262790251185,0.011108996538242306,
<br>
0.1353352832366127,0.6065306597126334,<span class="selection">1</span>,
<br>
0.6065306597126334,0.1353352832366127,0.011108996538242306,
<br>
0.00033546262790251185,0.000003726653172078671,
<br>
0.0000022603294069810542,0.00020346836901064417,0.006737946999085467,
<br>
0.0820849986238988,0.36787944117144233,0.6065306597126334,
<br>
0.36787944117144233,0.0820849986238988,0.006737946999085467,
<br>
0.00020346836901064417,0.0000022603294069810542,
<br>
5.04347662567888e-7,0.00004539992976248485,0.0015034391929775724,
<br>
0.01831563888873418,0.0820849986238988,0.1353352832366127,
<br>
0.0820849986238988,0.01831563888873418,0.0015034391929775724,
<br>
0.00004539992976248485,5.04347662567888e-7,
<br>
4.139937718785167e-8,0.000003726653172078671,0.00012340980408667956,
<br>
0.0015034391929775724,0.006737946999085467,0.011108996538242306,
<br>
0.006737946999085467,0.0015034391929775724,0.00012340980408667956,
<br>
0.000003726653172078671,4.139937718785167e-8,
<br>
1.2501528663867426e-9,1.1253517471925912e-7,0.000003726653172078671,
<br>
0.00004539992976248485,0.00020346836901064417,0.00033546262790251185,
<br>
0.00020346836901064417,0.00004539992976248485,0.000003726653172078671,
<br>
1.1253517471925912e-7,1.2501528663867426e-9,
<br>
1.3887943864964021e-11,1.2501528663867426e-9,4.139937718785167e-8,
<br>
5.04347662567888e-7,0.0000022603294069810542,0.000003726653172078671,
<br>
0.0000022603294069810542,5.04347662567888e-7,4.139937718785167e-8,
<br>
1.2501528663867426e-9,1.3887943864964021e-11
<br>
]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
tone-curve
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-filter-tone-curve"></span>
tone-curve特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.47.24</span>以降、<a href="#span-out-UI-graphing-filter">filter</a>を代用してgamma補正を含むtone-curve調整機能を追加する
<br>
<br>
tone-curveの仕様を列挙する
<br>
・<a href="#span-out-UI-graphing-filter">filter</a>定義（配列length=1~4）
<br>
hsvrgba[slope,offset||0,gamma||1,threshold||th=0~255||0]
<br>
・べき乗則のgamma値を拡張して連続的なtone-curveに一般化する定義式を次に示す
<br>
t=hsvrgba
<br>
t0=switch(t-th&lt;0,0:1,255)
<br>
t=pow((t-th)/switch(t0-th==0,1:1,t0-th),gamma)*(t0-th)+th
<br>
・<span class="run">Ver.2.59.26</span>以降、<a href="#span-out-prec-ope-logical">論理演算子</a>を追加
<br>
t=pow((t-th)/(t0-th||1),gamma)*(t0-th)+th
<br>
・tone-curve調整後、一次変換
<br>
t=t*slope+offset
<br>
・slope=-1の場合、反転を定義
<br>
offset=offset+255 -> t=-t+offset+255
<br>
<br>
test caseを列挙する
<br>
・R値係数倍(=R*2)
<br>
r[2]
<br>
・R値反転(=-R+255)
<br>
r[-1]
<br>
・R値一次変換(=R*2+50)
<br>
r[2,50]
<br>
・R値反転一次変換(=-R+255+50)
<br>
r[-1,50]
<br>
・sepia-tone化
<br>
r[0.9]:g[0.7]:b[0.4]
<br>
・相対輝度Y値化（輝度の可視化）
<br>
r[0.2126]:g[0.7152]:b[0.0722]
<br>
・NTSC加重平均法の輝度Y'値化
<br>
r[0.29891]:g[0.58661]:b[0.11448]
<br>
・下凸のgamma補正
<br>
[1,,2,0]
<br>
[1,,0.5,255]
<br>
・上凸のgamma補正
<br>
[1,,0.5,0]
<br>
[1,,2,255]
<br>
・S字のtone-curve調整
<br>
[1,,0.5,127]
<br>
[1,,2,127]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
post
<br>
-transformer
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-post-transformer"></span>
post-transformer特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.54.26</span>以降、<a href="#span-out-UI-graphing-filter">filter</a>を代用して<a href="#span-out-UI-graphing-transform">transform</a>同等のpost-transformerを追加する
<br>
<br>
post-transformerの仕様を列挙する
<br>
・<a href="#span-out-UI-graphing-filter">filter</a>定義（配列length=6~7）
<br>
rgba[<span class="selection">a,b,c,d,e,f</span>,isForward||0]
<br>
・配列はcanvas座標変換ctx.setTransform(<span class="selection">a,b,c,d,e,f</span>)の引数をcomma,区切りで入力
<br>
・各引数の詳細は<a href="#span-out-UI-graphing-transform">transform</a>参照
<br>
・isForward=0||1は座標変換後の各RGBA値の代入方法を数値で指定する
<br>
　0の場合、canvas座標を逆変換して変換前の各RGBA値を参照して代入
<br>
　1の場合、canvas座標を順変換して変換前の各RGBA値を成行きで上書き代入
<br>
・座標変換の原点は<a href="#span-out-UI-graphing-filter">canvas-area</a>の始点とする
<br>
<br>
test caseを列挙する
<br>
・canvas全体のRGBA値に<a href="#span-out-UI-graphing-filter-Gaussian">簡易なGaussぼかし</a>を適用後、座標変換を適用
<br>
area[0]rgba[1,2,1,2,4,2,1,2,1]:area[0]rgba[1,0.1,-0.5,0.5,65,40]
<br>
・canvas全体のRGBA値に座標変換を適用後、<a href="#span-out-UI-graphing-filter-Gaussian">簡易なGaussぼかし</a>を適用
<br>
area[0]rgba[1,0.1,-0.5,0.5,65,40]:area[0]rgba[1,2,1,2,4,2,1,2,1]
<br>
・canvas全体のRGBA値に<a href="#span-out-UI-graphing-filter-Gaussian">簡易なGaussぼかし</a>を3回適用後、座標変換を適用
<br>
rgba[1,2,1,2,4,2,1,2,1]:rgba[1,2,1,2,4,2,1,2,1]:rgba[1,2,1,2,4,2,1,2,1]:rgba[1,0.1,-0.5,0.5,65,40]
<br>
・canvas全体のRGBA値に座標変換を適用後、<a href="#span-out-UI-graphing-filter-Gaussian">簡易なGaussぼかし</a>を3回適用
<br>
rgba[1,0.1,-0.5,0.5,65,40]:rgba[1,2,1,2,4,2,1,2,1]:rgba[1,2,1,2,4,2,1,2,1]:rgba[1,2,1,2,4,2,1,2,1]
<br>
・<a href="#span-out-UI-graphing-filter">canvas-area</a>[30,30]のRGBA値に座標変換を適用
<br>
area[30,30]rgba[1,0.1,-0.5,0.5,65,40]
<br>
・canvas全体のRGBA値に拡大の順変換を適用（Braun管のdisplay表示を模擬）
<br>
area[0]rgba[2,0,0,2,0,0,1]
<br>
<br>
留意事項を列挙する
<br>
・変換後のcanvas座標を丸めるため、<a href="#span-out-UI-graphing-transform">transform</a>よりRGBA値の補間精度が悪化する
<br>
・順変換の場合、等倍でも空白発生の可能性がある（例えば、rgba[1,0.1,-0.5,1,0,0,1]）
<br>
・空白部分は<a href="#span-out-UI-graphing-color">透明黒色</a>とする
<br>
・別途、<a href="#span-out-UI-graphing-blur">blurring</a>のみを<a href="#span-out-UI-graphing-transform">transform</a>の対象とする場合、plot点に<a href="#span-out-FNmspecial">右手系</a>の座標変換を適用する
<br>
　<a href="#span-out-FNmspecial">左手系</a>のcanvas座標変換と等価変換は困難のため、例えば、<a href="#span-out-UI-graphing-transform">transform3x3</a>をplot点に演算
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
post
<br>
-compressor
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-post-compressor"></span>
post-compressor特定項目仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.65.27</span>以降、<a href="#span-out-UI-graphing-filter">filter</a>を代用してpost-compressor（<a href="#span-out-UI-graphing-post-processor-encode">noise</a>処理等、情報量の圧縮機能）を追加
<br>
・<span class="run">Ver.2.72.29</span>以降、<a href="#span-out-transform-dwt">離散Wavelet変換</a>を追加
<br>
<br>
post-compressorの仕様を列挙する
<br>
・hsvlrgba||HSVLRGBAのalphabetを除外してpost-compressor処理名を定義する
<br>
・post-compressor処理は単独処理で処理名の併記不可
<br>
<br>
post-compressor処理を優先順に列挙する
<br>
・<a href="#span-out-transform-fft">高速Fourier変換</a>は不採用（<a href="#span-out-UI-graphing-filter">filter</a>代用の仕様上、overhead大）
<br>
<del>fft_rgba[]</del>
<br>
・<a href="#span-out-transform-dft">離散Fourier変換</a>
<br>
dft_rgba[cutoffU=0~1||0,cutoffV=0~1||0]
<br>
・<a href="#span-out-transform-dwt">離散Wavelet変換</a>　<span class="run">Ver.2.72.29</span>以降、追加
<br>
dwt_rgba[cutoffU=0~1||0,cutoffV=0~1||0]
<br>
<br>
留意事項を列挙する
<br>
・cutoffU/Vは高周波数側の2次元AND領域の情報を<a href="#span-out-UI-graphing-post-processor-encode">noise</a>として強制的に遮断する
<br>
　<a href="#span-out-transform-dft">離散Fourier変換</a>の場合、spectrum強度=0
<br>
　<a href="#span-out-transform-dwt">離散Wavelet変換</a>の場合、<a href="#span-out-transform-dwt">wavelet情報</a>=0
<br>
・<a href="#span-out-transform-dwt">離散Wavelet変換</a>の場合、<a href="#span-out-UI-graphing-filter">area-size</a>の制約が存在する（切捨て側に自動re-size）
<br>
　量子化bit数=pの場合、w=2^p
<br>
　量子化bit数=qの場合、h=2^q
<br>
・未最適化のため、下流側で<a href="#span-out-UI-graphing-filter">area-size</a>(w,h&lt;=256)を制限する
<br>
　memory size&lt;100MB
<br>
・canvas全体に適用する場合、<a href="#span-out-UI-graphing-filter">canvas-area</a>を変えて列挙する
<br>
dft_rgba[0.05,0.05]:area[256,0]dft_rgba[0.05,0.05]
<br>
dwt_rgba[0.05,0.05]:area[256,0]dwt_rgba[0.05,0.05]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
post
<br>
-processor
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-post-processor"></span>
post-processor特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.48.24</span>以降、<a href="#span-out-UI-graphing-filter">filter</a>を代用してpost-processorを追加する
<br>
・<span class="clear">Ver.2.48.25</span>以降、描画canvas境界で正常に機能しないmosaic化の不具合を修正
<br>
・<span class="run">Ver.2.49.25</span>以降、2値化||monotone化（輝度）のsw=-1<span class="selection">任意のRGB重み平均値</span>に対応
<br>
・<span class="run">Ver.2.61.27</span>以降、<span class="condition">塗りつぶし</span>機能を追加（<span class="condition">Nwrap</span>を周回数とする独自の回り込み方式）
<br>
・<span class="run">Ver.2.62.27</span>以降、<a href="#span-out-UI-graphing-post-processor-encode">不可逆な<span class="jF">encode</span></a>機能を追加（<a href="#span-out-FN-rand">乱数seed値</a>不定のFisher-Yates shuffle）
<br>
<br>
post-processorの仕様を列挙する
<br>
・hsvlrgba||HSVLRGBAのalphabetを除外してpost-processor処理名を定義する
<br>
・post-processor処理は単独処理で処理名の併記不可
<br>
<br>
post-processor処理を優先順に列挙する
<br>
・左右反転
<br>
fx_rgba[offsetX||0]
<br>
・上下反転
<br>
fy_rgba[offsetY||0]
<br>
・mosaic化（不可逆な平均値化）
<br>
dot_rgba[dx=1~||1,dy=1~||dx]
<br>
・<a href="#span-out-UI-graphing-post-processor-encode">不可逆な<span class="jF">encode</span></a>
<br>
encode_rgba[dx=1~||1,dy=1~||dx]
<br>
・<span class="condition">塗りつぶし</span>（fill-inをfiinと省略する）
<br>
fiin[targetX||0,targetY||0,<a href="#span-out-UI-graphing-color">color</a>,<span class="condition">Nwrap</span>=1~256||1]
<br>
fiin[targetX||0,targetY||0,pickedX||0,pickedY||0,<span class="condition">Nwrap</span>=1~256||1]
<br>
・2値化（各RGBA値）
<br>
to2_rgba[threshold=0~255||0]
<br>
・2値化（輝度）
<br>
to2[threshold=0~255||0,sw=-1~6||0<span class="selection">,wr,wg,wb</span>]
<br>
・monotone化（輝度）
<br>
mono[sw=-1~6||0<span class="selection">,wr,wg,wb</span>]
<br>
<br>
2値化||monotone化の輝度選択switch
<br>
sw=0: NTSC加重平均法の輝度Y'=0.29891*r+0.58661*g+0.11448*b
<br>
sw=1: 相対輝度Y=0.2126*r+0.7152*g+0.0722*b
<br>
sw=2: HSL-<a href="#span-out-UI-graphing-color-space">color空間</a>の輝度L=(min+max)/2
<br>
sw=3: RGB平均値average=(r+g+b)/3
<br>
sw=4: RGB最小値min
<br>
sw=5: RGB最大値max||HSV-<a href="#span-out-UI-graphing-color-space">color空間</a>の明度V
<br>
sw=6: RGB中央値median
<br>
<span class="run">Ver.2.49.25</span>以降
<br>
sw=-1: 任意のRGB重み平均値average=(wr*r+wg*g+wb*b)/(wr+wg+wb||1)
<br>
<br>
test caseを列挙する
<br>
・R値右移動100px
<br>
fx_r:fx_r[100]
<br>
・G値上移動100px
<br>
fy_g:fy_g[-100]
<br>
・RGBA値上下左右反転
<br>
fy_rgba:fx_rgba
<br>
・<a href="#span-out-UI-graphing-post-processor-encode">不可逆な<span class="jF">encode</span></a>
<br>
encode_rgba[6,3]
<br>
encode_r[6,3]:encode_g[6,3]:encode_b[6,3]:encode_a[6,3]
<br>
encode_rgba[256,256]
<br>
encode_r[256,256]:encode_g[256,256]:encode_b[256,256]:encode_a[256,256]
<br>
・<a href="#span-out-UI-graphing-color">color</a>指定で絶対始点(0px,0px)の<span class="condition">塗りつぶし</span>
<br>
fiin[0,0,yellow,8]
<br>
fiin[0,0,green,8]
<br>
fiin[0,0,#0123,8] || fiin[0,0,#00112233,8]
<br>
・area[30,30]基準の<a href="#span-out-UI-graphing-color">color</a>-picked相対位置(10px,10px)指定で相対始点(0px,0px)の<span class="condition">塗りつぶし</span>
<br>
area[30,30]fiin[0,0,10,10,8]
<br>
・monotone化（Y'値）
<br>
mono[-1,0.29891,0.58661,0.11448]
<br>
・monotone化（Y値）
<br>
mono[-1,0.2126,0.7152,0.0722]
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
encode仕様
    </th>
    <td>
<span id="span-out-UI-graphing-post-processor-encode"></span>
post-processor特定項目のencode仕様について記述する
<br>
<br>
<span class="run">Ver.2.62.27</span>以降、<a href="#span-out-UI-graphing-post-processor">post-processor</a>に不可逆なencode機能を追加する
<br>
・noise付与に代用（<span class="run">Ver.2.72.29</span>追記）
<br>
<br>
encodeの仕様/補足を列挙する
<br>
・transposition方式
<br>
　通常、直列化した任意dataを可逆的な規則性に従って並び替える
<br>
・理想的なrandom-sortのFisher-Yates shuffle
<br>
　<a href="../99_gacha/index.html">確率抽選</a>の反復sortのため、<a href="#span-out-FN-rand">一様乱数</a>の前提で完全random性を数学的に保証する
<br>
・<a href="#span-out-FN-rand">乱数seed値</a>不定の仕様上、不可逆
<br>
　decodeする場合、encodeの<a href="#span-out-FN-rand">乱数seed値</a>を連番等で指定する（sort規則を予め指定する）
<br>
<br>
文字列を置換するsubstitution方式のcipher||encodeの一例を列挙する（参考）
<br>
・Enigma Cipher
<br>
・特定文字列の<a href="../70_decimal/index.html">n進数⇒m進数変換</a>
<br>
・特定文字列の<a href="../71_regexp/index.html">正規表現text置換</a>
<br>
・<a href="../72_unicode/index.html">Unicode変換Checker※IE一部非対応</a>
<br>
・<a href="../73_encodeURI/index.html">encodeURI変換Checker</a>
<br>
・<a href="../74_base64/index.html">base64変換Checker</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
tile
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-tile"></span>
tile特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.68.27</span>以降、指定領域の<a href="#span-out-UI-graphing-color">千鳥格子</a>tile機能を追加する
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にtileを入力
<br>
tile||TILE{args}
<br>
・任意位置に挿入可
<br>
・tileは<a href="#span-out-UI-graphing-filter">filtering</a>直後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は無効）
<br>
・argsはtile領域を指定する条件をcomma,区切りで入力
<br>
tile{dx||1,dy||1,x0||0,y0||0,x1||0,y1||0}
<br>
・(dx,dy=1~256)は格子1/格子2のtile-size(w,h)をpx数値で指定する
<br>
・(x0,y0=-32768~32767)は格子1のcanvas座標の始点(x,y)をpx数値で指定する
<br>
　描画canvas境界外の座標を指定した場合、境界外の領域は<a href="#span-out-UI-graphing-color">透明黒色</a>
<br>
・(x1,y1=-32768~32767)は格子2のcanvas座標の始点(x,y)をpx数値で指定する
<br>
　描画canvas境界外の座標を指定した場合、境界外の領域は<a href="#span-out-UI-graphing-color">透明黒色</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
cut
<br>
特定項目仕様
    </th>
    <td>
<span id="span-out-UI-graphing-cut"></span>
cut特定項目仕様について記述する
<br>
<br>
<span class="run">Ver.2.63.27</span>以降、指定領域のcut機能を追加する
<br>
<br>
<a href="#span-out-UI-graphing-z">z入力欄</a>にcutを入力
<br>
cut||CUT{args}
<br>
・任意位置に挿入可
<br>
・cutは<a href="#span-out-UI-graphing-filter">filtering</a>直後の<a href="#span-out-UI-graphing-post2">post最終処理</a>（svg出力は<a href="#span-out-UI-graphing-post1">layer合成</a>）
<br>
・argsはcut領域を指定する条件をcomma,区切りで入力
<br>
cut{Nlegend||last,withTransform||false}
<br>
・Nlegend=1~lastはcut領域を指定するplot-lineのlegend番号
<br>
　範囲外の数値||数値以外を指定した場合、最終legendを選択
<br>
・withTransform=false||trueは<a href="#span-out-UI-graphing-transform">transform</a>の反映を選択する
<br>
　svg出力の場合、<a href="#span-out-UI-graphing-transform">withBackground</a>=1のみ有効
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
layer
<br>
描画順
    </th>
    <td>
<span id="span-out-UI-graphing-layer"></span>
layer描画順と付随する留意事項について記述する
<br>
<br>
描画canvasのlayerを描画順に列挙する
<br>
・<span class="run">Ver.2.66.27</span>以降
<br>
　最背面固定layer（<a href="#span-out-UI-graphing-color">透明黒色</a>の初期状態を表す<a href="#span-out-UI-graphing-color">千鳥格子</a>の描画用）
<br>
・<a href="#span-out-UI-graphing-layer-background">background-layer</a>
<br>
・<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>
<br>
・<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>
<br>
・<a href="#span-out-UI-graphing-post1">layer合成</a>用layer
<br>
・最前面固定layer（<a href="#span-out-UI-graphing">mouse||touchによる範囲選択</a>領域の描画用）
<br>
<br>
留意事項を列挙する
<br>
・最背面/最前面固定layerはpng||svg出力対象外
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
背景
<br>
優先順
    </th>
    <td>
<span id="span-out-UI-graphing-layer-background"></span>
背景優先順について記述する
<br>
<br>
background-layerに<a href="#span-out-UI-graphing-config">背景画像file</a>||<a href="#span-out-UI-graphing-color">color</a>指定値を適用する項目を優先順に列挙する
<br>
・<a href="#span-out-UI-graphing-config">bg-image-file@plot-config</a>（svg出力は無効・<span class="clear">Internet Explorer非対応</span>）
<br>
・<a href="#span-out-UI-graphing-bgcolor">bgcolor</a>特定項目指定値
<br>
・<a href="#span-out-UI-graphing-config">bg-color@plot-config</a>入力値
<br>
・<a href="#span-out-UI-graphing-config">canvas-background@plot-config</a>選択値
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
grid-layer
<br>
描画順
    </th>
    <td>
<span id="span-out-UI-graphing-layer-grid"></span>
grid-layer描画順について記述する
<br>
<br>
grid-layerに描画する項目を描画順に列挙する
<br>
・<a href="#span-out-UI-graphing-title">graph-title</a>
<br>
・<a href="#span-out-UI-graphing-labels">axis-labels</a>
<br>
・<a href="#span-out-UI-graphing-origin">origin-label/origin-line</a>
<br>
・grid-lines/axis-values
<br>
<br>
grid-layerに<a href="#span-out-UI-graphing-color">color</a>指定値を適用する項目を優先順に列挙する
<br>
・<a href="#span-out-UI-graphing-gdcolor">gdcolor</a>特定項目指定値
<br>
・<a href="#span-out-UI-graphing-config">grid-line-color@plot-config</a>入力値
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot-layer
<br>
描画順
    </th>
    <td>
<span id="span-out-UI-graphing-layer-plot"></span>
plot-layer描画順について記述する
<br>
<br>
plot-layerに描画する項目を描画順に列挙する
<br>
・<a href="#span-out-UI-graphing-gradation">gradation</a>
<br>
・plot-lines
<br>
・plot-markers
<br>
・<a href="#span-out-UI-graphing-legend">legends</a>
<br>
・<a href="#span-out-UI-graphing-string-path">string-path</a>
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、<a href="#span-out-UI-graphing-title">graph-title</a>は<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>に描画
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
post
<br>
処理順
    </th>
    <td>
<span id="span-out-UI-graphing-post"></span>
post処理順について記述する
<br>
<br>
post処理を処理順に列挙する
<br>
・<a href="#span-out-UI-graphing-post1">layer合成</a>
<br>
・<a href="#span-out-UI-graphing-post2">post最終処理</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
layer
<br>
合成順
    </th>
    <td>
<span id="span-out-UI-graphing-post1"></span>
layer合成順と付随する留意事項について記述する
<br>
<br>
svg出力の場合、同期処理をlayer合成順に列挙する
<br>
・layerをclear
<br>
・同layerに<a href="#span-out-UI-graphing-transform">transform</a>を適用（withBackground=1の場合）
<br>
・同layerにbackground-layerを合成（source-over・<a href="#span-out-UI-graphing-config">背景image-file</a>無効）
<br>
・同layerに<a href="#span-out-UI-graphing-transform">transform</a>を適用（withBackground=0の場合）
<br>
・同layerに<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>を合成（source-over）
<br>
・同layerに<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>を合成（source-over）
<br>
・同layerに<a href="#span-out-UI-graphing-cut">cut</a>を適用（<a href="#span-out-UI-graphing-transform">transform</a>を反映する場合、withBackground=1のみ有効）
<br>
<br>
png出力||描画canvas出力の場合、drawImage()非同期処理をlayer合成順に列挙する
<br>
・layerをclear
<br>
・完了後、同layerに<a href="#span-out-UI-graphing-transform">transform</a>を適用（withBackground=1の場合）
<br>
・完了後、同layerにbackground-layerを合成（source-over）
<br>
・完了後、同layerに<a href="#span-out-UI-graphing-transform">transform</a>を適用（withBackground=0の場合）
<br>
・完了後、同layerに<a href="#span-out-UI-graphing-layer-grid">grid-layer</a>を合成（<a href="#span-out-UI-graphing-config">canvas-globalCompositeOperation</a>を適用）
<br>
・完了後、同layerに<a href="#span-out-UI-graphing-layer-plot">plot-layer</a>を合成（<a href="#span-out-UI-graphing-config">canvas-globalCompositeOperation</a>を適用）
<br>
・完了後、同layerの<a href="#span-out-UI-graphing-post2">post最終処理</a>に移行（source-over）
<br>
<br>
留意事項を列挙する
<br>
・svg出力の場合、<a href="#span-out-UI-graphing-config">canvas-globalCompositeOperation</a>無効（source-over）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
post
<br>
最終処理順
    </th>
    <td>
<span id="span-out-UI-graphing-post2"></span>
post最終処理順と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-UI-graphing-post1">layer合成</a>後、putImageData()同期出力のpost最終処理を処理順に列挙する
<br>
・<a href="#span-out-UI-graphing-blur">blur</a>
<br>
・<a href="#span-out-UI-graphing-filter">filter</a>
<br>
・<a href="#span-out-UI-graphing-tile">tile</a>
<br>
・<a href="#span-out-UI-graphing-cut">cut</a>
<br>
<br>
<a href="#span-out-UI-graphing-filter">filter</a>を代用する項目を列挙する
<br>
・<a href="#span-out-UI-graphing-filter-average">averageぼかし</a>
<br>
・<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>
<br>
・<a href="#span-out-UI-graphing-filter-Gaussian">Gaussぼかし</a>
<br>
・<a href="#span-out-UI-graphing-filter-tone-curve">tone-curve</a>
<br>
・<a href="#span-out-UI-graphing-post-transformer">post-transformer</a>
<br>
・<a href="#span-out-UI-graphing-post-compressor">post-compressor</a>
<br>
・<a href="#span-out-UI-graphing-post-processor">post-processor</a>
<br>
<br>
留意事項を列挙する
<br>
・putImageData()同期出力の場合、<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>無効（source-over）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot-config
    </th>
    <td>
<span id="span-out-UI-graphing-config"></span>
plot-configについて記述する
<br>
<br>
plot-configの設定項目を列挙する
<br>
・<span class="run">Ver.2.43.20</span>以降、<a href="#span-out-option3">Multi-thread実行</a>時の同時並列数Nthreadを選択可
<br>
　通常、memory sizeが問題にならない場合、最適なNthread=CPU-core数*(1~2)
<br>
・描画canvasのcanvas-size(canvas-width,canvas-height)を選択可
<br>
・bg-image-fileは任意size背景画像fileをread可（<span class="clear">Internet Explorer非対応</span>）
<br>
　read-cancel||image-file以外を選択||canvas-size変更で背景reset
<br>
　svg出力は背景image-file無効
<br>
・背景色はbg-colorの入力値優先で省略時、canvas-backgroundの選択値
<br>
　背景画像file未指定時のみ有効
<br>
・bg-colorを入力可
<br>
・grid-line-colorを入力可
<br>
・grid-line-widthを選択可
<br>
・marker-sizeを選択可
<br>
・marker-line-widthを選択可
<br>
・plot-line-widthを選択可
<br>
・font-sizeを選択可
<br>
　axis-values/<a href="#span-out-UI-graphing-legend">legend-string</a>のfont-sizeは選択値
<br>
　<a href="#span-out-UI-graphing-title">graph-title</a>/<a href="#span-out-UI-graphing-labels">axis-labels</a>/<a href="#span-out-UI-graphing-origin">origin</a>のfont-sizeは選択値+2px
<br>
・各軸のgrid分割数grid-x-Ni/grid-y-Njを選択可
<br>
・余白の調整係数kx-adjを選択可
<br>
・legendのx位置を調整するlegend-kxを選択可
<br>
・legendのy位置を調整するlegend-kyを選択可
<br>
・各layerの合成方法canvas-globalCompositeOperationLayerを選択可
<br>
・各layerの背景への合成方法<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>を選択可
<br>
<del>・title入力欄にgraph-titleを入力可</del><span class="run">Ver.2.34.18</span>以降、<a href="#span-out-UI-graphing-z">z入力欄</a>に統合
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
strict-mode
<br>
equation-list
    </th>
    <td>
<span id="span-out-UI-graphing-list"></span>
strict-mode equation-listについて記述する
<br>
<br>
各buttonはtext入力欄の選択位置に<a href="#span-out-config-strict">strict-mode</a>で記述した<a href="#span-out-eqns">式変数</a>を挿入する
<br>
<br>
詳細は<a href="#span-eqn">strict-mode式変数list</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
log-stamp
<br>
仕様
    </th>
    <td>
<span id="span-out-log-stamp"></span>
log-stamp仕様について記述する
<br>
<br>
svg||csv||history-txt出力時に記録するlog-stampの情報を列挙する
<br>
・Repository VERSION
<br>
・time-stamp
<br>
　new Date()
<br>
・<span class="run">Ver.2.38.18</span>以降、browser識別情報
<br>
　window.navigator.userAgent
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
log
<br>
表示仕様
    </th>
    <td>
<span id="span-out-log"></span>
log表示上の仕様と付随する留意事項について記述する
<br>
<br>
代入を伴わない場合
<br>
・演算後の値のみ表示する
<br>
・直前の実行文の演算結果を保持する<a href="#span-out-ans">予約変数</a>ansへの代入を明示しない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
(3*2,1) -> (6,1)
<br>
ans -> (6,1)
<br>
<br>
<a href="#span-out-substitution">変数への代入</a>の場合
<br>
・変数名と代入値を明示する
<br>
x=3*2 -> x=6
<br>
x=(3*2,3) -> x=(6,3)
<br>
<br>
<a href="#span-out-matching">行列要素pattern matching</a>による変数への代入の場合
<br>
・変数名のみ明示する
<br>
($a,$b)=(1,2) -> stored_var(a) stored_var(b) 
<br>
<br>
<a href="#span-out-substitution-equation">式変数への式代入</a>の場合
<br>
・式変数名のみ明示する
<br>
eqn_x=&lt;(a*x+b=0) -> stored_eqn(eqn_x)
<br>
eqn_t=&lt;sin(omega(t)) -> stored_eqn(eqn_t)
<br>
<br>
代入の場合、<a href="#span-out-ans">予約変数</a>ansは更新されない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
x=2; ($a,$b)=(1,2); eqn_x=&lt;(a*x+b=0) -> stored_eqn(eqn_x)
<br>
ans -> 6
<br>
<br>
表示仕様ではないが、以下の演算都合上の仕様について記述する
<br>
・代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は0が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をcomma,||colon:で区切った場合、0を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
(1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、<a href="#span-out-mat">行列</a>を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
外部option
    </th>
    <td>
<span id="span-out-options"></span>
外部optionの設定項目を列挙する
<br>
・<a href="#span-out-option1">2項演算子のassociativity</a>
<br>
・<a href="#span-out-option2">記号省略乗算</a>
<br>
・<a href="#span-out-option4">comma演算子</a>
<br>
・<a href="#span-out-option3">Multi-thread実行</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
2項演算子の
<br>
associativity
    </th>
    <td>
<span id="span-out-option1"></span>
外部optionの2項演算子のassociativityと付随する留意事項について記述する
<br>
<br>
<a href="#span-out-associativity">2項演算子のassociativity</a>を選択可
<br>
・左から順に結合する場合、左結合（以降、Left-AssociativityをLAと省略する）
<br>
・右から順に結合する場合、右結合（以降、Right-AssociativityをRAと省略する）
<br>
<br>
LA既定
<br>
+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
(1,2)-(3,4)-(5,6) || (((1,2)-(3,4))-(5,6)) -> (-7,-8)
<br>
-(1,1)-(2,2) || (((0,0)-(1,1))-(2,2)) -> (-3,-3)
<br>
(1,2){3,4}(5,6) || (((1,2){3,4})(5,6)) || 11(5,6) -> (55,66)
<br>
<br>
RA選択
<br>
+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
(1,2)-(3,4)-(5,6) || ((1,2)-((3,4)-(5,6))) -> (3,4)
<br>
-(1,1)-(2,2) || ((0,0)-((1,1)-(2,2))) -> (1,1)
<br>
(1,2){3,4}(5,6) || ((1,2)({3,4}(5,6))) || (1,2)(15,18:20,24) -> (55,66)
<br>
<br>
留意事項を列挙する
<br>
・<a href="#span-out-type-ope">前置単項演算子</a>の符号は同種の<a href="#span-out-type-ope">中置2項演算子</a>と区別しない
<br>
・符号の左側には0||zeros行列が存在すると仮定して結合する
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
記号省略乗算
    </th>
    <td>
<span id="span-out-option2"></span>
外部optionの記号省略乗算と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>と除算の<a href="#span-out-prec-ope">演算子のprecedence</a>を切替え可
<br>
<br>
除算より記号省略乗算優先既定
<br>
1/2(2) || 1/(2(2)) -> 0.25
<br>
<br>
記号省略乗算より除算優先選択
<br>
1/2(2) || (1/2)(2) -> 1
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>を許容しない場合、<a href="#span-out-config">裏設定</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
comma
<br>
演算子
    </th>
    <td>
<span id="span-out-option4"></span>
外部optionのcomma演算子と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.74.29</span>以降、<a href="#span-out-ope-extended">拡張行列演算</a>におけるcomma演算子の使用を選択可
<br>
<br>
comma演算子は行vectorの<a href="#span-out-FNm-last">最終要素</a>を取り出す
<br>
<br>
comma演算子未使用既定
<br>
(1,2:3,4)i -> (i,2i:3i,4i)
<br>
(1,2:3,4)(i) || (1,2:3,4)*i -> [MyErr]Invalid matrix operation
<br>
<br>
comma演算子使用選択
<br>
(1,2:3,4)i || ((1,2)i:(3,4)i) -> (2i:4i)
<br>
(1,2:3,4)(i) || (1,2:3,4)*i -> [MyErr]Invalid matrix operation
<br>
<br>
留意事項を列挙する
<br>
・<a href="#span-out-ope">無次元</a>の演算の場合、comma演算子は常に有効
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Multi-thread
<br>
実行
    </th>
    <td>
<span id="span-out-option3"></span>
外部optionのMulti-thread実行と付随する留意事項について記述する
<br>
<br>
Multi-thread実行を選択可
<br>
・Single-thread実行の場合、演算を中断不可
<br>
・Multi-thread実行の場合、演算を中断可
<br>
<br>
<a href="#span-out-UI-graphing">Graphing Calculator</a>の場合、Single-thread実行の演算||処理を列挙する
<br>
・<a href="#span-out-UI-graphing">t0/t1</a>の演算
<br>
・<a href="#span-out-UI-graphing-post">post処理</a>を含むcanvas描画処理
<br>
<br>
留意事項を列挙する
<br>
・Single-thread実行の場合、browser既定のtimeoutまで演算||処理を中断不可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算子
<br>
の大分類
    </th>
    <td>
<span id="span-out-type-ope"></span>
演算子の大分類と付随する留意事項について記述する
<br>
<br>
主要な演算子の大分類/記法を列挙する
<br>
・後置単項演算子
<br>
　left-operand operator
<br>
・前置単項演算子
<br>
　operator right-operand
<br>
・中置2項演算子
<br>
　left-operand operator right-operand
<br>
・中置3項演算子
<br>
　left-operand-boolean operator1 right-operand1 operator2 right-operand2
<br>
<br>
留意事項を列挙する
<br>
・未実装の3項演算子は<a href="#span-out-FNh-switch">switch高階関数</a>で代替する
<br>
<br>
小分類は<a href="#span-out-prec-ope">演算子のprecedence</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
2項演算子の
<br>
associativity
    </th>
    <td>
<span id="span-out-associativity"></span>
2項演算子のassociativityと付随する留意事項について記述するについて記述する
<br>
<br>
Left-Associativity（左結合）
<br>
+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
(1,2)-(3,4)-(5,6) || (((1,2)-(3,4))-(5,6)) -> (-7,-8)
<br>
-(1,1)-(2,2) || (((0,0)-(1,1))-(2,2)) -> (-3,-3)
<br>
(1,2){3,4}(5,6) || (((1,2){3,4})(5,6)) || 11(5,6) -> (55,66)
<br>
3^2^3 || ((3^2)^3) -> 729
<br>
3**2**3 || ((3**2)**3) -> 729
<br>
<br>
Right-Associativity（右結合）
<br>
+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
(1,2)-(3,4)-(5,6) || ((1,2)-((3,4)-(5,6))) -> (3,4)
<br>
-(1,1)-(2,2) || ((0,0)-((1,1)-(2,2))) -> (1,1)
<br>
(1,2){3,4}(5,6) || ((1,2)({3,4}(5,6))) || (1,2)(15,18:20,24) -> (55,66)
<br>
3^2^3 || (3^(2^3)) -> 6561
<br>
3**2**3 || (3**(2**3)) -> 6561
<br>
<br>
留意事項を列挙する
<br>
・<a href="#span-out-type-ope">中置2項演算子</a>を短絡評価する場合、<a href="#span-out-prec-ope-logical">論理演算子</a>参照
<br>
<br>
<a href="#span-out-type-ope">中置2項演算子</a>のassociativityを選択する場合、<a href="#span-out-option1">外部option</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算の
<br>
precedence
    </th>
    <td>
<span id="span-out-prec"></span>
演算のprecedenceと付随する留意事項について記述する
<br>
<br>
演算のprecedenceに従って実行文を解釈し、順番に演算を実行する
<br>
<br>
主要なprecedenceを優先順に列挙する
<br>
・<a href="#span-out-SR">区切り文字</a>
<br>
・<a href="#span-out-substitution-equation">式変数への式代入</a>
<br>
・<a href="#span-out-FNc">最上位関数</a>
<br>
・<a href="#span-out-BT">括弧</a>
<br>
・<a href="#span-out-eqns-call">式読出し</a>
<br>
・<a href="#span-out-FN">関数</a>
<br>
・<a href="#span-out-prec-ope">演算子</a>
<br>
・<a href="#span-out-substitution">変数への代入</a>
<br>
<br>
これに従う演算結果の一例を示す
<br>
max(x=1,(x):2,3)[0]2 || (max((0,1:2,3)[0]))2 || (max(0,1))2 || (1)2 -> 2
<br>
<br>
留意事項を列挙する
<br>
・演算のprecedenceは言語仕様によって異なる
<br>
<br>
詳細は<a href="#span-in-prec">内部仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算子の
<br>
precedence
    </th>
    <td>
<span id="span-out-prec-ope"></span>
演算子のprecedenceと付随する留意事項について記述する
<br>
<br>
演算子のprecedenceを優先順に列挙する
<br>
・<a href="#span-out-prec-ope-arithmetic">算術演算子</a>
<br>
　・<a href="#span-out-type-ope">後置単項演算子</a>
<br>
　　・<a href="#span-out-com">虚数単位</a> i
<br>
　　・<a href="#span-out-FN-fact">階乗</a>記号 ! || !!...
<br>
　・<a href="#span-out-type-ope">中置2項演算子</a>
<br>
　　・べき乗演算子 ** || ^
<br>
　　・剰余演算子 %
<br>
　　・四則演算子
<br>
　　　・<a href="#span-out-BRmo">記号省略乗算</a>
<br>
　　　・除算||乗算演算子 / || *
<br>
　　　・減算||加算演算子 - || +
<br>
　・<a href="#span-out-type-ope">前置単項演算子</a>
<br>
　　・減算-||加算+の符号は同種の<a href="#span-out-type-ope">中置2項演算子</a>と区別しない
<br>
・<a href="#span-out-prec-ope-bit">bit演算子</a>
<br>
　・<a href="#span-out-type-ope">前置単項演算子</a>
<br>
　　・bit not演算子 ~　<span class="run">Ver.2.71.28</span>以降、追加
<br>
　・<a href="#span-out-type-ope">中置2項演算子</a>
<br>
　　・bit shift演算子 &lt;&lt; || &gt;&gt; || &gt;&gt;&gt;
<br>
　　・bit and演算子 &amp;
<br>
　　・bit xor演算子 @
<br>
　　・bit or演算子 |
<br>
・<a href="#span-out-prec-ope-comparison">比較演算子</a>
<br>
　・<a href="#span-out-type-ope">中置2項演算子</a>
<br>
　　・大小比較演算子 &lt; || &lt;= || &gt;= || &gt;
<br>
・<a href="#span-out-prec-ope-relational">関係演算子</a>
<br>
　・<a href="#span-out-type-ope">中置2項演算子</a>
<br>
　　・一致||不一致関係演算子 == || &lt;&gt;
<br>
・<a href="#span-out-prec-ope-logical">論理演算子</a>　<span class="run">Ver.2.59.26</span>以降、追加
<br>
　・<a href="#span-out-type-ope">中置2項演算子</a>
<br>
　　・論理AND演算子 &amp;&amp;
<br>
　　・論理OR演算子 ||
<br>
<br>
留意事項を列挙する
<br>
・演算子のprecedenceは言語仕様によって異なる
<br>
<br>
演算子のprecedenceを変更する場合、<a href="#span-out-config">裏設定</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
算術演算子
    </th>
    <td>
<span id="span-out-prec-ope-arithmetic"></span>
算術演算子と付随する留意事項について記述する
<br>
<br>
減算と加算は区別せず、<a href="#span-out-associativity">2項演算子のassociativity</a>に従って演算する
<br>
<a href="#span-out-option1">LA既定</a>時　+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
<a href="#span-out-option1">RA選択</a>時　+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
<br>
除算と乗算は区別せず、<a href="#span-out-associativity">2項演算子のassociativity</a>に従って演算する
<br>
<a href="#span-out-option1">LA既定</a>時　1*2/3*4/5 || ((((1*2)/3)*4)/5) -> 0.5333333333333333
<br>
<a href="#span-out-option1">RA選択</a>時　1*2/3*4/5 || (1*(2/(3*(4/5)))) -> 0.8333333333333333
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>は除算より優先する
<br>
<a href="#span-out-option2">記号省略乗算優先既定</a>時　1/2(2) || 1/(2(2)) -> 0.25
<br>
　　　　<a href="#span-out-option2">除算優先選択</a>時　1/2(2) || (1/2)(2) -> 1
<br>
<br>
べき乗と剰余の<a href="#span-out-type-ope">中置2項演算子</a>は四則演算子より優先する
<br>
-2^2 || (0-(2^2)) -> -4
<br>
-3^2 || (0-(3^2)) -> -8.999999999999998
<br>
-3%2 || (0-(3%2)) -> -1
<br>
-3^2%2 || -((3^2)%2) || (0-(8.999999999999998%2)) -> -0.9999999999999982
<br>
-3%2^2 || -(3%(2^2)) || (0-(3%4)) -> -3
<br>
-(2)3%2^2 || (0-((2)3)) -> -6
<br>
<br>
<a href="#span-out-type-ope">後置単項演算子</a>は<a href="#span-out-type-ope">中置2項演算子</a>より優先する
<br>
3^2! || 3^(2!) || 3^(2*1) -> 8.999999999999998
<br>
2*3!! || 2*(3!!) || 2*(3*1) -> 6
<br>
・<a href="#span-out-FN-fact">階乗</a>のoperandは0を含む自然数のみ対応
<br>
0! || 0!! || 0!!! -> 1
<br>
!!! || !! || ! || 0! -> 1
<br>
3.3!! || 3!! || 3*1 -> 3
<br>
(3)!!! || 3!!! || 3 -> 3
<br>
-(3)! || (0-(3!)) || (0-(3*2*1)) -> -6
<br>
・<a href="#span-out-FN-fact">階乗</a>のoperandが負の場合、未定義で<del>1を返す</del><span class="clear">Ver.2.69.28</span>以降、0を返す
<br>
<span class="clear">(-3)!</span> || ((-3)!) -> 0
<br>
<span class="clear">(-3)!!</span> || ((-3)!!) -> 0
<br>
(-3)*!! || (-3)*(0!!) -> -3
<br>
-3*! || (0-(3*(0!))) -> -3
<br>
・<a href="#span-out-com">虚数単位</a>iは<a href="#span-out-type-ope">後置単項演算子</a>とする
<br>
1/2i || 1/(2i) -> -0.5i
<br>
<br>
算術演算子は<a href="#span-out-prec-ope-bit">bit演算子</a>より優先する
<br>
-0xff&gt;&gt;2 || (-0xff)&gt;&gt;2 || ((0-255)&gt;&gt;2) -> -64
<br>
-0xff&gt;&gt;1@1 || (-0xff&gt;&gt;1)@1 || ((0-128)@1) -> -127
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>を許容しない場合、<a href="#span-out-config">裏設定</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
bit演算子
    </th>
    <td>
<span id="span-out-prec-ope-bit"></span>
bit演算子と付随する留意事項について記述する
<br>
<br>
bit or
<br>
・<a href="#span-out-float">単精度32bit</a>の符号あり整数
<br>
1|1  <span class="selection">// 00000001|00000001->00000001</span> -> 1
<br>
1|2  <span class="selection">// 00000001|00000010->00000011</span> -> 3
<br>
2|2  <span class="selection">// 00000010|00000010->00000010</span> -> 2
<br>
2|-2  <span class="selection">// 00000010|11111110->11111110</span> -> -2
<br>
2|-3  <span class="selection">// 00000010|11111101->11111111</span> -> -1
<br>
1|-3  <span class="selection">// 00000001|11111101->11111101</span> -> -3
<br>
1|-2  <span class="selection">// 00000001|11111110->11111111</span> -> -1
<br>
1|0.5  <span class="selection">// 00000001|00000000->00000001</span> -> 1
<br>
1.1|0.1  <span class="selection">// 00000001|00000000->00000001</span> -> 1
<br>
0|0.1  <span class="selection">// 00000000|00000000->00000000</span> -> 0
<br>
<br>
bit and
<br>
・<a href="#span-out-float">単精度32bit</a>の符号あり整数
<br>
1&amp;1  <span class="selection">// 00000001&amp;00000001->00000001</span> -> 1
<br>
1&amp;2  <span class="selection">// 00000001&amp;00000010->00000000</span> -> 0
<br>
2&amp;2  <span class="selection">// 00000010&amp;00000010->00000010</span> -> 2
<br>
2&amp;-2  <span class="selection">// 00000010&amp;11111110->00000010</span> -> 2
<br>
2&amp;-3  <span class="selection">// 00000010&amp;11111101->00000000</span> -> 0
<br>
1&amp;-3  <span class="selection">// 00000001&amp;11111101->00000001</span> -> 1
<br>
1&amp;-2  <span class="selection">// 00000001&amp;11111110->00000000</span> -> 0
<br>
1&amp;0.5  <span class="selection">// 00000001&amp;00000000->00000000</span> -> 0
<br>
1.1&amp;0.1  <span class="selection">// 00000001&amp;00000000->00000000</span> -> 0
<br>
0&amp;0.1  <span class="selection">// 00000000&amp;00000000->00000000</span> -> 0
<br>
<br>
bit shift
<br>
・<a href="#span-out-float">単精度32bit</a>の符号あり整数
<br>
-round(pow(2,31)) -> -2147483648
<br>
-1&lt;&lt;31 || -1&lt;&lt;63  <span class="selection">// 10000000000000000000000000000000</span> -> -2147483648
<br>
-1&lt;&lt;30 || -1&lt;&lt;62  <span class="selection">// 11000000000000000000000000000000</span> -> -1073741824
<br>
-1&lt;&lt;20 || -1&lt;&lt;52  <span class="selection">// 11111111111100000000000000000000</span> -> -1048576
<br>
-1&lt;&lt;10 || -1&lt;&lt;42  <span class="selection">// 11111111111111111111110000000000</span> -> -1024
<br>
-1&lt;&lt;3 || -1&lt;&lt;35  <span class="selection">// 11111111111111111111111111111000</span> -> -8
<br>
-1&lt;&lt;2 || -1&lt;&lt;34  <span class="selection">// 11111111111111111111111111111100</span> -> -4
<br>
-1&lt;&lt;1 || -1&lt;&lt;33  <span class="selection">// 11111111111111111111111111111110</span> -> -2
<br>
-1&gt;&gt;0 || -1&gt;&gt;32  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-8&gt;&gt;0 || -8&gt;&gt;32  <span class="selection">// 11111111111111111111111111111000</span> -> -8
<br>
-8&gt;&gt;1 || -8&gt;&gt;33  <span class="selection">// 11111111111111111111111111111100</span> -> -4
<br>
-8&gt;&gt;2 || -8&gt;&gt;34  <span class="selection">// 1111111111111111111111111111110</span> -> -2
<br>
-8&gt;&gt;3 || -8&gt;&gt;35  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-1&gt;&gt;3 || -1&gt;&gt;35  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-1&gt;&gt;10 || -1&gt;&gt;42  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-1&gt;&gt;20 || -1&gt;&gt;52  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-1&gt;&gt;30 || -1&gt;&gt;62  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
-1&gt;&gt;31 || -1&gt;&gt;63  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
・<a href="#span-out-float">単精度32bit</a>の符号なし整数
<br>
round(pow(2,32)-1) -> 4294967295
<br>
-1&gt;&gt;&gt;0 || -1&gt;&gt;&gt;32  <span class="selection">// 11111111111111111111111111111111</span> -> 4294967295
<br>
-8&gt;&gt;&gt;0 || -8&gt;&gt;&gt;32  <span class="selection">// 11111111111111111111111111111000</span> -> 4294967288
<br>
-8&gt;&gt;&gt;1 || -8&gt;&gt;&gt;33  <span class="selection">// 01111111111111111111111111111100</span> -> 2147483644
<br>
-8&gt;&gt;&gt;2 || -8&gt;&gt;&gt;34  <span class="selection">// 0011111111111111111111111111110</span> -> 1073741822
<br>
-8&gt;&gt;&gt;3 || -8&gt;&gt;&gt;35  <span class="selection">// 00011111111111111111111111111111</span> -> 536870911
<br>
-1&gt;&gt;&gt;3 || -1&gt;&gt;&gt;35  <span class="selection">// 00011111111111111111111111111111</span> -> 536870911
<br>
-1&gt;&gt;&gt;10 || -1&gt;&gt;&gt;42  <span class="selection">// 00000000001111111111111111111111</span> -> 4194303
<br>
-1&gt;&gt;&gt;20 || -1&gt;&gt;&gt;52  <span class="selection">// 00000000000000000000111111111111</span> -> 4095
<br>
-1&gt;&gt;&gt;30 || -1&gt;&gt;&gt;62  <span class="selection">// 00000000000000000000000000000011</span> -> 3
<br>
-1&gt;&gt;&gt;31 || -1&gt;&gt;&gt;63  <span class="selection">// 00000000000000000000000000000001</span> -> 1
<br>
<br>
bit not
<br>
・<a href="#span-out-float">単精度32bit</a>の符号あり整数
<br>
~0  <span class="selection">// 11111111111111111111111111111111</span> -> -1
<br>
~1  <span class="selection">// 11111111111111111111111111111110</span> -> -2
<br>
~-1 || (~(-1))  <span class="selection">// 00000000000000000000000000000000</span> -> 0
<br>
~-2 || (~(-2))  <span class="selection">// 00000000000000000000000000000001</span> -> 1
<br>
~-4 || (~(-4))  <span class="selection">// 00000000000000000000000000000011</span> -> 3
<br>
~-8 || (~(-8))  <span class="selection">// 00000000000000000000000000000111</span> -> 7
<br>
~3  <span class="selection">// 11111111111111111111111111111100</span> -> -4
<br>
~7  <span class="selection">// 11111111111111111111111111111000</span> -> -8
<br>
~2147483647  <span class="selection">// 10000000000000000000000000000000</span> -> -2147483648
<br>
~2147483648  <span class="selection">// 01111111111111111111111111111111</span> -> 2147483647
<br>
~2147483649  <span class="selection">// 01111111111111111111111111111110</span> -> 2147483646
<br>
~-2147483647 || (~(-2147483647))  <span class="selection">// 01111111111111111111111111111110</span> -> 2147483646
<br>
~-2147483648 || (~(-2147483648))  <span class="selection">// 01111111111111111111111111111111</span> -> 2147483647
<br>
~-2147483649 || (~(-2147483649))  <span class="selection">// 10000000000000000000000000000000</span> -> -2147483648
<br>
~-1&gt;&gt;&gt;31 || ((~(-1))&gt;&gt;&gt;31)  <span class="selection">// 00000000000000000000000000000000</span> -> 0
<br>
~(-1&gt;&gt;&gt;31) || (~(-1&gt;&gt;&gt;31))  <span class="selection">// 11111111111111111111111111111110</span> -> -2
<br>
<br>
bit演算子は<a href="#span-out-prec-ope-comparison">比較演算子</a>・<a href="#span-out-prec-ope-relational">関係演算子</a>より優先する
<br>
5&lt;2|4 || 5&lt;(2|4) || 5&lt;6 -> 1
<br>
4==2|4 || 4==(2|4) || 4==6 -> 0
<br>
<br>
留意事項を列挙する
<br>
・operandは実数のみ対応
<br>
・operandは<a href="#span-out-float">倍精度64bit</a>から<a href="#span-out-float">単精度32bit</a>に変換される
<br>
・bit演算子は短絡評価しない
<br>
<br>
符号なし整数の場合、<a href="../70_decimal/index.html">n進数⇒m進数変換</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
比較演算子
    </th>
    <td>
<span id="span-out-prec-ope-comparison"></span>
比較演算子と付随する留意事項について記述する
<br>
<br>
比較演算子は<a href="#span-out-prec-ope-relational">関係演算子</a>より優先する
<br>
1==2>1 || 1==(2>1) || 1==1 -> 1
<br>
<br>
留意事項を列挙する
<br>
・operandは実数のみ対応
<br>
・operandに虚数を入力した場合、0と判別される
<br>
i&lt;&lt;2 || real(i)&lt;&lt;2 || 0&lt;&lt;2 -> 0
<br>
2i>i || real(2i)>real(i) || 0>0 -> 0
<br>
<br>
比較演算子を代替する関数は<a href="#span-out-FN-ope">演算子代替関数入力仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
関係演算子
    </th>
    <td>
<span id="span-out-prec-ope-relational"></span>
関係演算子と付随する留意事項について記述する
<br>
<br>
論理ORをbit orで代替する場合、<a href="#span-out-BT">括弧</a>を明示するか<a href="#span-out-FN-ope">関数</a>を使用する
<br>
・1==1 || 1==-1
<br>
<a href="#span-out-option1">LA既定</a>時　1==1|1==-1 || 1==(1|1)==-1 || (1==1)==-1 || 1==-1  <span class="selection">// NG</span> -> 0
<br>
<a href="#span-out-option1">RA選択</a>時　1==1|1==-1 || 1==(1|1)==-1 || 1==(1==-1) || 1==0  <span class="selection">// NG</span> -> 0
<br>
(1==1)|(1==-1) || eq(1,1)|eq(1,-1) || 1|0 -> 1
<br>
・<span class="run">Ver.2.59.26</span>以降、<a href="#span-out-prec-ope-logical">論理演算子</a>を追加
<br>
1==1||1==-1 || (1==1)||(1==-1) || 1||0 -> 1
<br>
<br>
論理ANDをbit andで代替する場合、<a href="#span-out-BT">括弧</a>を明示するか<a href="#span-out-FN-ope">関数</a>を使用する
<br>
・1==1 &amp;&amp; 1==-1
<br>
<a href="#span-out-option1">LA既定</a>時　1==1&amp;1==-1 || 1==(1&amp;1)==-1 || (1==1)==-1 || 1==-1  <span class="selection">// NG</span> -> 0
<br>
<a href="#span-out-option1">RA選択</a>時　1==1&amp;1==-1 || 1==(1&amp;1)==-1 || 1==(1==-1) || 1==0  <span class="selection">// NG</span> -> 0
<br>
(1==1)&amp;(1==-1) || eq(1,1)&amp;eq(1,-1) || 1&amp;0 -> 0
<br>
・<span class="run">Ver.2.59.26</span>以降、<a href="#span-out-prec-ope-logical">論理演算子</a>を追加
<br>
1==1&amp;&amp;1==-1 || (1==1)&amp;&amp;(1==-1) || 1&amp;&amp;0 -> 0
<br>
<br>
留意事項を列挙する
<br>
・operandは実数のみ対応
<br>
・operandに虚数を入力した場合、0と判別される
<br>
i==0 || real(i)==0 -> 1
<br>
・operandに行列を入力した場合、<a href="#span-out-FNm-last">最終要素</a>を取り出す
<br>
・<a href="#span-out-FNm-last">last行列関数</a>を使用
<br>
(1,2)==(3,2) || last(1,2)==last(3,2) || 2==2 -> 1
<br>
・代入と判別されないequal記号=は、右辺移項の<a href="#span-out-type-ope">中置2項演算子</a>として扱う
<br>
2!=1 || 2=1 || =1-2 -> -1
<br>
・よってnot equal関係演算子は!=の代わりに&lt;&gt;を使用する
<br>
1&lt;&gt;2 -> 1
<br>
・次のような場合、<a href="#span-out-FN-ope">関数</a>で代替する方が間違いが少ない
<br>
2&lt;(=2) || lt(2,=2) -> 0
<br>
2&lt;=2 -> 1
<br>
<br>
関係演算子を代替する関数は<a href="#span-out-FN-ope">演算子代替関数入力仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
論理演算子
    </th>
    <td>
<span id="span-out-prec-ope-logical"></span>
論理演算子と付随する留意事項について記述する
<br>
<br>
論理OR
<br>
・<a href="#span-out-option1">LA既定</a>
<br>
0||1 -> 1
<br>
0||1||2 -> 1
<br>
2||1||0 -> 2
<br>
2i||1i||0i -> 2i
<br>
0i||1i||2i -> i
<br>
0(1-i)||1(1-i)||2(1-i) -> 1-i
<br>
0(1-i)||1(1-i)||2(1-i)||3(1-i) -> 1-i
<br>
real(0(1-i)||1(1-i)||2(1-i)||3(1-i)) -> 1
<br>
imag(0(1-i)||1(1-i)||2(1-i)||3(1-i)) -> -1
<br>
・<a href="#span-out-option1">RA選択</a>
<br>
0||1 -> 1
<br>
0||1||2 -> 2
<br>
2||1||0 -> 1
<br>
2i||1i||0i -> i
<br>
0i||1i||2i -> 2i
<br>
0(1-i)||1(1-i)||2(1-i) -> 2-2i
<br>
0(1-i)||1(1-i)||2(1-i)||3(1-i) -> 3-3i
<br>
real(0(1-i)||1(1-i)||2(1-i)||3(1-i)) -> 3
<br>
imag(0(1-i)||1(1-i)||2(1-i)||3(1-i)) -> -3
<br>
<br>
論理AND
<br>
・<a href="#span-out-option1">LA既定</a>
<br>
0&amp;&amp;1&amp;&amp;2 -> 0
<br>
2&amp;&amp;1&amp;&amp;0 -> 0
<br>
1&amp;&amp;0&amp;&amp;2 -> 0
<br>
1i&amp;&amp;0i&amp;&amp;2i -> 0
<br>
1&amp;&amp;2&amp;&amp;3 -> 3
<br>
1i&amp;&amp;2i&amp;&amp;3i -> 3i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i) -> 3-3i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i) -> 4-4i
<br>
real(1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i)) -> 4
<br>
imag(1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i)) -> -4
<br>
1(1-i)||2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i) -> 1-i
<br>
1(1-i)&amp;&amp;2(1-i)||3(1-i)&amp;&amp;4(1-i) -> 2-2i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)||4(1-i) -> 3-3i
<br>
・<a href="#span-out-option1">RA選択</a>
<br>
0&amp;&amp;1&amp;&amp;2 -> 0
<br>
2&amp;&amp;1&amp;&amp;0 -> 0
<br>
1&amp;&amp;0&amp;&amp;2 -> 0
<br>
1i&amp;&amp;0i&amp;&amp;2i -> 0
<br>
1&amp;&amp;2&amp;&amp;3 -> 1
<br>
1i&amp;&amp;2i&amp;&amp;3i -> i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i) -> 1-i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i) -> 1-i
<br>
real(1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i)) -> 1
<br>
imag(1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i)) -> -1
<br>
1(1-i)||2(1-i)&amp;&amp;3(1-i)&amp;&amp;4(1-i) -> 2-2i
<br>
1(1-i)&amp;&amp;2(1-i)||3(1-i)&amp;&amp;4(1-i) -> 3-3i
<br>
1(1-i)&amp;&amp;2(1-i)&amp;&amp;3(1-i)||4(1-i) -> 4-4i
<br>
<br>
論理演算子は最下位の<a href="#span-out-prec-ope">演算子のprecedence</a>で<a href="#span-out-substitution">変数への代入</a>より優先する
<br>
clear; x=&lt;a=3; (0||x=&gt;||2,a)  <span class="selection">// (0||0||2,3)</span> -> (2,3)
<br>
clear; x=&lt;a=3; (0||x=&gt;||a)  <span class="selection">// (0||0||3)</span> -> 3
<br>
clear; x=&lt;a=3; (0||(x=&gt;)||a)  <span class="selection">// (0||0||3)</span> -> 3
<br>
clear; 0||(a=3)||a  <span class="selection">// 0||0||3</span> -> 3
<br>
clear; 0||(a=3)||(a=-3)||a  <span class="selection">// 0||0||0||-3</span> -> -3
<br>
clear; a=3||3,a  <span class="selection">// a=(3||3),a</span> -> (0,3)
<br>
clear; 1||a=3  <span class="selection">// (1||a)=3</span> -> [MyErr]Invalid binary operation
<br>
clear; 1||=3  <span class="selection">// (1||)=3</span> -> [MyErr]Invalid binary operation
<br>
clear; 1||0=3  <span class="selection">// (1||0)=3</span> -> 2
<br>
clear; 0||0=3  <span class="selection">// (0||0)=3</span> -> 3
<br>
clear; i||0=3  <span class="selection">// (i||0)=3</span> -> 3-i
<br>
clear; 0||i=3  <span class="selection">// (0||i)=3</span> -> 3-i
<br>
<br>
留意事項を列挙する
<br>
・operandは<a href="#span-out-com">複素数</a>に対応
<br>
・実装の都合上、すべてのoperandを評価して短絡評価を模擬する（throughputに影響なし）
<br>
・論理AND演算子は<a href="#span-out-error-numerical">数値誤差</a>を無視して0の短絡評価を再現する
<br>
・論理OR演算子は<a href="#span-out-error-numerical">数値誤差</a>を無視してnot0の短絡評価を再現する
<br>
・<a href="#span-out-option1">LA既定</a>の場合、<a href="#span-out-type-ope">中置2項演算子</a>のright-operandよりleft-operandを優先して左から評価する
<br>
・<a href="#span-out-option1">RA選択</a>の場合、<a href="#span-out-type-ope">中置2項演算子</a>のleft-operandよりright-operandを優先して右から評価する
<br>
<br>
論理ORを厳密に短絡評価して処理を切替える場合、<a href="#span-out-FNh-switch">switch高階関数</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
浮動小数点
<br>
演算
    </th>
    <td>
<span id="span-out-float"></span>
JavaScriptによる実数の浮動小数点演算について記述する
<br>
<br>
JavaScriptの<a href="#span-out-number">Number</a>型はIEEE754規格の倍精度64bit2進形式の浮動小数点数を使用する
<br>
・浮動小数点数による演算を以降、浮動小数点演算と呼ぶ
<br>
・64bitの上位から順に3つのfield（符号部・指数部・仮数部）を持つ
<br>
10進換算の浮動小数点数
<br>
=(-1)^(符号部1bit)*pow(基数2,指数部11bit-bias)*(0||1+仮数部52bit)
<br>
・指数部・仮数部は符号なしの2進数
<br>
・指数部は符号ありを符号なしに変換する次のbiasを持つ
<br>
bias=2^(11-1)-1=1023
<br>
・pow関数(base,exponent)はbase^exponentを返却するNative関数
<br>
・10進換算の指数に相当する
<br>
pow(2,10) || 2^10 || 1024 -> 1.024e3
<br>
・仮数部が小数点以下の有効桁（10進換算で約16桁）を保持する
<br>
・最上位bitから最下位bitまでの10進換算した有効数字の演算結果を示す
<br>
pow(2,-1) || 2^(-1) -> 0.5
<br>
pow(2,-2) || 2^(-2) -> 0.25
<br>
...
<br>
pow(2,-51) || 2^(-51) -> 4.440892098500626e-16
<br>
pow(2,-52) || 2^(-52) -> 2.220446049250313e-16
<br>
・この最小値O(1e-16)より小さな有効数字は保持できない
<br>
・これを丸める<a href="#span-out-error">誤差</a>を<a href="#span-out-epsilon">Machine epsilon</a>と呼ぶ
<br>
<br>
64bit2進形式の浮動小数点演算の挙動を示す
<br>
・16桁の小数を入力した場合、同じ
<br>
0.9999999999999999 -> 0.9999999999999999
<br>
-0.9999999999999999 -> -0.9999999999999999
<br>
・17桁の小数を入力した場合、<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
0.99999999999999999 -> 1
<br>
-0.99999999999999999 -> -1
<br>
・整数も小数同様に、<a href="#span-out-number">Number</a>型で保存される
<br>
・よって17桁以上の整数を入力した場合、<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
9007199254740991 -> 9007199254740991
<br>
90071992547409911 -> 90071992547409900
<br>
900719925474099111 -> 900719925474099100
<br>
9007199254740991111 -> 9007199254740991000
<br>
90071992547409911111 -> 90071992547409900000
<br>
900719925474099111111 -> 900719925474099100000
<br>
9007199254740991111111 -> 9.007199254740991e+21
<br>
・1000で割って1000を掛けた場合、<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
9007199254740991/1000 -> 9007199254740.99
<br>
ans*1000 -> 9007199254740990
<br>
0.9999999999999999/1000 -> 0.0009999999999999998
<br>
ans*1000 -> 0.9999999999999998
<br>
・<a href="#span-out-ope">実数演算</a>の場合、2の累乗倍で演算すれば仮数部の有効桁が保持される
<br>
9007199254740991/1024 -> 8796093022207.999
<br>
ans*1024 -> 9007199254740991
<br>
9007199254740991/2^100 -> 7.105427357601001e-15
<br>
ans*2^100 -> 9007199254740991
<br>
9007199254740991/2^(-100) -> 1.1417981541647678e+46
<br>
ans*2^(-100) -> 9007199254740991
<br>
0.9999999999999999/1024 -> 0.0009765624999999999
<br>
ans*1024 -> 0.9999999999999999
<br>
0.9999999999999999/2^100 -> 7.888609052210117e-31
<br>
ans*2^100 -> 0.9999999999999999
<br>
0.9999999999999999/2^(-100) -> 1.2676506002282293e+30
<br>
ans*2^(-100) -> 0.9999999999999999
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Machine
<br>
epsilon
    </th>
    <td>
<span id="span-out-epsilon"></span>
浮動小数点演算のMachine epsilonについて記述する
<br>
<br>
<a href="#span-out-float">仮数部</a>の最下位bitの有効数字未満を丸める<a href="#span-out-error">相対誤差</a>をMachine epsilonと呼ぶ
<br>
・次のepsilonで定義する
<br>
epsilon || eps || pow(2,-52) -> 2.220446049250313e-16
<br>
・test caseを列挙する
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> 1
<br>
10+10epsilon -> 10.000000000000002
<br>
10+10epsilon/2 -> 10.000000000000002
<br>
10+10epsilon/4 -> 10
<br>
100+100epsilon/4 -> 100
<br>
1000+1000epsilon/4 -> 1000
<br>
1e4+1e4epsilon/4 -> 10000
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> 0.9999999999999999
<br>
1-epsilon/4 -> 1
<br>
10-10epsilon/4 -> 10
<br>
100-100epsilon/4 -> 100
<br>
1000-1000epsilon/4 -> 1000
<br>
1e4-1e4epsilon/4 -> 10000
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Number型
<br>
定数
    </th>
    <td>
<span id="span-out-number"></span>
JavaScriptのNumber型の定数について記述する
<br>
<br>
JavaScriptのNumber型の<a href="#span-out-FN0">定数</a>を列挙する
<br>
EPSILON -> 2.220446049250313e-16
<br>
MIN_SAFE_INTEGER || -(2^53-1) -> -9007199254740991
<br>
MAX_SAFE_INTEGER || +(2^53-1) -> 9007199254740991
<br>
MIN_VALUE -> 5e-324
<br>
MAX_VALUE -> 1.7976931348623157e+308
<br>
<br>
test caseを列挙する
<br>
MIN_VALUE/2 -> 0
<br>
MIN_VALUE*(1-EPSILON) -> 5e-324
<br>
MAX_VALUE*2 -> Infinity
<br>
MAX_VALUE*(1+EPSILON) -> Infinity
<br>
・Nativeの場合
<br>
Math.pow(2,Math.pow(2,10)) || 2**(2**10) -> Infinity
<br>
・<a href="#span-out-ope">実数演算</a>の場合、Nativeに同義
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> Infinity
<br>
・<a href="#span-out-com">複素数</a>演算の場合、MAX_VALUEに近い値が得られる
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> 1.7976931348622732e+308
<br>
(1+106epsilon)2^(2^10) -> 1.7976931348623155e+308
<br>
(1+107epsilon)2^(2^10) -> Infinity
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
誤差の扱い
    </th>
    <td>
<span id="span-out-error"></span>
誤差の種類とその扱いについて記述する
<br>
<br>
本manualでは大きく分けて次の2種類に分類する
<br>
・丸め誤差: 計算機での数値表現由来の誤差
<br>
　・情報落ち（絶対値の大きく異なる2つの数値の差||和を取る場合）
<br>
　・桁落ち（丸め誤差を含む同符号の2つの近い数値の差を取る場合）
<br>
・数値誤差: 数学的な近似由来の誤差
<br>
　・離散化誤差（<a href="#span-out-FNh-DX">微分</a>・<a href="#span-out-FNh-IX">積分</a>の無限小を有限の幅で離散化する場合）
<br>
　・打切り誤差（絶対収束する無限級数を有限の次数で打切る場合）
<br>
　・modelling誤差（数値誤差を許容して対象を理論的にmodel化する場合）
<br>
<br>
丸め誤差は無理数等を<a href="#span-out-float">仮数部</a>の有効桁に丸める際の、
<br>
近似値の真値に対する絶対誤差||相対誤差と定義する
<br>
・円周率20桁の演算結果を一例に示す
<br>
3.14159265358979323846 -> 3.141592653589793
<br>
pi -> 3.141592653589793
<br>
・円周率20桁の絶対誤差は<a href="#span-out-epsilon">Machine epsilon</a>に相当する
<br>
0.00000000000000023846 -> 2.3846e-16
<br>
epsilon -> 2.220446049250313e-16
<br>
・円周率20桁の相対誤差
<br>
0.00000000000000023846/pi -> 7.590417545938672e-17
<br>
<br>
2つの数値の減算||加算で情報落ちが発生した場合、警告文を表示する
<br>
・警告文は前置のinfoLost[実部r虚部i]とする
<br>
1+1e-16 -> infoLost[r ] 1
<br>
(1-1e-16)i -> infoLost[r ] 0.9999999999999999i
<br>
i+1e-16i -> infoLost[ i] i
<br>
1-1e-16+i-1e-16i -> infoLost[ri] 0.9999999999999999+0.9999999999999999i
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> infoLost[r ] 1
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> infoLost[r ] 0.9999999999999999
<br>
<br>
<a href="#span-out-com">虚数単位</a>iを求める<a href="#span-out-com">複素数</a>演算を一例に誤差情報の特徴を示す
<br>
(-1)^0.5 -> 6.123233995736766e-17+i
<br>
・実部に<a href="#span-out-epsilon">Machine epsilon</a>が残るため、1を加算すると情報落ちが発生する
<br>
ans+1 -> infoLost[r ] 1+i
<br>
・さらに演算を繰り返すと、誤差情報は消えることなく伝播する
<br>
ans+1 -> infoLost[r ] 2+i
<br>
ans+1 -> infoLost[r ] 3+i
<br>
ans+1 -> infoLost[r ] 4+i
<br>
ans+1 -> infoLost[r ] 5+i
<br>
・真値が0との乗算では本来、誤差情報も消えるが、逐次判定しないため、誤差情報が残る
<br>
ans*0 -> infoLost[r ] 0
<br>
<br>
桁落ちは判定困難で評価にかかる<a href="#span-out-ope">演算量</a>を見積もれないため、評価しない
<br>
・整数演算を一例に示す
<br>
・丸め誤差を含む2つの整数を作る
<br>
・<a href="#span-out-comment">comment文</a>に有効桁のbitの並びを示す
<br>
255  <span class="selection">// 11111111</span> -> 255
<br>
255&gt;&gt;2  <span class="selection">// 111111</span> -> 63
<br>
ans&lt;&lt;2  <span class="selection">// 11111100</span> -> 252
<br>
255&gt;&gt;3  <span class="selection">// 11111</span> -> 31
<br>
ans&lt;&lt;3  <span class="selection">// 11111000</span> -> 248
<br>
・2つの整数の差を取ると有効桁が減少して丸め誤差が拡大する
<br>
252-248  <span class="selection">// 100</span> -> 4
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
数値解の
<br>
数値誤差
    </th>
    <td>
<span id="span-out-error-numerical"></span>
数値解の数値誤差について記述する
<br>
<br>
Computer Algebra Systemで解析的に真値||厳密解||解析解が得られない場合
<br>
・数値誤差を許容した数値解を得る（例えば、<a href="#span-out-FNh-DX">微分</a>・<a href="#span-out-FNh-IX">積分</a>）
<br>
・<a href="#span-out-application">application</a>の数値解のthroughputを優先するため、Computer Algebra System未実装
<br>
・よって解析解が得られるcaseも数値誤差を許容する
<br>
詳細は<a href="#span-out-development-problems-CAS">未実装のCAS</a>参照
<br>
<br>
数値誤差は無限を有限で数学的に近似する際の、
<br>
近似値の真値に対する絶対誤差||相対誤差、あるいは、
<br>
近似解の厳密解に対する絶対誤差||相対誤差、あるいは、
<br>
数値解の解析解に対する絶対誤差||相対誤差と定義する
<br>
<br>
数値誤差は目安の解析誤差（絶対誤差）のOrderを表示する
<br>
・Order表示は後置の+O(実部+虚部i)とする
<br>
・目安の解析誤差は当てにならないため、解のdouble-checkが必要
<br>
<br>
f(x)=x^2のx=1+iにおける1階微分の数値解
<br>
x=1+i; _dx(=&lt;{x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・上記微分の解析解
<br>
x=1+i; 2x -> 2+2i
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
ansn=1.9999999999996223+1.9999999999996223i;
<br>
ansa=2+2i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 3.7769787297747826e-13+3.7769787297747826e-13i
<br>
・絶対誤差のEuclidian norm
<br>
norm(erra) -> 5.341454544442203e-13
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 1.8884893648873913e-13+1.8884893648873913e-13i
<br>
・相対誤差のEuclidian norm
<br>
norm(errr) -> 2.6707272722211015e-13
<br>
<br>
f(x)=x^4の積分範囲[0,1+i]における定積分の数値解
<br>
a=0; b=1+i; _ix(=&lt;{x^4},a,b) || ab=[0,1+i]; _ix(=&lt;{x^4},ab)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・解析解
<br>
a=0; b=1+i; (b^5-a^5)/5 -> -0.8000000000000003-0.8000000000000002i
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
ansn=-0.8000000053333336-0.8000000053333334i;
<br>
ansa=-0.8000000000000003-0.8000000000000002i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 5.333333330526102e-9+5.3333332195038e-9i
<br>
・絶対誤差のEuclidian norm
<br>
norm(erra) -> 7.54247225018186e-9
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 6.666666663157625e-9+6.666666524379749e-9i
<br>
・相対誤差のEuclidian norm
<br>
norm(errr) -> 9.428090312727323e-9
<br>
<br>
数値誤差の特徴を示す
<br>
・数値誤差を含む演算結果に対して
<br>
x=1+i; _dx(=&lt;{x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・演算すると目安の解析誤差も演算される
<br>
ans*1e3 -> 1999.9999999996223+1999.9999999996223i+O(1e-9+1e-9i)
<br>
ans/1e3 -> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
ans*ans -> 7.999999999996978i+O(8e-12i)
<br>
sinh(ans) -> 0.9893582466238214i+O(1e-12i)
<br>
・解析誤差は符号がないため、減算||加算では誤差の最大値を選択する
<br>
ans+2ans -> 2.968074739871464i+O(2e-12i)
<br>
ans-2ans -> -2.968074739871464i+O(5e-12i)
<br>
・真値が0との乗算では、目安の解析誤差も消える
<br>
ans*0 -> 0
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
裏設定
    </th>
    <td>
<span id="span-out-config"></span>
UIには表示しない裏設定について記述する
<br>
<br>
browser上部のURL入力欄のGET入力で<a href="#span-in-options">内部option</a>を変更可
<br>
・html直後の?に続けて&amp;区切りでparameterを渡す
<br>
index.html?param0=value0&amp;param1=value1&amp;param2=value2&amp;...
<br>
<br>
<a href="#span-out-config-strict">strict-mode</a>で実行する場合、not false&amp;not0を設定
<br>
useStrict=true
<br>
・乗算記号*省略不可
<br>
・<a href="#span-out-eqns-call">式読出し</a>記号=&gt;省略不可
<br>
<br>
<a href="#span-out-error">情報落ち</a>の発生や<a href="#span-out-FNh-DX">微分</a>・<a href="#span-out-FNh-IX">積分</a>の<a href="#span-out-error-numerical">数値誤差</a>を評価しない場合、false（0 disabled）を設定
<br>
checkError=false
<br>
・<a href="#span-out-ope">演算量</a>が数倍軽くなる
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、useScopeを追加
<br>
useScope=falseの場合、完全な後方互換で<a href="#span-out-scope-vars">変数のscope</a>を一切使用しない
<br>
useScope=trueの場合、すべての<a href="#span-out-BT">括弧</a>に<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
useScope=BT2の場合、<a href="#span-out-BT">波括弧{}</a>のみ<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
useScope=BT1の場合、<a href="#span-out-BT">丸括弧()</a>のみ<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
・<a href="#span-out-call-by-equation">式読出し</a>時、既定で<a href="#span-out-BT">丸括弧()</a>で括るが、<a href="#span-out-bracket">parse</a>段階で作る<a href="#span-in-scope-vars">static scopes2d array</a>以外は無効
<br>
<span class="run">Ver.2.32.17</span>以降、以下の条件を追加
<br>
useScope=notBT2の場合、<a href="#span-out-BT">波括弧{}</a>を除いて<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
useScope=notBT1の場合、<a href="#span-out-BT">丸括弧()</a>を除いて<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
useScope=notBT0の場合、<a href="#span-out-BT-square">角括弧[]</a>を除いて<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
useScope=defaultの場合（上記以外の場合）、<a href="#span-out-BT-square">角括弧[]</a>のみ<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
<br>
<a href="#span-out-prec-ope">演算子のprecedence</a>を変更する場合
<br>
・演算子の<a href="#span-in-prec">tag名</a>を優先順にcomma,区切りで列挙する
<br>
・<span class="run">Ver.2.59.26</span>以降、<a href="#span-out-prec-ope-logical">論理演算子</a>を追加
<br>
・<span class="run">Ver.2.71.28</span>以降、<a href="#span-out-prec-ope-bit">bit not演算子</a>を追加
<br>
precedence=
<br>
URi,URf,BRp,BRr,BRmo,BRdm,BRsa<span class="run">,PUbn</span>,BRbs,BRba,BRbx,BRbo,BRcn,BRrl<span class="run">,BRlA,BRlO</span>
<br>
・別途、乗算記号*の省略を許容しない場合、tag名BRmoを削除する
<br>
　その場合、treeを全走査判定する無駄な<a href="#span-out-ope">演算量</a>が減る
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
strict-mode
    </th>
    <td>
<span id="span-out-config-strict"></span>
strict-modeについて記述する
<br>
<br>
strict-modeは演算内容の入力規則に以下2点の制約条件を追加する
<br>
・<span class="condition">乗算記号*省略不可</span>
<br>
　omitted multiplication sign(*) disabled
<br>
・<span class="clear"><a href="#span-out-eqns-call">式読出し</a>記号=&gt;省略不可</span>
<br>
　omitted equation's call sign(=&gt;) disabled
<br>
<del>・<a href="#span-out-call-by-equation">式渡し</a>の括弧{}省略不可
<br>
　omitted Call-by-Equation's bracket({}) disabled</del><span class="run">Ver.2.28.15</span>以降、text modified
<br>
<br>
曖昧さを回避することで演算内容の入力上、引いては演算上の間違いを低減する
<br>
・<a href="#span-out-eqns-args">式変数のarguments</a>を使用して一例を示す
<br>
・Non-strict-modeの場合
<br>
clear; times(a,b)=&lt;a(b); times(-2,3) -> -6
<br>
clear; times(a,b)=&lt;a(b); times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; a(b)=&lt;-999; times(a,b)=&lt;a(b); times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; a(b)=&lt;-999; times(a,b)=&lt;a(b)<span class="clear">=&gt;</span>; times(-2,3)<span class="clear">=&gt;</span> -> -999
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times(-2,3) -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3) -> (-4,6)
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span>times; times -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span>(times) -> -12
<br>
・strict-modeの場合
<br>
clear; times(a,b)=&lt;a(b); times(-2,3) -> [MyErr]Invalid ans isFound
<br>
clear; times(a,b)=&lt;a(b); times(-2,3)<span class="clear">=&gt;</span> -> [MyErr]Invalid operation
<br>
clear; a(b)=&lt;-999; times(a,b)=&lt;a(b); times(-2,3)<span class="clear">=&gt;</span> -> [MyErr]Invalid operation
<br>
clear; a(b)=&lt;-999; times(a,b)=&lt;a(b)<span class="clear">=&gt;</span>; times(-2,3)<span class="clear">=&gt;</span> -> -999
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times(-2,3) -> [MyErr]Invalid ans isFound
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span> -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3) -> [MyErr]Invalid ans isFound
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span>times; times -> -6
<br>
clear; times(a,b)=&lt;a<span class="condition">*</span>b; times=2; times(-2,3)<span class="clear">=&gt;</span>(times) -> [MyErr]Invalid ans isFound
<br>
<br>
strict-modeで実行する場合、<a href="#span-out-config">裏設定</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算仕様
    </th>
    <td>
<span id="span-out-ope"></span>
演算量||演算速度に関係する演算仕様の概要について記述する
<br>
<br>
<a href="#span-out-UI-simple">UI設定</a>によって対応する用途を4種類示す
<br>
・有次元の<a href="#span-out-com">複素数</a>の<a href="#span-out-mat">行列</a>演算（complex&amp;matrix checked）
<br>
・有次元の実数の<a href="#span-out-mat">行列</a>演算（matrix checked）
<br>
・無次元の<a href="#span-out-com">複素数</a>演算（complex checked）
<br>
・無次元の実数演算（complex&amp;matrix unchecked）
<br>
<br>
次の2次の正方行列の<a href="#span-out-mat-product">行列積</a>を一例に
<br>
(0,0:0,1+i)(1,0:0,1)
<br>
・上記の用途順に演算結果のみ示す
<br>
-> (0,0:0,1+i)
<br>
-> (0,0:0,1)
<br>
-> 1+i
<br>
-> 1
<br>
<br>
用途によらず、行列要素は左から右にすべて演算する
<br>
・行vectorをcolon:区切りで列挙
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
・列vectorをcolon:区切りで列挙
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
<br>
<br>
その上で、無次元の演算の場合、行列の<a href="#span-out-FNm-last">最終要素</a>を取り出して演算する
<br>
(x=1,x=2x:x=2x,x)1 || {x=1,x=2x:x=2x,x}1 || (0,0:0,4)1 || (4)*1 -> 4
<br>
・よって行列の積は次の乗算に変換される
<br>
(x=1,x=2x:x=2x,x){x=1,x=2x:x=2x,x} || (4)*{4} -> 16
<br>
<br>
以上より、n次の正方行列の<a href="#span-out-mat-product">行列積</a>の演算量を用途順に概算して示す
<br>
4*(n*n)*(n*n)
<br>
(n*n)*(n*n)
<br>
4
<br>
1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
拡張行列演算
    </th>
    <td>
<span id="span-out-ope-extended"></span>
拡張行列演算の演算仕様について記述する
<br>
<br>
<span class="run">Ver.2.73.29</span>以降、<span class="clear">本来、定義できない<a href="#span-out-mat">行列</a>演算を拡張</span>して<span class="run">拡張行列演算</span>を定義する
<br>
・定義できない<a href="#span-out-mat">行列</a>演算は実用しないため、拡張前の演算結果に影響なし
<br>
・<span class="run">Ver.2.74.29</span>以降、<a href="#span-out-type-ope">演算子のoperand</a>を追加で拡張
<br>
詳細は<a href="#span-out-ope-extended-history">拡張履歴</a>参照
<br>
<br>
拡張行列演算の仕様を列挙する
<br>
・拡張対象は<a href="#span-out-FN">関数の引数vector</a>||<a href="#span-out-type-ope">演算子のoperand</a>
<br>
・定義可能な<a href="#span-out-mat">行列</a>演算の<a href="#span-out-prec-ope">乗算||減算||加算演算子</a>は拡張対象外（変更なし）
<br>
<br>
test caseを列挙する
<br>
・<a href="#span-out-ope">実数演算</a>
<br>
min(1,2:3,4) || (min(1,2):min(3,4)) -> (1:3)
<br>
max(1,2:3,4) || (max(1,2):max(3,4)) -> (2:4)
<br>
(2,3,4)^(1,2) || (2,3,4)^(1,2,2) -> (2,9,16)
<br>
(2,3)**{1,2} || (2,3:2,3)**{1,2:1,2} || (2,3:2,3)**(1,1:2,2) -> (2,3:4,9)
<br>
(1,2:3,4:5)**{1,2} || (1,2:3,4:5)**{1,2,2:1,2} || (1,2:3,4:5)**(1,1:2,2:2) -> (1,2:9,16:25)
<br>
(3,5,7)%(1,5) || (3,5,7)%(1,5,5) -> (0,0,2)
<br>
(1,2,4)/2 -> (0.5,1,2)
<br>
2/(1,2,4) -> (2,1,0.5)
<br>
(2,4,8)&gt;&gt;(3,1) || (2,4,8)&gt;&gt;(3,1,1) -> (0,2,4)
<br>
clear; (x={0,1,2,3,4,5,6,7})||~(x&lt;&lt;1)%3 -> (-1:-3:-2:-1:-3:-2:-1:-3)
<br>
・<a href="#span-out-com">複素数</a>演算
<br>
cmin((1,2:3,4)i) || (cmin(1i,2i):cmin(3i,4i)) -> (1:3)
<br>
cmax((1,2:3,4)i) || (cmax(1i,2i):cmax(3i,4i)) -> (2:4)
<br>
(5,3,1)/(2i,i) || (5,3,1)/(2i,i,i) -> (-2.5i,-3i,-i)
<br>
clear; x={0,1,2,3,4,5,6,7}; y=(x*1,x*2,x*3)/(i,-2,3); y ->
<br>
(
<br>
0,0,0:
<br>
-i,-1,1:
<br>
-2i,-2,2:
<br>
-3i,-3,3:
<br>
-4i,-4,4:
<br>
-5i,-5,5:
<br>
-6i,-6,6:
<br>
-7i,-7,7
<br>
)
<br>
min(y),max(y) -> (0,0:-1,1:-2,2:-3,3:-4,4:-5,5:-6,6:-7,7)
<br>
clear; x={0,1,2,3,4,5,6,7}; N=sizer(x); f=e^((x*2*pi/N)i); f ->
<br>
(
<br>
1:
<br>
0.7071067811865476+0.7071067811865475i:
<br>
6.123233995736766e-17+i:
<br>
-0.7071067811865475+0.7071067811865476i:
<br>
-1+1.2246467991473532e-16i:
<br>
-0.7071067811865477-0.7071067811865475i:
<br>
-1.8369701987210297e-16-i:
<br>
0.7071067811865474-0.7071067811865477i
<br>
)
<br>
round_real(f,n)=&lt;round(real(f)*round(10**(n||1)))/round(10**(n||1));
<br>
round_imag(f,n)=&lt;round(imag(f)*round(10**(n||1)))/round(10**(n||1));
<br>
round_f(f,nr,ni)=&lt;round_real(=&lt;f,nr)+(round_imag(=&lt;f,ni))i;
<br>
round_f(=&lt;f,,2) -> (1:0.7+0.71i:i:-0.7+0.71i:-1:-0.7-0.71i:-i:0.7-0.71i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
拡張履歴
    </th>
    <td>
<span id="span-out-ope-extended-history"></span>
拡張行列演算の拡張履歴について記述する
<br>
<br>
<a href="#span-out-ope-extended">拡張行列演算</a>の拡張履歴を示す
<br>
・<a href="#span-out-FN">関数の引数vector</a>の場合
<br>
最終行vector　⇒　<span class="run">Ver.2.73.29</span>以降、各行vectorに拡張
<br>
・<a href="#span-out-type-ope">演算子のoperand</a>の場合
<br>
最終行vector　⇒　<span class="run">Ver.2.73.29</span>以降、各行vectorに拡張（<a href="#span-out-option4">comma演算子</a>を適用）
<br>
　　　　　　　⇒　<span class="run">Ver.2.74.29</span>以降、各要素に拡張（<a href="#span-out-option4">comma演算子</a>使用を選択可）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
型の種類
    </th>
    <td>
<span id="span-out-types"></span>
型の種類について記述する
<br>
<br>
演算単位として唯一定義する型、structureを次に示す
<br>
・<a href="#span-out-float">浮動小数点数</a>の実部と虚部から成る<a href="#span-out-com">複素数</a>の<a href="#span-out-mat">行列</a>
<br>
<br>
演算単位のstructureを以降、<a href="#span-in-tree">単位tree構造</a>と呼ぶ
<br>
・複素数や整数、文字列等の型は定義しない
<br>
・<a href="#span-out-vars-symbol">変数名symbol</a>のみ、呼出し時に内部で判別する
<br>
・よって<a href="#span-out-ope">用途</a>をseamlessに切替えて<a href="#span-out-ope">演算量</a>を調整する
<br>
<br>
詳細は<a href="#span-in-tree">単位tree構造</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数の種類
    </th>
    <td>
<span id="span-out-types-vars"></span>
変数の種類について記述する
<br>
<br>
変数の種類は以下2種類で代入記号と読出し方法が異なる
<br>
・<a href="#span-out-vars">変数</a>
<br>
・<a href="#span-out-eqns">式変数</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数のscope
    </th>
    <td>
<span id="span-out-scope-vars"></span>
変数のscopeについて記述する
<br>
<br>
<del>各変数にscopeの概念はない</del><span class="run">Ver.2.31.17</span>以降、変数のscopeを追加
<br>
・変数毎に<a href="#span-out-storage">storage</a>を共有する
<br>
・<a href="#span-out-FNh">高階関数</a>と<a href="#span-out-FNmh">高階行列関数</a>で扱うdummy変数のみ、scopeが独立する
<br>
<br>
次の<a href="#span-out-command">命令文</a>の組合せで完全独立のlocal scopeを代替可
<br>
・<a href="#span-out-comment">comment文</a>を使用
<br>
x=2; store; clear; x=3<span class="selection">/*independent local scope*/</span>; restore; x -> 2
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、<a href="#span-out-BT-square">角括弧[]</a>に変数のscopeを追加
<br>
過去の後方互換性を完全に維持する場合、<a href="#span-out-config">裏設定</a>参照
<br>
<br>
scope内での<a href="#span-out-vars">変数</a>||<a href="#span-out-eqns">式変数</a>の宣言はECMAScript6（以降、ES6と省略する）のlet宣言を想定
<br>
<a href="#span-out-bracket">直列scope内</a>の変数はreadonly（pollution disabled）
<br>
scopeから直接、local <a href="#span-out-storage">storage</a>にwriteする場合、<a href="#span-out-FNc">最上位関数</a>参照
<br>
・test caseを列挙する
<br>
clear; [a=2,[a=1,a],a] -> (0,0,1,2)
<br>
clear; [a=2,=&lt;[a=1,=&lt;a]=&gt;+a]=&gt; -> 3
<br>
・<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>はES6のlet変数同様に宣言時の<a href="#span-out-bracket">階層</a>に依存する
<br>
・よって同一scope内の変数のみ、<a href="#span-out-substitution">変数への代入</a>可
<br>
clear; a=3,[a=1,a,a=2,a],a -> (0,0,1,0,2,3)
<br>
clear; a=3; [a=1,a,a=2,a]; a -> 3
<br>
clear; [a=1,a],a -> [MyErr]Invalid REv(a)
<br>
clear; [a=1,a]; a -> [MyErr]Invalid REv(a)
<br>
・<a href="#span-out-matching">行列要素pattern matching</a>による変数への代入も同様
<br>
clear; a=3,[($a)=1,a,($a)=2,a],a -> (0,0,1,0,2,3)
<br>
clear; a=3; [($a)=1,a,($a)=2,a]; a -> 3
<br>
clear; [($a)=1,a],a -> [MyErr]Invalid REv(a)
<br>
clear; [($a)=1,a]; a -> [MyErr]Invalid REv(a)
<br>
・<a href="#span-out-substitution-mat">行列への代入</a>も同様
<br>
clear; [A=(1,2),A[0][0]=-1,A] -> (0,0,-1,2)
<br>
clear; A=(1,2); [A[0][0]=-1,A] -> [MyErr]Invalid SEv-scope(A)
<br>
・<a href="#span-out-bracket">並列scope</a>の変数を参照不可
<br>
clear; [A=(1,2),],[A] -> [MyErr]Invalid REv(A)
<br>
clear; ([A=(1,2),],[A]) -> [MyErr]Invalid REv(A)
<br>
clear; [A=(1,2),],[B=-A,] -> [MyErr]Invalid binary operation
<br>
clear; ([A=(1,2),],[B=-A,]) -> [MyErr]Invalid binary operation
<br>
・<a href="#span-out-bracket">直列scope内</a>の変数を参照可
<br>
clear; A=(1,2); [A] -> (1,2)
<br>
clear; A=(1,2); [-A] -> (-1,-2)
<br>
clear; A=(1,2); [B=-A,B] -> (0,-1,-2)
<br>
clear; A=(1,2); [B=-A,[C=A+B,C]] -> (0,0,0,0)
<br>
clear; A=(1,2); [B=-A,[C=A+B,C],C] -> [MyErr]Invalid REv(C)
<br>
clear; a=3; [($a,{($b)=a})=2,a+b] -> (0,5)
<br>
・<a href="#span-out-bracket">直列scope内</a>の変数の<a href="#span-out-bracket">search-precedence</a>
<br>
clear; A=(1,2); B=A; [B=-B,[C=A+B,C]] -> (0,0,0,0)
<br>
clear; A=(1,2); B=A; [B=-B,[C=A+B,C]]; B -> (1,2)
<br>
clear; A=(1,2); B=A; (B=-B,[C=A+B,C]) -> (0,0,0,0)
<br>
clear; A=(1,2); B=A; (B=-B,[C=A+B,C]); B -> (-1,-2)
<br>
・<a href="#span-out-eqns">式変数</a>も同様
<br>
clear; A=&lt;(1,2); B=&lt;A; [B=&lt;-B,[C=&lt;A+B,C]] -> [MyErr]Invalid circular(B)
<br>
clear; A=&lt;(1,2); B=&lt;A; [D=-B,B=&lt;D,[C=&lt;A+B,C]] -> (0,0,0,0,0)
<br>
clear; A=&lt;(1,2); B=&lt;A; [D=-B,B=&lt;D,[C=&lt;A+B,C]]; B -> (1,2)
<br>
clear; A=&lt;(1,2); B=&lt;A; (D=-B,B=&lt;D,[C=&lt;A+B,C]) -> (0,0,0,0,0)
<br>
clear; A=&lt;(1,2); B=&lt;A; (D=-B,B=&lt;D,[C=&lt;A+B,C]); B -> (-1,-2)
<br>
clear; a=&lt;[3+4,]; ([a=&gt;]+[a=&gt;])*trans([a=&gt;]) -> 98
<br>
・宣言時の<a href="#span-out-bracket">階層</a>に依存するため、次の場合、error終了
<br>
let a=()=&gt;b; (function(){let b=1; return a();})();  <span class="selection">// ES6</span> -> b is not defined
<br>
clear; a=&lt;b; [b=1,=&lt;a=&gt;]=&gt; -> [MyErr]Invalid REv(b)
<br>
・<a href="#span-out-call-by-equation">式読出し</a>時の<a href="#span-out-bracket">階層</a>を継承する場合、<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>を使用
<br>
・式読出し記号==&gt;
<br>
clear; a=&lt;b; [b=1,=&lt;a=&gt;]=&gt; -> [MyErr]Invalid REv(b)
<br>
clear; a=&lt;b; [b=1,=&lt;a==&gt;]=&gt; -> 1
<br>
clear; a=&lt;b; [b=1,=&lt;a==&gt;]==&gt; -> 1
<br>
・同義
<br>
(function(){let a=()=&gt;b; let b=1; return a();})();  <span class="selection">// ES6</span> -> 1
<br>
clear; [a=&lt;b,b=1,=&lt;a=&gt;]=&gt; -> 1
<br>
・let宣言の挙動を以下に比較して示す
<br>
(function(){let a=()=&gt;b; let c=a(); let b=3; return c;})();  <span class="selection">// ES6</span> ||
<br>
let b=-1; (function(){let a=()=&gt;b; let c=a(); let b=3; return c;})();  <span class="selection">// ES6</span>
<br>
-> Cannot access 'b' before initialization
<br>
clear; [a=&lt;b,c=a=&gt;,b=1,=&lt;c]=&gt; -> [MyErr]Invalid REv(b)
<br>
clear; b=-1; [a=&lt;b,c=a=&gt;,b=1,=&lt;c]=&gt;  <span class="selection">// not hoisted</span> -> -1
<br>
let b=-1; (function(){let a=()=&gt;b; let c=a(); return c;})();  <span class="selection">// ES6</span> -> -1
<br>
clear; b=-1; [a=&lt;b,c=a=&gt;,=&lt;c]=&gt; -> -1
<br>
let b=-1; (function(){let a=()=&gt;b; let b=1; let c=a(); return c;})();  <span class="selection">// ES6</span> -> 1
<br>
clear; b=-1; [a=&lt;b,b=1,c=a=&gt;,=&lt;c]=&gt; -> 1
<br>
・<a href="#span-out-FNc">最上位関数</a>を使用
<br>
clear; b=-1; a=&lt;[b,b]; a=&gt; -> (-1,-1)
<br>
clear; b=-1; a=&lt;[b,b]; b=1,a=&gt; -> (0,1,1)
<br>
clear; b=-1; a=&lt;[b,b]; [b=1,a=&gt;] -> (0,-1,-1)
<br>
clear; a=&lt;b; [b=1,a=&gt;] -> [MyErr]Invalid REv(b)
<br>
clear; a=&lt;b+1; [b=1,a=&gt;] -> [MyErr]Invalid binary operation
<br>
clear; a=&lt;[b,b]; [b=1,a=&gt;] -> [MyErr]Invalid REv(b)
<br>
clear; a=&lt;[b,b]; [b=2,addVar(b),a=&gt;] -> (0,1,2,2)
<br>
clear; [a=&lt;[b,b],b=1,a=&gt;,b=2,a=&gt;] -> (0,0,1,1,0,2,2)
<br>
clear; [a=&lt;[b,b],[b=1,],a=&gt;] -> [MyErr]Invalid REv(b)
<br>
clear; [a=&lt;[b,b],[b=2,addVar(b)],a=&gt;] -> (0,0,1,2,2)
<br>
clear; b=-1; a=&lt;[b,b]; [[b=1,],a=&gt;] -> (0,0,-1,-1)
<br>
clear; b=-1; a=&lt;[b,[b,]]; [b=1,a=&gt;] -> (0,-1,-1,0)
<br>
clear; b=-1; [a=&lt;[b,[b,]],b=1,a=&gt;] -> (0,0,1,1,0)
<br>
clear; b=-1; [a=&lt;[b,[b,]],[b=1,b],[a=&gt;,b]] -> (0,0,1,-1,-1,0,-1)
<br>
clear; b=-1; [a=&lt;[b,[b,]],[b=1,b],b=2,[a=&gt;,b]] -> (0,0,1,0,2,2,0,2)
<br>
clear; b=-1; [a=&lt;(b,[b,[b,]]),b=1,a=&gt;] -> (0,0,1,1,1,0)
<br>
clear; b=-1; [a=&lt;(b,[b=2,[b,]]),b=1,a=&gt;] -> (0,0,1,0,2,0)
<br>
clear; b=-1; [a=&lt;(b,[b=2,[b,]]),b=1,=&lt;a=&gt;]=&gt; -> (1,0,2,0)
<br>
clear; b=-1; a=&lt;(b,[b=2,[b,]]); ([b=1,a=&gt;]) -> (0,-1,0,2,0)
<br>
・scopeのnesting
<br>
clear; a=-1; [a=1,=&lt;a+1]=&gt; -> 2
<br>
clear; a=-1; [a=&lt;1,=&lt;a]=&gt; -> -1
<br>
clear; a=-1; [a=&lt;1,=&lt;a=&gt;]=&gt; -> 1
<br>
clear; a=-1; [[a=&lt;1],=&lt;a=&gt;]=&gt; -> [MyErr]Invalid reference
<br>
clear; a=-1; [[a=&lt;1,a],=&lt;a=&gt;]=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; a=&lt;-1; [[a=&lt;1,a],=&lt;a=&gt;]=&gt; -> -1
<br>
clear; [a=&lt;1,=&lt;a=&gt;+1]=&gt; -> 2
<br>
clear; a=1; [a=2,=&lt;(a,[[a=3,a],a])]=&gt;,a -> (2,0,3,2,1)
<br>
clear; a=1; [a=2,=&lt;{a,[[a=3,a],a]}]=&gt;,a -> (2,1:0,3,2)
<br>
clear; a=1; {[a=2,=&lt;{a,[[a=3,a],a]}]}=&gt;,a -> (2,1:0,3,2)
<br>
clear; a=1; {a=2,=&lt;{a,[[a=3,a],a]}}=&gt;,a -> (2,2:0,3,2)
<br>
clear; [a=1,(a=2,[a,a=3,a],a=4),a,[a,a=5,a],a] -> (0,0,2,0,3,0,4,4,0,5,4)
<br>
clear; [a=1,a[0][0]=2,(a,3)] -> (0,0,2,3)
<br>
clear; a=1,[a=2,[a=3,=&lt;a]=&gt;,a,[a,a],[($a)=4,a]],a -> (0,0,3,2,2,2,0,4,1)
<br>
clear; a=1,(a=2,[a=3,=&lt;a]=&gt;,a,[a,a],[($a)=4,a]),a -> (0,0,3,2,2,2,0,4,2)
<br>
clear; a=-1; [a=1,(a=2,[a=3,=&lt;a]=&gt;,a,[a,a],[($a)=4,a]),a],a -> (0,0,3,2,2,2,0,4,2,-1)
<br>
clear; a=-1; [a=1,(a=2,[a=&lt;3,=&lt;a]=&gt;,a,[a,a],[($a)=4,a]),a],a -> (0,0,2,2,2,2,0,4,2,-1)
<br>
clear; a=-1; [a=1,(a=2,[a=&lt;3,=&lt;a=&gt;]=&gt;,a,[a,a],[($a)=4,a]),a],a -> (0,0,3,2,2,2,0,4,2,-1)
<br>
clear; a=-1; [a=1,(a=2,[a=&lt;3,=&lt;a=&gt;]=&gt;,a,[a,a],[($a)=4,a]),=&lt;a]=&gt;,a -> (2,-1)
<br>
・<a href="#span-out-call-by-equation">式渡しの直接式読出し</a>
<br>
・(function(){return (function(){return (function(){var a=1; return 3;})()+a;})()*2;})();
<br>
clear; [=&lt;[=&lt;[a=1,=&lt;3]=&gt;+a]=&gt;*2]=&gt; -> [MyErr]Invalid binary operation
<br>
・(function(){return (function(){var a=1; return (function(){return 3;})()+a;})()*2;})();
<br>
clear; [=&lt;[a=1,=&lt;[=&lt;3]=&gt;+a]=&gt;*2]=&gt; -> 8
<br>
・(function(){var a=1; return (function(){return (function(){return 3;})()+a;})()*2;})();
<br>
clear; [a=1,=&lt;[=&lt;[=&lt;3]=&gt;+a]=&gt;*2]=&gt; -> 8
<br>
・var a=1; (function(){return (function(){return (function(){return 3;})()+a;})()*2;})();
<br>
clear; a=1; [=&lt;[=&lt;[=&lt;3]=&gt;+a]=&gt;*2]=&gt; -> 8
<br>
・(function(){return (function(){return (function(){var a=1; return 3;})()+1;})()*a;})();
<br>
clear; [=&lt;[=&lt;[a=1,=&lt;3]=&gt;+1]=&gt;*a]=&gt; -> [MyErr]Invalid binary operation
<br>
・(function(){return (function(){var a=1; return (function(){return 3;})()+1;})()*a;})();
<br>
clear; [=&lt;[a=1,=&lt;[=&lt;3]=&gt;+1]=&gt;*a]=&gt; -> [MyErr]Invalid binary operation
<br>
・(function(){var a=1; return (function(){return (function(){return 3;})()+1;})()*a;})();
<br>
clear; [a=1,=&lt;[=&lt;[=&lt;3]=&gt;+1]=&gt;*a]=&gt; -> 4
<br>
・var a=1; (function(){return (function(){return (function(){return 3;})()+1;})()*a;})();
<br>
clear; a=1; [=&lt;[=&lt;[=&lt;3]=&gt;+1]=&gt;*a]=&gt; -> 4
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数の
<br>
scope
<br>
継承call
    </th>
    <td>
<span id="span-out-scope-inherited-call"></span>
式変数のscope継承callについて記述する
<br>
<br>
<a href="#span-out-bracket">直列scope内</a>の<a href="#span-out-eqns">式変数</a>をcallする際、<a href="#span-out-call-by-equation">式読出し</a>時の<a href="#span-out-bracket">階層</a>を継承する場合
<br>
・<a href="#span-out-eqns">式変数</a>のscope継承callと定義する
<br>
・Nativeの.call(this)を想定するが、
<br>
・thisの<a href="#span-out-bracket">直列scope内</a>の<a href="#span-in-scope-vars">parents-scope</a>を含めて継承後、callする点で異なる
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、追加の<a href="#span-out-eqns-call">式読出し</a>記号==&gt;を使用
<br>
・test caseを列挙する
<br>
clear; a=&lt;b; [b=1,=&lt;a=&gt;]=&gt; -> [MyErr]Invalid REv(b)
<br>
clear; a=&lt;b; [b=1,=&lt;a==&gt;]=&gt; -> 1
<br>
clear; a=&lt;b; [b=1,=&lt;a==&gt;]==&gt; -> 1
<br>
clear; a=&lt;b; [b=1,=&lt;[=&lt;a==&gt;]=&gt;]=&gt; -> 1
<br>
clear; a=&lt;b; [=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 1
<br>
clear; a=&lt;b; [b=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;+a=&gt;]=&gt; -> [MyErr]Invalid BRsa operation
<br>
clear; a=&lt;b; [b=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;+a==&gt;]=&gt; -> 3
<br>
clear; a=&lt;b; [b=3,=&lt;[b=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;+a==&gt;]=&gt;+a==&gt;]=&gt; -> 6
<br>
clear; a=&lt;b+c; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 3
<br>
clear; a=&lt;b+c+d; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; a=&lt;b+c+d; [d=3, c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; [a=&lt;b+c+d, d=3, c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; [d=3, c=2,=&lt;[a=&lt;b+c+d, b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; a=&lt;last[sum=b+c+d,sum]; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; a=&lt;last[sum=b+c+d,last[,-sum]]; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> -6
<br>
clear; a=&lt;last[sum=b+c+d,last[,-sum]]; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> -6
<br>
clear; a=&lt;last[sum=b+c+d,last[,-sum]]; d=3; [c=2,=&lt;[c=-c,b=1,=&lt;a==&gt;]=&gt;]=&gt; -> -2
<br>
clear; a=&lt;last[sum=b+c+d,last[,-sum]]; d=3; [c=-d,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> -1
<br>
clear; a=&lt;last{sum=b+c+d,last[,-sum]}; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> -6
<br>
clear; a=&lt;last{d=-100,sum=b+c+d,last[,-sum]}; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 97
<br>
・callする<a href="#span-out-eqns">式変数</a>の0<a href="#span-out-bracket">階層</a>に宣言される<a href="#span-out-vars">変数</a>はcall先<a href="#span-out-bracket">scope</a>に定義する
<br>
clear; a=&lt;last{d=-100,sum=b+c+d,last[,-sum]}; d=3; [c=2,=&lt;[b=1,a==&gt;,=&lt;d]=&gt;]=&gt; -> -100
<br>
clear; a=&lt;last{d=-100,sum=b+c+d,last[,-sum]}; [c=2,=&lt;[d=3,b=1,a==&gt;,=&lt;d]=&gt;]=&gt; -> -100
<br>
clear; [a=&lt;last{d=-100,sum=b+c+d,last[,-sum]},c=2,=&lt;[d=3,b=1,a==&gt;,=&lt;d]=&gt;]=&gt; -> -100
<br>
・callする<a href="#span-out-eqns">式変数</a>の1<a href="#span-out-bracket">階層</a>に宣言される場合、call先から参照不可
<br>
clear; a=&lt;last[d=-100,sum=b+c+d,last[,-sum]]; [c=2,=&lt;[d=3,b=1,a==&gt;,=&lt;d]=&gt;]=&gt; -> 3
<br>
clear; [a=&lt;last[d=-100,sum=b+c+d,last[,-sum]],c=2,=&lt;[d=3,b=1,a==&gt;,=&lt;d]=&gt;]=&gt; -> 3
<br>
・scope継承callのnesting
<br>
clear; a=&lt;b; b=0; last[b=1,c=&lt;a=&gt;,[b=2,c=&gt;]] -> 0
<br>
clear; a=&lt;b; b=0; last[b=1,c=&lt;a=&gt;,[b=2,c==&gt;]] -> 0
<br>
clear; a=&lt;b; b=0; last[b=1,c=&lt;a==&gt;,[b=2,c=&gt;]] -> 1
<br>
clear; a=&lt;b; b=0; last[b=1,c=&lt;a==&gt;,[b=2,c==&gt;]] -> 2
<br>
clear; a=&lt;b==&gt;; b=&lt;0; last[b=&lt;1,c=&lt;a==&gt;,[b=&lt;2,c==&gt;]] -> 2
<br>
<br>
実装logicのtest caseを以下に示す
<br>
・<a href="#span-out-eqns">式変数</a>s0のcall後、<a href="#span-in-scope-vars">scopes2d array</a>の各<a href="#span-out-bracket">scope</a>に各<a href="#span-out-vars">変数</a>が定義されることを確認する
<br>
clear; s0=&lt;[s1=1,[s1,s2=2,[s2,s3=3,[s3,s4=4,[s4,s5=5]]]]]; s0=&gt; -> (0,1,0,2,0,3,0,4,0)
<br>
clear; s0=&lt;[s1=1,[s1,s2=2,[s2,s3=3,[s3,s4=4,[s4,s5=5]]]]]; [s0=&gt;,] -> (0,1,0,2,0,3,0,4,0,0)
<br>
・<a href="#span-out-eqns">式変数</a>s2のcall後、<a href="#span-in-scope-vars">scopes2d array</a>の各<a href="#span-out-bracket">scope</a>に各<a href="#span-out-vars">変数</a>が定義されることを確認する
<br>
clear; s0=0,[s1=1,[s2=&lt;[s3=s1+2,[s4=s3+1,s4]],[s5=last[s2==&gt;],s5]]] -> (0,0,0,0,4)
<br>
・<a href="#span-out-eqns">式変数</a>s0の通常call=&gt;の場合、<a href="#span-out-vars">変数</a>s0はlocal storageに定義される
<br>
clear; s0=&lt;s0=[s1=1,[s1,s2=2,[s2,s3=3]]]; [s0=&gt;,s0,hasVar(s0),hasV(s0)] -> (0,0,1,0,2,0,1,1)
<br>
・<a href="#span-out-eqns">式変数</a>s0のscope継承call==&gt;の場合、<a href="#span-out-vars">変数</a>s0はscope内に定義される
<br>
clear; s0=&lt;s0=[s1=1,[s1,s2=2,[s2,s3=3]]]; [s0==&gt;,s0,hasVar(s0),hasV(s0)] -> (0,0,1,0,2,0,0,1)
<br>
<br>
詳細は<a href="#span-in-scope-vars">変数のscope</a>内部仕様参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
storage
    </th>
    <td>
<span id="span-out-storage"></span>
storageについて記述する
<br>
<br>
storageは<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を別々に保存するobjectで次の3種類
<br>
・local storage
<br>
・global storage
<br>
・local buffer
<br>
<br>
local storage
<br>
・演算実行確定1回の各実行文の<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を保存する
<br>
・保存された変数をlocal変数と呼ぶ
<br>
・保存された式変数をlocal式変数と呼ぶ
<br>
<br>
global storage
<br>
・演算実行確定1回毎に返る<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を累積保存する
<br>
・保存された変数をglobal変数と呼ぶ
<br>
・保存された式変数をglobal式変数と呼ぶ
<br>
<br>
local buffer
<br>
・local storageを一時的に記憶する
<br>
<br>
演算実行確定1回のstorageのflowを示す
<br>
・演算実行開始　global storage　⇒　local storageに復帰
<br>
・演算実行途中　local storageのread-write　⇔　local buffer
<br>
・演算実行終了　local storage　⇒　global storageに保存
<br>
<br>
<a href="#span-out-bracket">scope</a>との関係について記述する
<br>
・local storageを<a href="#span-in-scope-vars">static scopes2d array</a>の<a href="#span-out-bracket">0階層</a>に割当てる
<br>
・演算実行確定1回毎にlocal storageを除くscope内の<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は破棄する
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-re-use">scope付式変数の再利用</a>に対応
<br>
・global storage　⇒　local storageのflowで<a href="#span-out-eqns">式変数</a>の復帰時、
<br>
　新規に作る<a href="#span-in-scope-vars">scopes2d array ids</a>から<a href="#span-in-scope-vars">self-children ids</a>を更新
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
階層とscope
<br>
の関係
    </th>
    <td>
<span id="span-out-bracket"></span>
階層とscopeの関係について記述する
<br>
<br>
<a href="#span-out-bracket">parse</a>段階で<a href="#span-out-BT">括弧</a>のnestingによる構文を解析し、深さ方向に<a href="#span-in-tree">tree構造</a>を階層化する
<br>
・深さ0の0階層にlocal <a href="#span-out-storage">storage</a>を統合・共通化する（<a href="#span-out-command">命令文</a>を含む）
<br>
・既定で<a href="#span-out-BT-square">角括弧[]</a>のみ<a href="#span-out-scope-vars">変数のscope</a>を使用する
<br>
・0階層を除く階層は実行文毎に独立する
<br>
・以上より、階層の概念を次に示す
<br>
実行文A[,];
<br>
実行文B[,[],[],[,[,[,]]]]; ->
<br>
0階層[A-1階層,];
<br>
0階層[B-1階層,[B-2階層並列1],[B-2階層並列2],[B-2階層並列3,[B-3階層直列,[B-4階層直列,]]]];
<br>
<br>
定義を列挙する
<br>
・階層毎に並列に並んだ<a href="#span-out-scope-vars">scope</a>は互いに独立で、並列scopeと定義する
<br>
・階層の深さ方向に直列に並んだ<a href="#span-out-scope-vars">scope</a>を直列scopeと定義する
<br>
・自身の階層の深さ以下の直列scopeは参照可能で、直列scope内と定義する
<br>
・それ以外の参照できない<a href="#span-out-scope-vars">scope</a>を直列scope外と定義する
<br>
・同じ階層の並列scopeは直列scope外に含む
<br>
・よって0階層のlocal <a href="#span-out-storage">storage</a>はすべての<a href="#span-out-scope-vars">scope</a>の直列scope内で共通化される
<br>
・以上より、<a href="#span-out-bracket">parse</a>段階で作る<a href="#span-out-scope-vars">scope</a>の配列を<a href="#span-in-scope-vars">static scopes2d array</a>と定義する
<br>
<br>
直列scope内の<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>のsearch-precedenceの一例を示す
<br>
・上記B-2階層並列1の場合、次の論理ORを短絡評価
<br>
B-2階層並列1 || B-1階層 || 0階層
<br>
・上記B-3階層直列の場合、次の論理ORを短絡評価
<br>
B-3階層直列 || B-2階層並列3 || B-1階層 || 0階層
<br>
・上記B-4階層直列の場合、次の論理ORを短絡評価
<br>
B-4階層直列 || B-3階層直列 || B-2階層並列3 || B-1階層 || 0階層
<br>
・よって直列scope内の<a href="#span-out-bracket">階層</a>の深さの降順で0階層のlocal <a href="#span-out-storage">storage</a>が最下位のprecedence
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数の
<br>
arguments
    </th>
    <td>
<span id="span-out-eqns-args"></span>
式変数のargumentsについて記述する
<br>
<br>
<a href="#span-out-eqns">式変数</a>のargumentsは次の関数定義と関数callを代替する
<br>
let add=(a,b)=&gt;a+b; add(1,2)  <span class="selection">// ES6</span> -> 3
<br>
clear; add(a,b)=&lt;a+b; add(1,2)=&gt; || add(1,2) -> 3
<br>
・以降、<a href="#span-out-eqns">式変数</a>の定義元に対してcall先と区別する
<br>
<br>
<a href="#span-out-mat">行列</a>の値渡しの場合、<a href="#span-out-call-by-equation">式渡し</a>を使用
<br>
clear; add(A,B)=&lt;A+B; add((1,2:3,4),(5,6:7,8)) -> [MyErr]Invalid args.length=2(add)
<br>
clear; add(A,B)=&lt;A+B; add(=&lt;(1,2:3,4),=&lt;(5,6:7,8))=&gt; -> (6,8:10,12)
<br>
clear; add(A,B)=&lt;A+B; add(=&lt;(1,2:3,4),=&lt;(5,6:7,8)) -> (6,8:10,12)
<br>
<br>
call先argumentsに<a href="#span-out-vars-symbol">変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>する場合（以降、symbol渡しと呼ぶ）
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
clear; add(A,B)=&lt;A+B;
<br>
A=(1,2:3,4); B=(5,6:7,8); add(A,B)=&gt; -> [MyErr]Invalid args.length=2(add)
<br>
clear; add(A,B)=&lt;A+B;
<br>
A=(1,2:3,4); B=(5,6:7,8); add(=&lt;A,=&lt;B)=&gt; || add(=&lt;A,=&lt;B) -> (6,8:10,12)
<br>
・<a href="#span-out-eqns">式変数</a>を使用
<br>
clear; add(A,B)=&lt;A+B;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;A,=&lt;B)=&gt; -> (6,8:10,12)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_=&gt;+B_=&gt;;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;A,=&lt;B)=&gt; -> (6,8:10,12)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_+B_;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;A,=&lt;B)=&gt; -> (6,8:10,12)
<br>
<br>
<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>の<a href="#span-out-call-by-equation">式渡し</a>の場合
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_+B_;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;A=&gt;,=&lt;B=&gt;)=&gt; -> (6,8:10,12)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_+B_;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;A=&gt;+A=&gt;,=&lt;B=&gt;+B=&gt;)=&gt; -> (12,16:20,24)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_+B_;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;{A=&gt;+A=&gt;},=&lt;(B=&gt;+B=&gt;))=&gt; -> (12,16:20,24)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;A_+B_;
<br>
A=&lt;(1,2:3,4); B=&lt;(5,6:7,8); add(=&lt;[A=&gt;+A=&gt;],=&lt;[B=&gt;+B=&gt;])=&gt; -> (12,16:20,24)
<br>
<br>
定義元argumentsの<a href="#span-out-vars-symbol">式変数名symbol</a>をunderscoreでescapeする理由を列挙する
<br>
・symbol渡しで<a href="#span-out-eqns">式変数</a>Bの中身をcallする場合、問題なし
<br>
clear; add(A,=&lt;B)=&lt;A+B=&gt;; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
・定義元から<a href="#span-out-eqns">式変数</a>Bをcallする場合、<a href="#span-out-vars-symbol">式変数名symbol</a>の循環参照（B=&gt;B=&gt;）と判別される
<br>
clear; add(A,=&lt;B)=&lt;A+B=&gt;; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;) -> [MyErr]Invalid circular(B)
<br>
・参照上の問題はないため、定義元argumentsの<a href="#span-out-vars-symbol">式変数名symbol</a>をescapeする
<br>
clear; add(A,=&lt;B_)=&lt;A+B_=&gt;; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;) -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;A+B_=&gt;; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
・以降、escape文字は後置のunderscoreで統一する
<br>
clear; add(A,=&lt;B_)=&lt;(A+B_=&gt;); B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;) -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;(A+B_=&gt;); B=&lt;(3,4); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;[A+B_=&gt;]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;) -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;[A+B_=&gt;]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
・定義元argumentsが<a href="#span-out-call-by-equation">式渡し</a>の場合、<a href="#span-out-vars-symbol">式変数名symbol</a>のみ判別する
<br>
clear; add(A,=&lt;B_)=&lt;[A+B_=&gt;]; B=&lt;(3,4); B=(,); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
・定義元argumentsが値渡しの場合、<a href="#span-out-vars-symbol">変数名symbol</a>を優先する
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B) -> (4,6)
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); B=(,); add(=&lt;(1,2),=&lt;B) -> (1,2)
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); B=(,); add(=&lt;(1,2),=&lt;B=&gt;) -> (4,6)
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合、<a href="#span-out-vars-symbol">変数名symbol</a>を厳格に判別する
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B)=&gt; -> [MyErr]Invalid matrix operation
<br>
clear; add(A,B)=&lt;[A]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B)=&gt; -> (1,2)
<br>
clear; add(A,B)=&lt;[B]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B)=&gt; -> [MyErr]Invalid REv(B)
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); B=(,); add(=&lt;(1,2),=&lt;B)=&gt; -> (1,2)
<br>
clear; add(A,B)=&lt;[A+B]; B=&lt;(3,4); B=(,); add(=&lt;(1,2),=&lt;B=&gt;)=&gt; -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;(A+B_=&gt;); B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;)=&gt; -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;(A+B_=&gt;); B=&lt;(3,4); add(=&lt;(1,2),=&lt;B)=&gt; -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;[A+B_=&gt;]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B=&gt;)=&gt; -> (4,6)
<br>
clear; add(A,=&lt;B_)=&lt;[A+B_=&gt;]; B=&lt;(3,4); add(=&lt;(1,2),=&lt;B)=&gt; -> (4,6)
<br>
<br>
symbol渡しの場合、定義元<a href="#span-out-bracket">scope</a>に留意が不要（別<a href="#span-out-bracket">scope</a>を参照するcaseを除く）
<br>
・次の場合、<a href="#span-out-eqns">式変数</a>Bの中身(a,4)を定義元の<a href="#span-out-eqns">式変数</a>B_に継承する
<br>
clear; add(A,=&lt;B_)=&lt;(a=-1,=&lt;A+B_=&gt;)=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;B)=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;(a=-1,=&lt;A+B_=&gt;)=&gt;; a=1; add(=&lt;(1,2),=&lt;(a,4))=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;B)=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; a=1; add(=&lt;(1,2),=&lt;(a,4))=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; a=1; add(=&lt;(1,2),=&lt;{=&lt;(a,4)}=&gt;)=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; a=1; add(=&lt;(1,2),=&lt;{=&lt;(a,4)}=&gt;)=&gt; -> (0,6)
<br>
・<a href="#span-out-vars-symbol">変数名symbol</a>を<a href="#span-out-BT">括弧</a>で括った場合、<a href="#span-out-call-by-equation">式渡し</a>と判別される
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;(B))=&gt; -> (2,6)
<br>
・<a href="#span-out-FNh">高階関数</a>のsymbolのみを渡す引数と異なる
<br>
<br>
<a href="#span-out-call-by-equation">式渡し</a>の場合、定義元<a href="#span-out-bracket">scope</a>に留意が必要
<br>
・次の場合、B=&gt;を定義元の<a href="#span-out-eqns">式変数</a>B_に継承する
<br>
clear; add(A,=&lt;B_)=&lt;(a=-1,=&lt;A+B_=&gt;)=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;B=&gt;)=&gt; -> (0,6)
<br>
clear; add(A,=&lt;B_)=&lt;(a=-1,=&lt;A+B_=&gt;)=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;[B=&gt;])=&gt; -> (0,6)
<br>
・以上の場合、定義元<a href="#span-out-bracket">scope</a>とlocal <a href="#span-out-storage">storage</a>が共通で<a href="#span-out-eqns">式変数</a>Bをcallする
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;B=&gt;)=&gt; -> (2,6)
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;[B=&gt;])=&gt; -> (2,6)
<br>
・以上の場合、定義元<a href="#span-out-bracket">scope</a>から参照可能なlocal <a href="#span-out-storage">storage</a>に定義された<a href="#span-out-eqns">式変数</a>Bをcallする
<br>
・よって定義元<a href="#span-out-bracket">scope</a>を<a href="#span-out-eqns">式変数</a>Bに継承する場合、<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>をnestingする
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_==&gt;]=&gt;; B=&lt;(a,4); a=1; add(=&lt;(1,2),=&lt;(B==&gt;))=&gt; -> (0,6)
<br>
・独立scopeに<a href="#span-out-eqns">式変数</a>Bが定義された場合、定義元<a href="#span-out-bracket">scope</a>から参照不可
<br>
clear; add(A,=&lt;B_)=&lt;[a=-1,=&lt;A+B_=&gt;]=&gt;;
<br>
[B=&lt;(a,4),a=1,add(=&lt;(1,2),=&lt;B=&gt;)=&gt;] -> [MyErr]Invalid REv(B)
<br>
<br>
<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>を代替する一例を次に示す
<br>
clear; a=&lt;b+c+d; d=3; [c=2,=&lt;[b=1,=&lt;a==&gt;]=&gt;]=&gt; -> 6
<br>
clear; a()=&lt;b+c+d; d=3; [c=2,=&lt;[b=1,=&lt;a()==&gt;]=&gt;]=&gt; -> 6
<br>
clear; a(b,c,d)=&lt;b+c+d; d=3; [c=2,=&lt;[b=1,=&lt;a(b,c,d)]=&gt;]=&gt;  <span class="selection">// better</span> -> 6
<br>
clear; a(b,c,d)=&lt;b+c+d; d=3; [c=2,=&lt;[b=1,=&lt;a(b,c,d)=&gt;]=&gt;]=&gt;  <span class="selection">// better</span> -> 6
<br>
・定義元argumentsの<a href="#span-out-vars-symbol">変数名symbol</a>は独立として<a href="#span-in-scope-vars">static scopes2d array</a>を共有する
<br>
clear; a(b,c,d)=&lt;last{b=-1,b+c+d}; d=3; [c=2,=&lt;[b=1,=&lt;[a(b,c,d),b]]=&gt;]=&gt; -> (4,1)
<br>
clear; a(b,c,d)=&lt;last{b=-1,b+c+d}; d=3; [c=2,=&lt;[=&lt;[a(b,c,d),b]]=&gt;]=&gt; -> [MyErr]Invalid REv(b)
<br>
・通常callの場合、定義元で宣言される<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は定義元<a href="#span-out-bracket">scope</a>に定義する
<br>
clear; a(b_,c,d)=&lt;last{b=b_,b_+c+d}; d=3; [c=2,=&lt;[=&lt;[a(1,c,d),b]]=&gt;]=&gt;,b -> (6,1,1)
<br>
clear; a(b_,c,d)=&lt;last{b=&lt;1,b_+c+d}; d=3; [c=2,=&lt;[=&lt;[a(1,c,d),b=&gt;]]=&gt;]=&gt;,b=&gt; -> (6,1,1)
<br>
clear; a(b_,c,d)=&lt;last{b=b_,b_+c+d}; d=3; [c=2,=&lt;[=&lt;[a(1,c,d),b_]]=&gt;]=&gt;
<br>
-> [MyErr]Invalid REv(b_)
<br>
<br>
以上のtestcaseを列挙する
<br>
clear; add(a,b)=&lt;last{a=-1,a+b}; add(last{a=1,a},2)=&gt;,a -> (1,1)
<br>
clear; add(a_,b)=&lt;last{a=-1,a_+b}; add(last{a=1,a},2)=&gt;,a -> (3,-1)
<br>
clear; add(a_,b)=&lt;last{a=-1,a_+b}; add(last{a=1,a},2)=&gt;,a_ -> [MyErr]Invalid REv(a_)
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-re-use">scope付式変数の再利用</a>に対応
<br>
clear; add(a_,b)=&lt;last[a=-1,a_+b]; add(last{a=1,a},2)=&gt;,a -> (3,1)
<br>
clear; add(a_,b)=&lt;last[a=-1,a_+b]; add(last[a=1,a],2)=&gt;,a -> [MyErr]Invalid REv(a)
<br>
clear; add(a_,b)=&lt;last(a=-1,a_+b); add(last[a=1,a],2)=&gt;,a -> (3,-1)
<br>
clear; conv(=&lt;a)=&lt;last{a=&lt;-1,a=&gt;}; conv(=&lt;last{a=&lt;1,a=&gt;})=&gt; -> -1
<br>
clear; conv(=&lt;a)=&lt;last{a=&lt;-1,a=&gt;}; conv(=&lt;last{a=&lt;1,a=&gt;})=&gt;; a=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; conv(=&lt;a_)=&lt;last{a=&lt;-1,a_=&gt;}; conv(=&lt;last{a=&lt;1,a=&gt;})=&gt;,a=&gt; -> (1,1)
<br>
clear; conv(=&lt;a_)=&lt;last{a=&lt;-1,a_=&gt;}; conv(=&lt;last{a=&gt;})=&gt;,a=&gt; -> (-1,-1)
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]; conv(=&lt;last{a=&gt;})=&gt; -> -1
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_==&gt;]; conv(=&lt;last{a=&gt;})=&gt; -> -1
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]*2; conv(=&lt;last{a=&gt;})=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_==&gt;]*2; conv(=&lt;last{a=&gt;})=&gt; -> -2
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_==&gt;]; conv(=&lt;last[a=&gt;])=&gt; -> [MyErr]Invalid FNm(last)
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_==&gt;]; conv(=&lt;last[,a=&gt;])=&gt; -> -1
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]; conv(=&lt;last[,a=&gt;])=&gt; -> -1
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]; conv(=&lt;last[a=&lt;1,a=&gt;])=&gt; -> 1
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]*2; conv(=&lt;last[,a=&gt;])=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_==&gt;]*2; conv(=&lt;last[,a=&gt;])=&gt; -> -2
<br>
clear; conv(=&lt;a_)=&lt;last[a=&lt;-1,a_=&gt;]*2; conv(=&lt;last[a=&lt;1,a=&gt;])=&gt; -> 2
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-call">式読出し</a>記号=&gt;省略時同様に
<br>
clear; add(A,B)=&lt;A+B; add[0](=&lt;(1,2:3,4),=&lt;(5,6:7,8)) || (6,8:10,12)[0] -> (6,8)
<br>
・<a href="#span-out-BT-square">角括弧[]</a>で<a href="#span-out-eqns">式変数</a>の返値の<a href="#span-out-mat">行列</a>要素を参照可
<br>
clear; add(A,B)=&lt;A+B; add[0](=&lt;(1,2:3,4),=&lt;(5,6:7,8))=&gt; -> (6,8)
<br>
clear; add(A,B)=&lt;A+B; add[1](=&lt;(1,2:3,4),=&lt;(5,6:7,8))=&gt; -> (10,12)
<br>
clear; add(A,B)=&lt;A+B; add[0][0](=&lt;(1,2:3,4),=&lt;(5,6:7,8))=&gt; -> 6
<br>
clear; add(A,B)=&lt;A+B; add[1][1](=&lt;(1,2:3,4),=&lt;(5,6:7,8))=&gt; -> 12
<br>
<br>
call先arguments省略の場合、定義元argumentsを無視してcall可（<span class="clear">Ver.2.43.22</span>追記）
<br>
clear; x(t)=&lt;-t; f=&lt;x+1; f -> [MyErr]Invalid null args(x)
<br>
clear; x(t)=&lt;-t; f=&lt;x=&gt;+1; f -> [MyErr]Invalid binary operation
<br>
clear; x(t)=&lt;-t; t=-999; f=&lt;x=&gt;+1; f -> 1000
<br>
clear; x(t)=&lt;-t; t=-999; [t=1,f=&lt;x=&gt;+1,f] -> (0,0,1000)
<br>
clear; x(t)=&lt;-t; t=-999; [t=1,f=&lt;x==&gt;+1,f] -> (0,0,0)
<br>
clear; x(t)=&lt;-t; t=-999; [t=1,f=&lt;x(t)==&gt;+1,f] -> (0,0,0)
<br>
clear; x(t)=&lt;-t; t=-999; [t=1,f=&lt;x(t)=&gt;+1,f] -> (0,0,0)
<br>
clear; x(t)=&lt;-t; t=-999; [t=1,f=&lt;x(t)+1,f] -> (0,0,0)
<br>
clear; x=&lt;-t; t=-999; [t=1,f=&lt;x+1,f] -> (0,0,1000)
<br>
clear; x=&lt;-t; t=-999; [t=1,f=&lt;x=&gt;+1,f] -> (0,0,1000)
<br>
clear; x=&lt;-t; t=-999; [t=1,f=&lt;x==&gt;+1,f] -> (0,0,0)
<br>
<br>
arguments不正の場合、error終了
<br>
・定義元argumentsに<a href="#span-out-FN">関数</a>を指定した場合、<a href="#span-out-vars-symbol">変数名symbol</a>とは判別されない
<br>
clear; a(max)=&lt;max*2; a(2)=&gt; -> [MyErr]Invalid args.length=0(a)
<br>
clear; a(max)=&lt;max*2; a()=&gt; || max*2 -> [MyErr]Invalid binary operation
<br>
clear; a(max)=&lt;2; a()=&gt; || a()=&lt;2; a()=&gt; || a=&lt;2; a=&gt; -> 2
<br>
・argumentsの<a href="#span-out-vars-symbol">変数名symbol</a>は<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
clear; a($b)=&lt;$b*2 -> [MyErr]Invalid REv($b)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
scope付
<br>
式変数の
<br>
再利用
    </th>
    <td>
<span id="span-out-eqns-re-use"></span>
scope付式変数の再利用について記述する
<br>
<br>
<a href="#span-out-scope-vars">変数のscope</a>付の<a href="#span-out-eqns">式変数</a>の一例を列挙する
<br>
・単独<a href="#span-out-bracket">scope</a>と判別されるcaseのみ、<a href="#span-out-eqns-args">定義元arguments</a>は<a href="#span-out-BT-square">角括弧[]</a>の<a href="#span-out-bracket">scope</a>内に定義する
<br>
clear; com2vec(a)=&lt;[{real(a),imag(a)}]; com2vec(2-3i) -> (2:-3)
<br>
clear; minus(a)=&lt;[,=&lt;-a]=&gt;; minus(2) -> -2
<br>
clear; add(a,b)=&lt;last[,a+b]; add(1,3) -> 4
<br>
・以下のような場合、<a href="#span-out-eqns-args">定義元arguments</a>は<a href="#span-out-BT-square">角括弧[]</a>の<a href="#span-out-bracket">scope</a>外に定義する
<br>
clear; com2vec_k(a,k)=&lt;[{real(a),imag(a)}]*k; com2vec_k(2-3i,i) -> (2i:-3i)
<br>
clear; minus_k(a,k)=&lt;[,=&lt;-a]=&gt;*k; minus_k(2,2) -> -4
<br>
clear; add_k(a,b,k)=&lt;last[,a+b]*k; add_k(1,3,2) -> 8
<br>
clear; iproduct(L,R)=&lt;[L]*[trans(R)]; iproduct(=&lt;(1,2),=&lt;(3,4)) -> 11
<br>
・<a href="#span-out-config-strict">Non-strict-mode</a>の場合
<br>
clear; iproduct(L,R)=&lt;[(L)][trans(R)]; iproduct(=&lt;(1,2),=&lt;(3,4)) -> 11
<br>
clear; iproduct(L,R)=&lt;[(L)](trans(R)); iproduct(=&lt;(1,2),=&lt;(3,4)) -> 11
<br>
clear; iproduct(L,R)=&lt;(L)[trans(R)]; iproduct(=&lt;(1,2),=&lt;(3,4)) -> 11
<br>
clear; iproduct(L,R)=&lt;(L)(trans(R)); iproduct(=&lt;(1,2),=&lt;(3,4)) -> 11
<br>
<br>
これらを再利用する一例を以下に示す
<br>
clear; add(a,b)=&lt;last[,a+b]; add(1,3) -> 4
<br>
add(1,-3),add(1,i) -> (-2,1+i)
<br>
・値を返す場合、nesting可
<br>
add(1,add(1,add(1,add(1,i)))) -> 4+i
<br>
add(1,add(2,add(3,add(4,i)))) -> 10+i
<br>
add(1,add(1,add(1,add(1,i))add(1,i))add(1,i))add(1,i) -> -5+5i
<br>
・同義
<br>
(1+(1+(1+(1+i)))) -> 4+i
<br>
(1+(2+(3+(4+i)))) -> 10+i
<br>
(1+(1+(1+(1+i))(1+i))(1+i))(1+i) -> -5+5i
<br>
<br>
<a href="#span-out-FNm-last">last行列関数</a>を代替する<a href="#span-out-eqns">式変数</a>last_ttを以下に示す
<br>
・<a href="#span-out-FNm-last">last行列関数</a>は<a href="#span-in-tree">単位tree構造</a>の仕様上、行vectorの抜け要素を自動で埋めない
<br>
・行vectorの抜け要素を自動で埋める<a href="#span-out-eqns">式変数</a>last_ttを次に定義する
<br>
clear; last_tt(A)=&lt;(trans(trans(A)))[sizer(A)-1][sizec(A)-1]; A=(1,2:3,4); last_tt(=&lt;A) -> 4
<br>
・<a href="#span-out-BT-square">行列要素参照の角括弧[]</a>も同様に、<a href="#span-out-bracket">scope</a>を持つ
<br>
A=(1,2:3,(,:,4),5); last(A) -> 4
<br>
A=(1,2:3,(,:,4),5); last(trans(trans(A))) -> 0
<br>
A=(1,2:3,last(,:,4),5); last(A) -> 5
<br>
A=(1,2:3,(,:,4),5); last_tt(=&lt;A) -> 0
<br>
A=(1,2:3,last_tt(=&lt;(,:,4)),5); last_tt(=&lt;A) -> 5
<br>
A4=(,:,4); A=(1,2:3,last_tt(=&lt;A4),5); last_tt(=&lt;A) -> 5
<br>
A4=(,:,4); A=(1,2:3,A4,5) ->
<br>
(
<br>
1,2:
<br>
3,0,0,5:
<br>
0,0,4
<br>
)
<br>
ttA=trans(trans(A)) ->
<br>
(
<br>
1,2,0,0:
<br>
3,0,0,5:
<br>
0,0,4,0
<br>
)
<br>
sizer(A)-sizer(ttA),sizer(A) -> (0,3)
<br>
sizec(A)-sizec(ttA),sizec(A),size(A) -> (0,4,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数の
<br>
scope
<br>
継承call
<br>
まとめ
    </th>
    <td>
<span id="span-out-scope-inherited-call-memo"></span>
式変数のscope継承callについてまとめる
<br>
<br>
<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>の仕様を列挙する
<br>
・<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は宣言時の<a href="#span-out-bracket">階層</a>に依存するため、次の場合、error終了
<br>
let a=()=&gt;b; (function(){let b=1; return a();})();  <span class="selection">// ES6</span> -> b is not defined
<br>
clear; a=&lt;b; [b=1,=&lt;a=&gt;]=&gt; -> [MyErr]Invalid REv(b)
<br>
・<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>を使用して<a href="#span-out-call-by-equation">式読出し</a>時の<a href="#span-out-bracket">階層</a>を継承する
<br>
clear; a=&lt;b; [b=1,=&lt;a==&gt;]=&gt; -> 1
<br>
・<a href="#span-out-eqns-args">式変数のarguments</a>を使用して<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>を代替する
<br>
clear; a(b)=&lt;b; [b=1,=&lt;a(b)=&gt;]=&gt;  <span class="selection">// better</span> -> 1
<br>
・<a href="#span-out-eqns">式変数</a>の定義元に対してcall先と区別する
<br>
・<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-vars-symbol">変数名symbol</a>は独立する
<br>
詳細は<a href="#span-out-development-problems-CBR">未実装の参照渡し</a>参照
<br>
clear; a(b)=&lt;last(b=-1,b); (b=1,a(b)=&gt;,b) -> (0,-1,1)
<br>
clear; a(B)=&lt;{B[0]=B[1],=&lt;B}=&gt;; B=(1,2:3,4); (B,a(=&lt;B)=&gt;,B) ->
<br>
(
<br>
1,2,3,4,1,2:
<br>
3,4,3,4,3,4
<br>
)
<br>
<br>
<span class="run">Ver.2.33.18</span>以降、<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-vars">変数</a>は宣言時の<a href="#span-out-bracket">階層</a>に依存する（<span class="run">Ver.2.70.28</span>追記）
<br>
・定義元とcall先の<a href="#span-out-bracket">scope</a>が同一の場合
<br>
　・<a href="#span-out-eqns-args">symbol渡し</a>の場合、定義元とcall先のAは同一
<br>
clear; add(A,B)=&lt;A+B; A=(1,2:3,4); add(=&lt;A,=&lt;A) -> (2,4:6,8)
<br>
　
<del>
・<a href="#span-out-call-by-equation">式渡し</a>の場合、A[1]のcall時、A=A[0]更新後のA=(1,2)を参照するため、error終了
<br>
clear; add(A,B)=&lt;A+B; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> [MyErr]Invalid reference of array
<br>
clear; add(A,B)=&lt;A+B; A=&lt;(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> [MyErr]Invalid reference of array
</del>
<br>
　・<span class="clear">Ver.2.71.29</span>以降、<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>の初期化algorithmを修正
<br>
clear; add(A,B)=&lt;A+B; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
clear; add(A,B)=&lt;A+B; A=&lt;(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
・<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-vars-symbol">変数名symbol</a>を区別する場合
<br>
clear; add(A_,B_)=&lt;A_+B_; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
clear; add(A_,B_)=&lt;A_+B_; A=&lt;(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
・<a href="#span-out-vars">変数</a>と<a href="#span-out-eqns">式変数</a>の<a href="#span-out-vars-symbol">変数名symbol</a>を区別する場合
<br>
clear; add(A,B)=&lt;A+B; A=&lt;(1,2:3,4); add(=&lt;A[0]=&gt;,=&lt;A[1]=&gt;) -> (4,6)
<br>
clear; add(=&lt;A,=&lt;B)=&lt;A=&gt;+B=&gt;; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
・定義元とcall先の<a href="#span-out-bracket">scope</a>を区別する場合
<br>
clear; add(A,B)=&lt;[A+B]; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
clear; add(A,B)=&lt;[A+B]; A=&lt;(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
clear; add(=&lt;A,=&lt;B)=&lt;[A=&gt;+B=&gt;]; A=(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
clear; add(=&lt;A_,=&lt;B_)=&lt;[A_=&gt;+B_=&gt;]; A=&lt;(1,2:3,4); add(=&lt;A[0],=&lt;A[1]) -> (4,6)
<br>
<br>
<span class="run">Ver.2.33.18</span>以降、<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-eqns">式変数</a>は宣言時の<a href="#span-out-bracket">階層</a>に依存する
<br>
・通常callの場合
<br>
clear; conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,conv(=&lt;a)=&gt;] -> [MyErr]Undef eqn(a)
<br>
clear; conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,a=&lt;a,conv(=&lt;a)=&gt;] -> [MyErr]Invalid REv(a)
<br>
clear; conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,conv(=&lt;(a))=&gt;] -> [MyErr]Invalid REv(a)
<br>
clear; [conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,conv(=&lt;(a))=&gt;]] -> [MyErr]Invalid REv(a)
<br>
・定義元で宣言される<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は定義元<a href="#span-out-bracket">scope</a>に定義する
<br>
clear; conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,a=&lt;a,conv(=&lt;a)=&gt;,a],a -> (0,0,0,-3,3,-3)
<br>
clear; conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))=&gt;,a],a -> (0,0,-3,3,-3)
<br>
clear; [conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))=&gt;,a],a] -> (0,0,-3,3,-3)
<br>
clear; [conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))=&gt;,a],a],a -> [MyErr]Invalid REv(a)
<br>
・<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>の場合
<br>
clear; conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,a=&lt;a,conv(=&lt;a)==&gt;,a] -> (0,0,0,3,3)
<br>
clear; conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a] -> (0,0,3,3)
<br>
clear; [conv(=&lt;a_)=&lt;last(a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a]] -> (0,0,3,3)
<br>
・定義元で宣言される<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>はcall先<a href="#span-out-bracket">scope</a>に定義する
<br>
clear; conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,a=&lt;a,conv(=&lt;a)==&gt;,a] -> (0,0,0,-3,-3)
<br>
clear; conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a] -> (0,0,-3,-3)
<br>
clear; [conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a]] -> (0,0,-3,-3)
<br>
clear; [conv(=&lt;a_)=&lt;last(a=-3,a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a],a] -> [MyErr]Invalid REv(a)
<br>
clear; [conv(=&lt;a_)=&lt;last(b=4,a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,b],b] -> [MyErr]Invalid REv(b)
<br>
clear; [conv(=&lt;a_)=&lt;last(b=4,a_=&gt;),[a=3,conv(=&lt;(a))==&gt;,a,b]] -> (0,0,3,3,4)
<br>
・定義元とcall先の<a href="#span-out-bracket">scope</a>を区別する場合
<br>
・定義元で宣言される<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>はcall先から参照不可
<br>
clear; [conv(=&lt;a_)=&lt;last[b=4,a_=&gt;],[a=3,conv(=&lt;(a))==&gt;,b]] -> [MyErr]Invalid REv(b)
<br>
clear; [conv(=&lt;a_)=&lt;last[b=&lt;4,a_=&gt;],[a=3,conv(=&lt;(a))==&gt;,b=&gt;]] -> [MyErr]Invalid REv(b)
<br>
clear; [conv(=&lt;a_)=&lt;last[b=4,a_=&gt;+b],[a=3,conv(=&lt;(a))==&gt;]] -> (0,0,7)
<br>
clear; [conv(=&lt;a_)=&lt;last[b=&lt;4,a_=&gt;+b=&gt;],[a=3,conv(=&lt;(a))==&gt;]] -> (0,0,7)
<br>
・symbol渡しで定義元<a href="#span-out-bracket">scope</a>を継承する場合
<br>
clear; conv(=&lt;a_)=&lt;(a=-1,=&lt;a+a_=&gt;)=&gt;*2; a=&lt;a; a=1; conv(=&lt;a)=&gt;,a -> (-4,-1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_=&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;a)=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_==&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;a)=&gt;,a -> (-4,1)
<br>
・symbol渡しを<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>で代替する場合、nestingが必要
<br>
clear; conv(=&lt;a_)=&lt;[=&lt;a+a_=&gt;]=&gt;*2; a=&lt;-a; a=1; conv(=&lt;a)=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[=&lt;a+a_=&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;(a=&gt;))=&gt;,a -> (4,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_=&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;(a=&gt;))=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_=&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;(a==&gt;))=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_==&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;(a=&gt;))=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_==&gt;]=&gt;*2; a=&lt;a; a=1; conv(=&lt;(a==&gt;))=&gt;,a -> (-4,1)
<br>
・単独<a href="#span-out-bracket">scope</a>と判別される場合、定義元のみ通常callに短縮可
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_==&gt;]=&gt;; a=&lt;a; a=1; conv(=&lt;(a==&gt;))=&gt;,a -> (-2,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_=&gt;]=&gt;; a=&lt;a; a=1; conv(=&lt;(a==&gt;))=&gt;,a -> (-2,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_==&gt;]=&gt;; a=&lt;a; a=1; conv(=&lt;(a=&gt;))=&gt;,a -> (0,1)
<br>
clear; conv(=&lt;a_)=&lt;[a=-1,=&lt;a+a_=&gt;]=&gt;; a=&lt;a; a=1; conv(=&lt;(a=&gt;))=&gt;,a -> (0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算flow
    </th>
    <td>
<span id="span-out-flow"></span>
演算実行確定1回の演算flowについて記述する
<br>
<br>
次の3関数による演算flowを示す
<br>
main関数　⇔　parse関数　⇔　operation関数
<br>
・main関数
<br>
　・入力dataを作ってparse関数に渡す
<br>
　・出力dataから演算結果を外部に表示する
<br>
・parse関数
<br>
　・入力dataから実行文を作ってoperation関数に渡す
<br>
　・演算結果から出力dataを作ってmain関数に返す
<br>
・operation関数
<br>
　・実行文から演算結果を作ってparse関数に返す
<br>
<br>
parse関数とoperation関数の役割分担を示す
<br>
<br>
parse関数の役割はcompiler
<br>
・<a href="#span-out-BT">括弧</a>のnestingによる構文を解析し、深さ方向に<a href="#span-in-tree">tree構造</a>を階層化する
<br>
・入力dataの字句を解析してtagを付ける
<br>
・逐次、入力dataを実行文のtreeに置換する
<br>
<br>
operation関数の役割はinterpreter
<br>
・<a href="#span-out-prec">演算のprecedence</a>に従って実行文を実行する
<br>
・逐次、実行文のtreeを演算結果のtreeに置換する
<br>
・再帰的に<a href="#span-in-tree">単位tree構造</a>に帰結する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
開発環境
    </th>
    <td>
<span id="span-out-development"></span>
さらに、JavaScriptのinterpreterを介してbrowser上で演算を実行する
<br>
・よってNativeに近い言語で直接記述するよりthroughputは圧倒的に低いが、
<br>
・以下のcross-platform開発とonline-test管理の容易さを選択
<br>
<br>
開発環境を列挙する
<br>
・Microsoft windows 10
<br>
・Google Chrome Developer Tools（以降、Chrome DevToolsと省略する）
<br>
・Apache HTTP Server
<br>
・GitHub Desktop
<br>
・GitHub Pages
<br>
commit E-mail addressを変更する場合（参考）
<br>
・Git Bash（first-commit前にgit config user.emailで設定を変更する）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
実装の特徴
    </th>
    <td>
<span id="span-out-development-additional"></span>
基本構文のみで最短かつ確実な実装を選択したため、platform以前に最適化の余地がある
<br>
また、すべての結果の確からしさは自己判断のため、致命的な見落としを残す可能性がある
<br>
<br>
実装の特徴を列挙する
<br>
・<a href="#span-out-vars">変数</a>のread-writeは<a href="#span-in-tree">tree構造</a>を複製して参照上の副作用を単純に回避する
<br>
・<a href="#span-out-eqns">式変数</a>のread-write||call時も同様
<br>
・<a href="#span-out-mat">行列</a>演算を含む<a href="#span-out-associativity">2項演算子のassociativity</a>は単なるfor-loopで結合順||演算順を保証する
<br>
・reccursive callを代替する<a href="#span-out-FNh-RX">再帰高階関数</a>も同様に、独自のcall stackを実装しない
<br>
・よって<a href="#span-out-FNh-DX">微分の多重化</a>等、<a href="#span-out-FNh">高階関数</a>をnestingする場合、致命的にthroughputが低下する
<br>
・<a href="#span-out-flow">parser</a>は複数種類の<a href="#span-out-BT">括弧</a>のnestingに対応し、再帰的に<a href="#span-in-tree">tree構造</a>を階層化する
<br>
・よって<a href="#span-out-bracket">階層</a>に紐付く<a href="#span-out-scope-vars">変数のscope</a>はstaticで再利用可能としたが、最善を追及していない
<br>
・<a href="#span-out-eqns-args">式変数のarguments</a>も同様に、最善の仕様を追及していない
<br>
・<a href="#span-out-FN">関数</a>を含む実装関数は最善のalgorithmとは限らない
<br>
・debug機能が存在しないため、<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>はpollution disabledの厳格な制約条件を課す
<br>
・よって<a href="#span-out-bracket">scope</a>本来の利便性を大きく損なうが、緩和の見通しはない
<br>
<br>
JavaScript特有の実装を列挙する
<br>
・namespaceの中に全objectを宣言してglobal searchを省略する（定量的な効果は不明）
<br>
・よって関数式のconstructorはhoistingなしの前提で実装する
<br>
・同制約の下、既存のframework||plug-inを一切使用しない
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
仕様上の
<br>
問題点
    </th>
    <td>
<span id="span-out-development-problems"></span>
仕様上の問題点を列挙する
<br>
・<a href="#span-out-development-problems-type">型定義の問題点</a>
<br>
・<a href="#span-out-development-problems-complex">複素数演算の問題点</a>
<br>
・<a href="#span-out-development-problems-CBR">未実装の参照渡し</a>
<br>
・<a href="#span-out-development-problems-CAS">未実装のCAS</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
型定義の
<br>
問題点
    </th>
    <td>
<span id="span-out-development-problems-type"></span>
型定義の問題点を列挙する
<br>
・2次元の<a href="#span-out-types">行列の型</a>||<a href="#span-in-tree">tree構造</a>を前提とする設計のため、<span class="clear">3次元以上の配列は定義不能</span>
<br>
・3次元以上の配列に相当する自由度は<a href="#span-out-vars-symbol">変数名symbol</a>で区別する
<br>
・3次元以上の配列に相当するfor-loopは展開して記述する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
複素数演算の
<br>
問題点
    </th>
    <td>
<span id="span-out-development-problems-complex"></span>
<a href="#span-out-com">複素数</a>演算の問題点を列挙する
<br>
・演算後に<a href="#span-out-epsilon">Machine epsilon</a>が残りやすく、整数を意識する負担がある
<br>
(-1)^0.5 || (-1)**0.5 || pow(-1,0.5) -> <span class="clear">6.123233995736766e-17</span>+i
<br>
2^3 || 2**3 || pow(2,3) -> <span class="clear">7.999999999999998</span>
<br>
・同時に、減算||加算で<a href="#span-out-error">情報落ち</a>が発生しやすく、警告文の判断が難しい
<br>
(-1)^0.5 || (-1)**0.5 || pow(-1,0.5) -> <span class="clear">6.123233995736766e-17</span>+i
<br>
ans+1 -> <span class="clear">infoLost[r ]</span> 1+i
<br>
・<a href="#span-out-ope">実数演算</a>の場合（参考）
<br>
(-1)^0.5 || (-1)**0.5 || pow(-1,0.5) -> [MyErr]FN isNaN
<br>
2^3 || 2**3 || pow(2,3) -> 8
<br>
・<a href="#span-out-UI-simple">UI設定</a>||<a href="#span-out-config">裏設定</a>以外で<a href="#span-out-ope">実数演算</a>に切替え不可（自動判別しない）
<br>
2^3 || 2**3 || pow(2,3) -> <span class="clear">7.999999999999998</span>
<br>
round(2^3) -> 8
<br>
vectorr(2^3) || vectorr(7)  <span class="selection">// NG</span> -> (0,0,0,0,0,0,0)
<br>
vectorr(round(2^3)) || vectorr(8)  <span class="selection">// OK</span> -> (0,0,0,0,0,0,0,0)
<br>
・整数演算の場合、<a href="#span-out-prec-ope">四則演算子</a>||<a href="#span-out-prec-ope-bit">bit shift演算子</a>を活用する
<br>
2*2*2 -> 8
<br>
2&lt;&lt;2 || 2*2*2 -> 8
<br>
1&lt;&lt;3 || 1*2*2*2 -> 8
<br>
8&gt;&gt;&gt;3 || 8&gt;&gt;3 || (((8/2)/2)/2) || 8/(2*2*2) -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
未実装の
<br>
参照渡し
    </th>
    <td>
<span id="span-out-development-problems-CBR"></span>
未実装の参照渡しについて留意事項を列挙する
<br>
・<a href="#span-out-eqns-args">定義元arguments</a>の<a href="#span-out-vars-symbol">変数名symbol</a>は独立する
<br>
clear; a(B)=&lt;{B[0]=B[1],=&lt;B}=&gt;; B=(1,2:3,4); (B,a(=&lt;B)=&gt;,B) ->
<br>
(
<br>
1,2,3,4,1,2:
<br>
3,4,3,4,3,4
<br>
)
<br>
clear; a(B)=&lt;[B[0]=B[1],=&lt;B]=&gt;; B=(1,2:3,4); (B,a(=&lt;B)=&gt;,B) ->
<br>
(
<br>
1,2,3,4,1,2:
<br>
3,4,3,4,3,4
<br>
)
<br>
・値渡し（参考）
<br>
clear; a(b)=&lt;last(b=-1,b); (b=1,a(b)=&gt;,b) -> (0,-1,1)
<br>
clear; a(b)=&lt;last[b=-1,b]; (b=1,a(b)=&gt;,b) -> (0,-1,1)
<br>
・<a href="#span-out-call-by-equation">式渡し</a>（参考）
<br>
clear; a(=&lt;b_)=&lt;last(b=-1,b_=&gt;); (b=1,a(=&lt;b)=&gt;,b) -> [MyErr]Undef eqn(b)
<br>
clear; a(=&lt;b_)=&lt;last(b=-1,b_=&gt;); (b=1,a(=&lt;{b})=&gt;,b) -> (0,-1,-1)
<br>
clear; a(=&lt;b_)=&lt;last(b=-1,b_=&gt;); (b=&lt;1,a(=&lt;b)=&gt;,b) -> (0,1,-1)
<br>
clear; a(=&lt;b_)=&lt;last(b=&lt;-1,b_=&gt;); (b=&lt;1,a(=&lt;b)=&gt;,b) -> (0,1,-1)
<br>
clear; a(=&lt;b_)=&lt;last[b=&lt;-1,b_=&gt;]; (b=&lt;1,a(=&lt;b)=&gt;,b) -> (0,1,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
未実装の
<br>
CAS
    </th>
    <td>
<span id="span-out-development-problems-CAS"></span>
未実装のCAS(Computer Algebra System)について留意事項を列挙する
<br>
・<a href="#span-out-application">application</a>のthroughputを優先するため、
<br>
・<a href="#span-out-FNh-DX">微分</a>・<a href="#span-out-FNh-IX">積分</a>の解析解が得られるcaseも<a href="#span-out-error-numerical">数値誤差</a>を許容する
<br>
・よって非線形性が強い<a href="#span-out-FN">関数</a>・<a href="#span-out-series">級数</a>・<a href="#span-out-limit">極限</a>の演算結果は当てにならない
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
動作test環境
    </th>
    <td>
<span id="span-out-system"></span>
browserの動作test環境について記述する
<br>
<br>
localhost offline/online-test環境
<br>
・latest Chrome
<br>
・latest Edge
<br>
・Internet Explorer 11（以降、IEと省略する）
<br>
・<span class="run">Ver.2.38.18</span>以降、latest Firefox
<br>
・その他、Chrome DevTools-emulatorで動作確認
<br>
<br>
実機online-test環境
<br>
・latest Amazon Silk
<br>
・<span class="run">Ver.2.37.18</span>以降、latest Chrome
<br>
・<span class="run">Ver.2.38.18</span>以降、latest Firefox
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
実機
<br>
online-test
<br>
手順
    </th>
    <td>
<span id="span-out-system-test"></span>
実機mobile端末のonline-test手順について記述する
<br>
<br>
<span class="run">Ver.2.37.18</span>以降、実機online-testのcommit前実施に対応
<br>
・GitHub Pages上で実施していた実機testの大半を以下の手順でcommit前に実施する
<br>
・さらに、今後の<a href="#span-out-application">application</a>開発で必要な実機online-testのdebug環境を整備する
<br>
<br>
実機online-testのcommit前実施準備を以下に示す
<br>
・localhost Apache HTTP ServerのDocumentRootのaccess制限を設定する
<br>
　Require all denied
<br>
　Require ip 192.168.
<br>
・localhost Apache HTTP Serverを再起動して設定変更を反映する
<br>
<br>
実機online-testのcommit前実施手順を以下に示す
<br>
・localhostのWi-Fi接続先propertyのnetwork profileを確認する
<br>
・localhost Firewallの設定でApache HTTP Serverのprivate||publicを許可する
<br>
・localhostと実機を同一のWi-Fiに接続する
<br>
・localhost IPv4 addressを確認する
<br>
・実機browserのURLにlocalhost IPv4 addressを入力して更新する
<br>
・localhost Apache HTTP ServerのDocumentRootからの相対pathでtestするpageを開く
<br>
・以上より、Wi-Fiを介して実機online-testを実施する
<br>
・test終了後、必要に応じてlocalhost Firewallの設定を元に戻す
<br>
<br>
さらに、localhost Chrome DevToolsでAndroid端末を操作してdebugする手順を以下に示す
<br>
・Android端末のBuild numberを7回tapしてDeveloper optionsを表示する
<br>
・System-Advanced-Developer optionsを開く
<br>
・USB debuggingを有効化する
<br>
・Android端末をlocalhostにUSB接続してUSB debugging connectedを確認する
<br>
・localhost ChromeのURLにchrome://inspect/#devicesを入力して更新する
<br>
・Android端末に表示されるcomputer's RSA keyによる接続を許可する
<br>
・先述の実施手順に従ってAndroid端末Chromeでlocalhostのdebugするpageを開く
<br>
・localhost Chromeに戻ってAndroid端末情報を確認する
<br>
・debugするpage URLのinspectを実行して新しいwindowを開く
<br>
・Chromeの同一page上でlocalhostとAndroid端末の操作が連動することを確認する
<br>
・以上より、Wi-Fiを介して実機online-testとともにdebugを実施する
<br>
・test終了後、必要に応じてAndroid端末の設定を元に戻す
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
動作要件
    </th>
    <td>
<span id="span-out-requirements"></span>
browserの動作要件を列挙する
<br>
・ECMAScript5対応
<br>
・HTML5対応
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
browser間
<br>
の相違
    </th>
    <td>
<span id="span-out-browsers"></span>
browser間の相違について記述する
<br>
<br>
png||svg出力の相違について記述する
<br>
・browserによってtext幅のNative測定値が異なる
<br>
　var text = "x=t,x;x";
<br>
　ctx.font = "10px sans-serif";
<br>
　var w = ctx.measureText(text).width;
<br>
IE: w -> 29
<br>
Edge/Chrome: w -> 36.2841796875
<br>
Firefox: w -> 30
<br>
　ctx.font = "12px sans-serif";
<br>
　var w = ctx.measureText(text).width;
<br>
IE: w -> 35
<br>
Edge/Chrome: w -> 43.541015625
<br>
Firefox: w -> 31
<br>
・Edge/Chromeはpngとsvgの出力表示が一致するが、IE/Firefoxは一致しない
<br>
　JavaScript engineの系統による違いと推察されるが、規則性が不明で対応未定
<br>
・textを除けばbrowser間の出力表示に大差なし
<br>
<br>
演算結果の相違について記述する
<br>
・browser間で<a href="#span-out-epsilon">Machine epsilon</a>程度の相違がある
<br>
IE: sin(5) -> -0.9589242746631384
<br>
Edge/Chrome/Firefox: sin(5) -> -0.9589242746631385
<br>
IE/Edge/Chrome: exp(i) -> 0.5403023058681398+0.8414709848078965i
<br>
Firefox: exp(i) -> 0.5403023058681397+0.8414709848078965i
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Internet
<br>
Explorer
<br>
非対応の機能
    </th>
    <td>
<span id="span-out-browsers-ie"></span>
IE非対応の機能について記述する
<br>
<br>
IE非対応の機能/原因を列挙する
<br>
・<a href="#span-out-UI-graphing-config">bg-image-file</a>
<br>
　描画更新時、SCRIPT5022: SecurityError
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
出力仕様
    </th>
    <td>
<span id="span-out-plot2d"></span>
Graphing Calculator's plot2dの出力仕様について記述する
<br>
<br>
plot2dの演算は高速化のため、<a href="#span-out-error">誤差</a>を評価しない・logを作らない
<br>
・<a href="#span-out-error">誤差</a>を含めたlogを作る場合、別途、通常の演算が必要
<br>
<br>
csv/history-txt出力のplot2d-command-logとplot2d-options-logについて記述する
<br>
・整合性保証のため、plot2dの演算実行確定時のlogを表示する
<br>
・よって演算終了後に変更した現在のzをlogに残す場合、再演算が必要
<br>
<br>
semi-colon;区切りで行列の<a href="#span-out-FNm-last">最終要素</a>の数値をgraphに描画する
<br>
・命令文や代入文のみを各軸に入力した場合、0を返して描画する
<br>
・処理を列挙する場合、最終列挙の要素が<a href="#span-out-FNm-last">最終要素</a>とは限らない点、留意が必要
<br>
詳細は<a href="#span-out-FNm-last">last行列関数</a>参照
<br>
<br>
tの範囲下限t0と範囲上限t1のlocal <a href="#span-out-storage">storage</a>は独立
<br>
・global <a href="#span-out-storage">storage</a>をreadonlyで共有する場合、shared storage checked
<br>
<br>
x軸とy軸のlocal <a href="#span-out-storage">storage</a>はx軸優先で共通
<br>
・global <a href="#span-out-storage">storage</a>をreadonlyで共有する場合、shared storage checked
<br>
<br>
t0/t1の演算を実行後、x/yの演算を実行
<br>
・t0/t1の演算はSingle-thread実行で中断不可
<br>
・x/yの演算は<a href="#span-out-option3">Multi-thread実行</a>を選択可
<br>
<br>
svg出力機能について記述する
<br>
・<a href="#span-out-UI-graphing-post1">canvas-globalCompositeOperation</a>無効（source-over）
<br>
・既定markerのdestination-outは背景色source-overで代替（透明の場合、白）
<br>
・canvas描画処理の継承互換性のため、group化等による最適化はしない
<br>
・<a href="#span-out-UI-graphing-z">z入力欄</a>から入力不可のsemi-colon;等の特殊文字を直接file編集可
<br>
・その他、font-family等も直接file編集可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
-command
<br>
入力仕様
    </th>
    <td>
<span id="span-out-plot2d-command"></span>
Graphing Calculator's plot2d-commandの入力仕様について記述する
<br>
<br>
以下2種類のplot2d-commandは操作panel中段のtext入力欄から実行する
<br>
plot2d('t0','t1','xt','yt')
<br>
plot2d(xt,yt)
<br>
・plot2d-command最優先で他の実行文は破棄other sentences ignored
<br>
・plot-button実行中の割込み不可
<br>
<br>
csv/history-txtに記録されるlogからplot2d-commandを実行する場合
<br>
・plot2d-from-logのformatを次に示す
<br>
plot2d('t0','t1','xt','yt')
<br>
plot2d('t0','t1','xt','yt','N')
<br>
plot2d('t0','t1','xt','yt','N','z')
<br>
・<span class="run">Ver.2.25.12</span>以降、第5引数Nにsingle quotation markを付与
<br>
・<span class="run">Ver.2.27.14</span>以降、第6引数z&amp;<a href="#span-out-comment">comment文</a>入力に対応
<br>
・plot2d-commandの一例を示す
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;')
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;','50')
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;','50','circle')
<br>
・N入力値はselect値が存在するcaseのみ有効
<br>
・<a href="#span-out-comment">comment文</a>入力の一例を示す
<br>
・tokenを区切るsingle quotation markは使用不可
<br>
plot2d(
<br>
'1e-3(1+i)<span class="selection">/*t0*/</span>','1e2(1+i)<span class="selection">/*t1*/</span>',
<br>
'x=t,x<span class="selection">/*xt*/</span>;','x;2x;3x;4x;5x;6x;7x;8x;9x;10x<span class="selection">/*yt*/</span>;',
<br>
'10',
<br>
'circle<span class="selection">/*marker*/</span>;'
<br>
)
<br>
<br>
時系列dataからplot2d-commandを実行する場合
<br>
・plot2d-from-arrのformatを次に示す
<br>
plot2d
<br>
(
<br>
x(t)<a href="#span-out-vars-symbol">変数名symbol</a>,
<br>
y(t)<a href="#span-out-vars-symbol">変数名symbol</a>
<br>
)
<br>
・xt,ytの場合
<br>
plot2d(xt,yt)
<br>
・circleを描く時系列data作成の一例を示す
<br>
・<a href="#span-out-eqns">式変数</a>の<a href="#span-out-eqns-call">式読出し</a>記号=&gt;を省略する場合、変数名の重複に留意する
<br>
storage cleared
<br>
t0=0;
<br>
t1=2pi;
<br>
tn=&lt;t0+(t1-t0)n/N;
<br>
N=10;
<br>
/*init=&lt;last{xt=zeros(N+1,1),yt=zeros(N+1,1)};*/
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
stepn=&lt;last{xt[n]=cos(tn),yt[n]=sin(tn)};
<br>
evolutionN=&lt;_sn(=&lt;stepn,0,N);
<br>
init; evolutionN; xt,yt ->
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合
<br>
storage cleared
<br>
t0=0;
<br>
t1=2*pi;
<br>
tn=&lt;t0+(t1-t0)*n/N;
<br>
N=10;
<br>
/*init=&lt;last{xt=zeros(N+1,1),yt=zeros(N+1,1)};*/
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
stepn=&lt;last{xt[n]=cos(tn=&gt;tn),yt[n]=sin(tn)};
<br>
/*evolutionN=&lt;_sn(=&lt;{stepn=&gt;},0,N);*/
<br>
evolutionN=&lt;_sn(=&lt;stepn,0,N);
<br>
init=&gt;; evolutionN=&gt;; xt,yt ->
<br>
(
<br>
1,0:
<br>
0.8090169943749475,0.5877852522924731:
<br>
0.30901699437494745,0.9510565162951535:
<br>
-0.3090169943749471,0.9510565162951536:
<br>
-0.8090169943749473,0.5877852522924732:
<br>
-1,1.2246467991473532e-16:
<br>
-0.8090169943749478,-0.5877852522924727:
<br>
-0.30901699437494756,-0.9510565162951535:
<br>
0.30901699437494723,-0.9510565162951536:
<br>
0.8090169943749473,-0.5877852522924734:
<br>
1,-2.4492935982947064e-16
<br>
)
<br>
<br>
複数の時系列dataを作成してplot2d-commandを実行する一例を以下に示す
<br>
・上記xt,ytの元dataを結合して作る場合
<br>
xt4=(xt*0,xt*1,xt*2,xt*3); yt4=(yt*0,yt*1,yt*2,yt*3);
<br>
plot2d(xt4,yt4)
<br>
・同義
<br>
xt4=xt*(0,1,2,3); xt4 ->
<br>
(
<br>
0,1,2,3:
<br>
0,0.8090169943749475,1.618033988749895,2.4270509831248424:
<br>
0,0.30901699437494745,0.6180339887498949,0.9270509831248424:
<br>
0,-0.3090169943749471,-0.6180339887498942,-0.9270509831248414:
<br>
0,-0.8090169943749473,-1.6180339887498947,-2.427050983124842:
<br>
0,-1,-2,-3:
<br>
0,-0.8090169943749478,-1.6180339887498956,-2.4270509831248432:
<br>
0,-0.30901699437494756,-0.6180339887498951,-0.9270509831248427:
<br>
0,0.30901699437494723,0.6180339887498945,0.9270509831248417:
<br>
0,0.8090169943749473,1.6180339887498947,2.427050983124842:
<br>
0,1,2,3
<br>
)
<br>
yt4=yt*(0,1,2,3); yt4 ->
<br>
(
<br>
0,0,0,0:
<br>
0,0.5877852522924731,1.1755705045849463,1.7633557568774194:
<br>
0,0.9510565162951535,1.902113032590307,2.8531695488854605:
<br>
0,0.9510565162951536,1.9021130325903073,2.853169548885461:
<br>
0,0.5877852522924732,1.1755705045849465,1.7633557568774196:
<br>
0,1.2246467991473532e-16,2.4492935982947064e-16,3.6739403974420594e-16:
<br>
0,-0.5877852522924727,-1.1755705045849454,-1.763355756877418:
<br>
0,-0.9510565162951535,-1.902113032590307,-2.8531695488854605:
<br>
0,-0.9510565162951536,-1.9021130325903073,-2.853169548885461:
<br>
0,-0.5877852522924734,-1.1755705045849467,-1.76335575687742:
<br>
0,-2.4492935982947064e-16,-4.898587196589413e-16,-7.347880794884119e-16
<br>
)
<br>
・case違いの演算を繰り返してxt,ytを作り直す場合
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合
<br>
storage cleared
<br>
t0=0;
<br>
t1=2*pi;
<br>
tn=&lt;t0+(t1-t0)*n/N;
<br>
N=10;
<br>
M=3;
<br>
init=&lt;last{xt=zeros(N+1,M+1),yt=zeros(N+1,M+1)};
<br>
stepnm=&lt;last{xt[n][m]=cos(tn=&gt;tn)*m,yt[n][m]=sin(tn)*m};
<br>
casesM=&lt;_sm(=&lt;stepnm,0,M);
<br>
evolutionN=&lt;_sn(=&lt;casesM,0,N);
<br>
init=&gt;; evolutionN=&gt;;
<br>
xt4=xt; xt4 ->
<br>
(
<br>
0,1,2,3:
<br>
0,0.8090169943749475,1.618033988749895,2.4270509831248424:
<br>
0,0.30901699437494745,0.6180339887498949,0.9270509831248424:
<br>
0,-0.3090169943749471,-0.6180339887498942,-0.9270509831248414:
<br>
0,-0.8090169943749473,-1.6180339887498947,-2.427050983124842:
<br>
0,-1,-2,-3:
<br>
0,-0.8090169943749478,-1.6180339887498956,-2.4270509831248432:
<br>
0,-0.30901699437494756,-0.6180339887498951,-0.9270509831248427:
<br>
0,0.30901699437494723,0.6180339887498945,0.9270509831248417:
<br>
0,0.8090169943749473,1.6180339887498947,2.427050983124842:
<br>
0,1,2,3
<br>
)
<br>
yt4=yt; yt4 ->
<br>
(
<br>
0,0,0,0:
<br>
0,0.5877852522924731,1.1755705045849463,1.7633557568774194:
<br>
0,0.9510565162951535,1.902113032590307,2.8531695488854605:
<br>
0,0.9510565162951536,1.9021130325903073,2.853169548885461:
<br>
0,0.5877852522924732,1.1755705045849465,1.7633557568774196:
<br>
0,1.2246467991473532e-16,2.4492935982947064e-16,3.6739403974420594e-16:
<br>
0,-0.5877852522924727,-1.1755705045849454,-1.763355756877418:
<br>
0,-0.9510565162951535,-1.902113032590307,-2.8531695488854605:
<br>
0,-0.9510565162951536,-1.9021130325903073,-2.853169548885461:
<br>
0,-0.5877852522924734,-1.1755705045849467,-1.76335575687742:
<br>
0,-2.4492935982947064e-16,-4.898587196589413e-16,-7.347880794884119e-16
<br>
)
<br>
<br>
<a href="#span-out-evolution">時間発展の解法</a>を使用して時系列dataを作成する一例を以下に示す
<br>
・total時間積分回数がplot2d-buttonのN回に対して1回で済むため、圧倒的に速い
<br>
・時間刻みを次の<a href="#span-out-eqns">式変数</a>dtnで定義してevolutionNで時間発展する
<br>
dtn=&lt;switch(n&lt;=0,0:1,dt);
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v};
<br>
/*{$z_x,$z_v}=x_initial=&gt;;*/
<br>
t0=0;
<br>
t1=5;
<br>
N=round((t1-t0)/dt);
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
dtn=&lt;switch(n&lt;=0,0:1,dt);
<br>
step=&lt;{x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,0,dtn=&gt;)};
<br>
stepn=&lt;last{step=&gt;,xt[n]=real(z_x),yt[n]=imag(z_x)};
<br>
evolutionN=&lt;_sn(=&lt;stepn,0,N);
<br>
init=&gt;; evolutionN=&gt;; xt,yt ->
<br>
(
<br>
0,0:
<br>
7.864583333333332+O(6e-2),6.818229166666667:
<br>
12.636583116319443+O(6e-2),9.028508843315972:
<br>
15.532093401308412+O(6e-2),8.442819167949535:
<br>
17.289004589856408+O(6e-2),6.160616838886046:
<br>
18.355047055824333+O(6e-2),2.849020113178252:
<br>
19.001890531268412+O(6e-2),-1.0871831084100707:
<br>
19.394376285899845+O(6e-2),-5.402379334009235:
<br>
19.63252519430902+O(6e-2),-9.947537460479563:
<br>
19.77702700592188+O(6e-2),-14.6322297611764:
<br>
19.86470649057239+O(6e-2),-19.40158732904714
<br>
)
<br>
・<a href="#span-out-evolution">時間発展の解法</a>に示す各時刻の位置z_xの近似解に一致する
<br>
xt+yt*i ->
<br>
(
<br>
0:
<br>
7.864583333333332+6.818229166666667i+O(6e-2):
<br>
12.636583116319443+9.028508843315972i+O(6e-2):
<br>
15.532093401308412+8.442819167949535i+O(6e-2):
<br>
17.289004589856408+6.160616838886046i+O(6e-2):
<br>
18.355047055824333+2.849020113178252i+O(6e-2):
<br>
19.001890531268412-1.0871831084100707i+O(6e-2):
<br>
19.394376285899845-5.402379334009235i+O(6e-2):
<br>
19.63252519430902-9.947537460479563i+O(6e-2):
<br>
19.77702700592188-14.6322297611764i+O(6e-2):
<br>
19.86470649057239-19.40158732904714i+O(6e-2)
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
comment文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-comment"></span>
comment文の入力仕様と付随する留意事項について記述する
<br>
<br>
次のcomment文2種類は実行文に含まれない
<br>
<span class="selection">// line comment</span>
<br>
<span class="selection">/* block comment */</span>
<br>
<br>
test caseを示す
<br>
x=-0xff; <span class="selection">/*x:16進数値*/</span> x&gt;&gt;3 <span class="selection">// 右shift3回</span>
<br>
-> -32
<br>
・<a href="#span-out-bracket">parse</a>後の実行文を示す
<br>
x=-0xff; x&gt;&gt;3 -> -32
<br>
・同義
<br>
x=-255; floor(x/(2^3)) -> -32
<br>
x=-255; int(x/(2^3)) -> -32
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
命令文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-command"></span>
命令文の入力仕様と付随する留意事項について記述する
<br>
<br>
命令文は上位の実行文に相当する
<br>
・semi-colon;以外で区切った場合、error終了
<br>
clear || clear; -> local storage cleared
<br>
clear, || clear: -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-BT">括弧</a>の中で呼出した場合、error終了
<br>
(clear) || {clear} -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-substitution">変数への代入</a>不可
<br>
clear; x=clear -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-substitution-equation">式変数への式代入</a>不可
<br>
f=&lt;clear -> [MyErr]Invalid clear called
<br>
<br>
命令文を以下に示す
<br>
<br>
clear
<br>
・呼出し時点までのlocal <a href="#span-out-storage">storage</a>をclearする
<br>
x=3; x -> 3
<br>
clear -> local storage cleared
<br>
x -> 3
<br>
clear; x -> [MyErr]Invalid REv(x)
<br>
x -> 3
<br>
clear; ans -> [MyErr]Invalid REv(ans)
<br>
ans -> 3
<br>
・続けてglobal <a href="#span-out-storage">storage</a>をclearする場合
<br>
Clear実行確定 ->
<br>
storage cleared
<br>
x -> [MyErr]Invalid REv(x)
<br>
ans -> [MyErr]Invalid REv(ans)
<br>
・global <a href="#span-out-storage">storage</a>に一切の変数を残さない場合
<br>
x=3; y=3x; y; clear -> local storage cleared
<br>
x -> [MyErr]Invalid REv(x)
<br>
y -> [MyErr]Invalid REv(y)
<br>
ans -> [MyErr]Invalid REv(ans)
<br>
<br>
store
<br>
・呼出し時点までのlocal <a href="#span-out-storage">storage</a>をlocal <a href="#span-out-storage">buffer</a>に保存する
<br>
・元objectを新規objectに複製する
<br>
<br>
restore
<br>
・local <a href="#span-out-storage">buffer</a>に保存されたlocal <a href="#span-out-storage">storage</a>を復帰する
<br>
<del>・複製した新規objectをそのまま復帰する（元objectの参照を切る仕様）</del>
<br>
<span class="clear">Ver.2.30.17</span>以降、元objectの参照を保存
<br>
clear; x=2; store; x=3; restore; x -> 2
<br>
clear; x=2; store; clear; restore; x -> 2
<br>
<span class="clear">Ver.2.30.17</span>以降、clear実行後、新規objectを複製してから復帰する（再利用に対応）
<br>
clear; a=2; store; a=3; restore; a; a=3; restore; a -> 2
<br>
clear; a=2; store; a=3; restore; a; a=3; b=4; restore; b -> [MyErr]Invalid REv(b)
<br>
・HTML5描画canvas等、stack方式と異なり、最新のstore時点のobjectのみ再利用可
<br>
clear; a=2; store; a=3; store; restore; a; restore; a  <span class="selection">// not stacked</span> -> 3
<br>
・store~restore間に新規に定義された<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は参照不可
<br>
clear; x=2; store; y=3; clear; restore; x+y -> [MyErr]Invalid binary operation
<br>
clear; x=2; store; y=3; store; clear; restore; x+y -> 5
<br>
・store;clear~restore間の<a href="#span-out-scope-vars">変数のscope</a>は完全独立
<br>
clear; x=2; store; clear; x=3; restore; x -> 2
<br>
clear; x=2; store; clear; x -> [MyErr]Invalid REv(x)
<br>
・演算実行確定1回毎にlocal <a href="#span-out-storage">buffer</a>は消去される
<br>
storage cleared
<br>
restore -> null buffer
<br>
x=2; store -> local storage stored
<br>
restore -> null buffer
<br>
restore; x -> [MyErr]Invalid REv(x)
<br>
<br>
stop
<br>
・呼出し時点以降の演算を中断する
<br>
x=3; 3x; stop; x -> operation stopped
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
区切り文字
<br>
入力仕様
    </th>
    <td>
<span id="span-out-SR"></span>
区切り文字の入力仕様と付随する留意事項について記述する
<br>
<br>
区切り文字を優先順に列挙する
<br>
・各実行文を区切るsemi-colon;
<br>
実行文; 実行文; ...
<br>
・<a href="#span-out-mat">行列</a>の各vectorを区切るcolon:
<br>
vector: vector: ...
<br>
・vectorの各要素||<a href="#span-out-FN">関数</a>の引数を区切るcomma,
<br>
要素, 要素, ... || 引数, 引数, ...
<br>
<br>
区切り文字は<a href="#span-out-associativity">2項演算子のassociativity</a>や<a href="#span-out-bracket">階層</a>の深さとは無関係に左から順に演算する
<br>
・区切り文字の<a href="#span-out-prec">演算のprecedence</a>は最優先
<br>
x=3,(x=9),2x -> (0,0,18)
<br>
x -> 9
<br>
・よって<a href="#span-out-vars">変数</a>は実行直前ではなく列挙直前の代入値を参照する
<br>
x=3; x=2:3x -> (0:6)
<br>
<br>
区切り文字はNativeの<a href="#span-out-option4">comma演算子</a>同様に働くが、<a href="#span-out-mat">行列</a>の次元は残る
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
最上位関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNc"></span>
最上位関数の入力仕様と付随する留意事項について記述する
<br>
<br>
以下の最上位関数は<a href="#span-out-BT">括弧</a>より優先する
<br>
<br>
hasVar最上位関数
<br>
・<a href="#span-out-vars">変数</a>のlocal <a href="#span-out-storage">storage</a>存在可否を判定する
<br>
・引数
<br>
　・第1引数: <a href="#span-out-vars-symbol">変数名symbol</a>
<br>
・返値
<br>
　・exist時: 1を返す
<br>
　・not exist時: 0を返す
<br>
・test caseを列挙する
<br>
clear; a=2; hasVar(a) -> 1
<br>
clear; a=2; hasVar(b) -> 0
<br>
・第1引数は<a href="#span-out-FNm-last">最終要素</a>を参照する
<br>
clear; a=2; hasVar(b,c:a) -> 1
<br>
clear; a=2; hasVar(a,b:c) -> 0
<br>
clear; a=2; hasVar((b,a),c) -> 0
<br>
clear; a=2; hasVar({b,a},c) -> 1
<br>
・引数不正の場合、error終了
<br>
hasVar() -> [MyErr]Invalid FNc(hasvar)
<br>
hasVar(2) || hasVar(a=2) -> [MyErr]Invalid hasvar arguments
<br>
<br>
hasEqn最上位関数
<br>
・<a href="#span-out-eqns">式変数</a>のlocal <a href="#span-out-storage">storage</a>存在可否を判定する
<br>
・hasVar最上位関数同様
<br>
・test caseを列挙する
<br>
clear; a=2; hasEqn(a) -> 0
<br>
clear; a=&lt;2; hasEqn(a) -> 1
<br>
clear; a=&lt;2; hasEqn(b) -> 0
<br>
<br>
delVar最上位関数
<br>
・<a href="#span-out-vars">変数</a>をlocal <a href="#span-out-storage">storage</a>から削除する
<br>
・引数
<br>
　・第1引数: <a href="#span-out-vars-symbol">変数名symbol</a>
<br>
・返値
<br>
　・削除対象exist時: 1を返す
<br>
　・削除対象not exist時: 0を返す
<br>
・test caseを列挙する
<br>
clear; a=2; delVar(a) -> 1
<br>
clear; a=2; delVar(b) -> 0
<br>
clear; a=2; (delVar(a)) -> 1
<br>
clear; a=2; (delVar(a),a)  <span class="selection">// a deleted</span> -> [MyErr]Invalid REv(a)
<br>
clear; a=2; (delVar(b),a) -> (0,2)
<br>
clear; a=2; a*delVar(a)  <span class="selection">// a deleted</span> -> [MyErr]Invalid binary operation
<br>
・第1引数は<a href="#span-out-FNm-last">最終要素</a>を参照する
<br>
clear; a=2; (delVar(b,c:a),a)  <span class="selection">// a deleted</span> -> [MyErr]Invalid REv(a)
<br>
clear; a=2; (delVar(a,b:c),a) -> (0,2)
<br>
clear; a=2; (delVar((b,a),c),a) -> (0,2)
<br>
clear; a=2; (delVar({b,a},c),a)  <span class="selection">// a deleted</span> -> [MyErr]Invalid REv(a)
<br>
<br>
delEqn最上位関数
<br>
・<a href="#span-out-eqns">式変数</a>をlocal <a href="#span-out-storage">storage</a>から削除する
<br>
・delVar最上位関数同様
<br>
・test caseを列挙する
<br>
clear; a=2; delEqn(a) -> 0
<br>
clear; a=&lt;2; delEqn(a) -> 1
<br>
clear; a=&lt;2; delEqn(b) -> 0
<br>
clear; a=&lt;2; (delEqn(a)) -> 1
<br>
clear; a=&lt;2; (delEqn(a),a=&gt;)  <span class="selection">// a deleted</span> -> [MyErr]Invalid REv(a)
<br>
clear; a=&lt;2; (delEqn(b),a=&gt;) -> (0,2)
<br>
・<a href="#span-out-command">命令文</a>を使用
<br>
clear; a=&lt;2; store; delEqn(a); a=&gt;  <span class="selection">// a deleted</span> -> [MyErr]Invalid REv(a)
<br>
clear; a=&lt;2; store; delEqn(a); restore; a=&gt; -> 2
<br>
・自身をdelete不可
<br>
clear; delete=&lt;delEqn(delete); delete=&gt; -> [MyErr]Invalid delEqnSelf(delete)
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、addVar/addEqn/hasV/hasE最上位関数を追加
<br>
<br>
addVar最上位関数
<br>
・<a href="#span-out-bracket">直列scope内</a>の<a href="#span-out-vars">変数</a>をlocal <a href="#span-out-storage">storage</a>に追加する
<br>
・引数
<br>
　・第1引数: <a href="#span-out-vars-symbol">変数名symbol</a>
<br>
・返値
<br>
　・追加対象exist時: 1を返す
<br>
　・追加対象not exist時: 0を返す
<br>
・test caseを列挙する
<br>
clear; a=&lt;2; addVar(a) -> 0
<br>
clear; a=2; addVar(a) -> 1
<br>
clear; a=2; addVar(a),addVar(a) -> (1,1)
<br>
clear; a=2; addVar(a); a -> 2
<br>
clear; a=2; addVar(b) -> 0
<br>
clear; a=2; addVar(b); a -> 2
<br>
clear; [a=2,]; a -> [MyErr]Invalid REv(a)
<br>
clear; [a=2,addVar(a)]; a -> 2
<br>
clear; [a=2,[a=3,addVar(a)]]; a -> 3
<br>
clear; [a=2,[a=3,[a=4,addVar(a)]]]; a -> 4
<br>
clear; [a=2,[a=3,[a=4,[a=5,],addVar(a)]]]; a -> 4
<br>
clear; [a=2,[a=3,[[a=5,],addVar(a)]]]; a -> [MyErr]Invalid REv(a)
<br>
clear; [a=2,[a=3,([a=5,],addVar(a))]]; a -> 3
<br>
<br>
addEqn最上位関数
<br>
・<a href="#span-out-bracket">直列scope内</a>の<a href="#span-out-eqns">式変数</a>をlocal <a href="#span-out-storage">storage</a>に追加する
<br>
・addVar最上位関数同様
<br>
・test caseを列挙する
<br>
clear; a=2; addEqn(a) -> 0
<br>
clear; a=&lt;2; addEqn(a) -> 1
<br>
clear; a=&lt;2; addEqn(a),addEqn(a) -> (1,1)
<br>
clear; a=&lt;2; addEqn(a); a=&gt; -> 2
<br>
clear; a=&lt;2; addEqn(b) -> 0
<br>
clear; a=&lt;2; addEqn(b); a=&gt; -> 2
<br>
clear; [a=&lt;2,]; a=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; [a=&lt;2,addEqn(a)]; a=&gt; -> 2
<br>
clear; [a=&lt;2,[a=&lt;3,addEqn(a)]]; a=&gt; -> 3
<br>
clear; [a=&lt;2,[a=&lt;3,[a=&lt;4,addEqn(a)]]]; a=&gt; -> 4
<br>
clear; [a=&lt;2,[a=&lt;3,[a=&lt;4,[a=&lt;5,],addEqn(a)]]]; a=&gt; -> 4
<br>
clear; [a=&lt;2,[a=&lt;3,[[a=&lt;5,],addEqn(a)]]]; a=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; [a=&lt;2,[a=&lt;3,([a=&lt;5,],addEqn(a))]]; a=&gt; -> 3
<br>
<br>
hasV最上位関数
<br>
・<a href="#span-out-vars">変数</a>の<a href="#span-out-bracket">直列scope内</a>存在可否を判定する
<br>
・引数
<br>
　・第1引数: <a href="#span-out-vars-symbol">変数名symbol</a>
<br>
・返値
<br>
　・exist時: 1を返す
<br>
　・not exist時: 0を返す
<br>
・test caseを列挙する
<br>
clear; a=&lt;2; hasV(a) -> 0
<br>
clear; a=2; hasV(a) -> 1
<br>
clear; a=2; hasV(b) -> 0
<br>
clear; a=2; hasV(a),[b=3,hasV(a),hasV(b)],hasV(b) -> (1,0,1,1,0)
<br>
clear; a=2; hasV(a),[b=3,[hasV(a),hasV(b)]],hasV(b) -> (1,0,1,1,0)
<br>
<br>
hasE最上位関数
<br>
・<a href="#span-out-eqns">式変数</a>の<a href="#span-out-bracket">直列scope内</a>存在可否を判定する
<br>
・hasV最上位関数同様
<br>
・test caseを列挙する
<br>
clear; a=2; hasE(a) -> 0
<br>
clear; a=&lt;2; hasE(a) -> 1
<br>
clear; a=&lt;2; hasE(b) -> 0
<br>
clear; a=&lt;2; hasE(a),[b=&lt;3,hasE(a),hasE(b)],hasE(b) -> (1,0,1,1,0)
<br>
clear; a=&lt;2; hasE(a),[b=&lt;3,[hasE(a),hasE(b)]],hasE(b) -> (1,0,1,1,0)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
括弧
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT"></span>
括弧の入力仕様と付随する留意事項について記述する
<br>
<br>
実行文の一部を括る括弧は3種類使用可
<br>
<br>
優先順に列挙する
<br>
・波括弧{}
<br>
・丸括弧()
<br>
・<a href="#span-out-BT-square">角括弧[]</a>
<br>
<br>
括弧は<a href="#span-out-SR">区切り文字</a>に含める
<br>
・実行文を区切るsemi-colon;を括弧の中で使用した場合、error終了
<br>
(;) -> [MyErr]Invalid {([])}
<br>
・対応関係が取れない括弧のnestingが見つかった場合、error終了
<br>
[(0]) -> [MyErr]Invalid {([])}
<br>
<br>
丸括弧()は行vectorをcolon:区切りで列挙する
<br>
・<a href="#span-out-BT-square">角括弧[]</a>は丸括弧()に準ずる
<br>
(行vector: 行vector: ...) || [行vector: 行vector: ...]
<br>
<br>
波括弧{}は列vectorをcolon:区切りで列挙する
<br>
{列vector: 列vector: ...}
<br>
<br>
<a href="#span-out-ope">無次元</a>の演算の場合、要素を括る丸括弧()と波括弧{}は区別しない
<br>
・列挙しなければ括弧の種類は区別しない
<br>
<br>
<a href="#span-out-ope">有次元</a>の場合、vectorを括る丸括弧()と波括弧{}は互いに<a href="#span-out-FNm-trans">転置の関係</a>
<br>
(1,2:3,4) -> (1,2:3,4)
<br>
{1,2:3,4} -> (1,3:2,4)
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
transpose({1,2:3,4}) || trans({1,2:3,4}) -> (1,2:3,4)
<br>
<br>
<a href="#span-out-FN">関数</a>の引数を括る括弧は丸括弧()で統一する（<a href="#span-out-FNm-last">last行列関数</a>を除く）
<br>
・波括弧{}を使用した場合、引数が転置される
<br>
trans(1,2:3,4) -> (1,3:2,4)
<br>
trans{1,2:3,4} -> (1,2:3,4)
<br>
max(2,1) -> 2
<br>
<del>max{2,1} -> 1</del><span class="run">Ver.2.73.29</span>以降、<a href="#span-out-ope-extended">拡張行列演算</a>参照
<br>
max{2,1} -> (2:1)
<br>
<br>
括弧なしで要素を列挙した場合、行vector扱いの丸括弧()で括られる
<br>
1,2,3 -> (1,2,3)
<br>
<br>
演算結果のlog表示は丸括弧()
<br>
{1,2:3,4} || [1,3:2,4] -> (1,3:2,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
括弧の
<br>
associativity
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT-associativity"></span>
括弧のassociativityの入力仕様と付随する留意事項について記述する
<br>
<br>
vectorを括る丸括弧()と波括弧{}は互いに<a href="#span-out-FNm-trans">転置の関係</a>で<a href="#span-out-BT">括弧</a>のassociativityが存在する
<br>
<br>
1重列挙の場合、外側に<a href="#span-out-BT">括弧</a>のassociativityは存在しない
<br>
(1,2) || {(1,2)} || ({(1,2)}) || {({(1,2)})} -> (1,2)
<br>
{1,2} || ({1,2}) || {({1,2})} || ({({1,2})}) -> (1:2)
<br>
・よって上流で列挙しない限り、<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は任意の<a href="#span-out-BT">括弧</a>で括れる
<br>
x=(1,2); y={1,2}; x*y || (x)(y) || {x}{y} || ({x}{y}) || {{x}{y}}  -> 5
<br>
x=&lt;(1,2); y=&lt;{1,2}; x*y || (x)(y) || {x}{y} || ({x}{y}) || {{x}{y}}  -> 5
<br>
<br>
2重列挙の場合
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
x=(1,2); y={3,4}; (x,y) -> (1,2,3:0,0,4)
<br>
x=(1,2); y={3,4}; (x:y) -> (1,2:3:4)
<br>
x=(1,2); y={3,4}; {x,y} -> (1,2:3:4)
<br>
x=(1,2); y={3,4}; {x:y} -> (1,2,3:0,0,4)
<br>
・<a href="#span-out-eqns">式変数</a>も同様
<br>
x=&lt;(1,2); y=&lt;{3,4}; (x,y) -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; (x:y) -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; {x,y} -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; {x:y} -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;(x,y); z -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;(x:y); z -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;{x,y}; z -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;{x:y}; z -> (1,2,3:0,0,4)
<br>
・抜け要素は0として演算する
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
trans(trans((1,2:3:4))) -> (1,2:3,0:4,0)
<br>
trans(trans{(1,2:3:4)}) -> (1,2:3,0:4,0)
<br>
trans{trans{(1,2:3:4)}} -> (1,2:3,0:4,0)
<br>
x=(1,2); y={3,4}; trans(trans((x:y))) -> (1,2:3,0:4,0)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
角括弧
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT-square"></span>
角括弧[]の入力仕様と付随する留意事項について記述する
<br>
<br>
角括弧[]は直前の<a href="#span-out-mat">行列</a>要素の行/列indexを指定する
<br>
<a href="#span-out-mat">行列</a>[行index][列index]
<br>
<a href="#span-out-vars">変数</a>[行index][列index]
<br>
<a href="#span-out-eqns">式変数</a>[行index][列index]=&gt;
<br>
<a href="#span-out-eqns">式変数</a>[行index][列index](<a href="#span-out-eqns-args">arguments</a>)=&gt;
<br>
・よって<a href="#span-out-BT">括弧</a>の中で最下位の<a href="#span-out-prec">演算のprecedence</a>
<br>
・唯一のRight-Associativity（右から左を参照）
<br>
A=(1,2:3,4); A[0][0] || (1,2:3,4)[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] || (1,2:3,4)[1][1] -> 4
<br>
A=(1,2:3,4); A[0] || (1,2:3,4)[0] -> (1,2)
<br>
A=(1,2:3,4); A[1] || (1,2:3,4)[1] -> (3,4)
<br>
・複数の要素を持つcaseのみ、<a href="#span-out-mat">行列</a>として使用可
<br>
A=(1,2:3,4); A[1,2:3,4] -> (7,10:15,22)
<br>
[1,2][0][0] -> 1
<br>
[1,2:3,4][0] -> (1,2)
<br>
[1,2:3,4][1] -> (3,4)
<br>
<br>
詳細は<a href="#span-out-array">行列操作入力仕様</a>参照
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、<a href="#span-out-scope-vars">変数のscope</a>を追加
<br>
・複数の要素を持つcaseのみ、<a href="#span-out-scope-vars">変数のscope</a>有効
<br>
clear; 3*[a=2] || 3*[0] -> [MyErr]Invalid BRdm(*)
<br>
clear; [a=2]*3 || [0]*3 -> [MyErr]Invalid reference
<br>
clear; 3*[a=2,a] || 3*[0,2] -> (0,6)
<br>
clear; [a=2,a]*3 || [0,2]*3 -> [MyErr]Invalid matrix operation
<br>
clear; 3*[a=2,a]; a -> [MyErr]Invalid REv(a)
<br>
<br>
詳細は<a href="#span-out-scope-vars">変数のscope</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行参照
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT-square-row"></span>
行参照の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.78.31</span>以降、<a href="#span-out-mat">行列</a>の行参照と<a href="#span-out-substitution-mat-row">行代入</a>の<span class="selection">反転機能</span>を追加
<br>
<br>
行指定で<a href="#span-out-mat">行列</a>の行vectorを参照する場合
<br>
<a href="#span-out-mat">行列</a>[行index]
<br>
<a href="#span-out-vars">変数</a>[行index]
<br>
<a href="#span-out-eqns">式変数</a>[行index]=&gt;
<br>
<a href="#span-out-eqns">式変数</a>[行index](<a href="#span-out-eqns-args">arguments</a>)=&gt;
<br>
・<a href="#span-out-BT-square">列index</a>を省略する
<br>
A=&lt;(1,2:3,4); A[0] || (1,2:3,4)[0] -> (1,2)
<br>
A=&lt;(1,2:3,4); A[1] || (1,2:3,4)[1] -> (3,4)
<br>
・抜け要素を自動で埋めない
<br>
A=&lt;(1:3,4); A[0] -> 1
<br>
A=&lt;(1:3,4); A[1] -> (3,4)
<br>
・<a href="#span-out-BT-square">行index</a>が負の場合、<span class="selection">反転参照</span>を定義する
<br>
A=&lt;(1:3,4:); A[<span class="selection">-1</span>] -> 0
<br>
A=&lt;(1:3,4:); A[<span class="selection">-2</span>] -> (3,4)
<br>
A=&lt;(1:3,4:); A[<span class="selection">-3</span>] -> 1
<br>
・未定義の<a href="#span-out-mat">行列</a>要素の参照不可
<br>
A=&lt;(1:3,4:); A[<span class="selection">-4</span>] -> [MyErr]Invalid reference of array
<br>
A=&lt;(1:3,4:); A[3] -> [MyErr]Invalid reference of array
<br>
A=&lt;(1:3,4:); A[0.3] -> [MyErr]Invalid reference of array
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
列参照
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT-square-col"></span>
列参照の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.76.29</span>以降、<a href="#span-out-mat">行列</a>の列参照と<a href="#span-out-substitution-mat-col">列代入</a>を追加
<br>
・<span class="run">Ver.2.78.31</span>以降、<a href="#span-out-mat">行列</a>の列参照と<a href="#span-out-substitution-mat-col">列代入</a>の<span class="selection">反転機能</span>を追加
<br>
<br>
列指定で<a href="#span-out-mat">行列</a>の列vectorを参照する場合
<br>
<a href="#span-out-mat">行列</a>[<span class="condition">-1</span>][列index]
<br>
<a href="#span-out-vars">変数</a>[<span class="condition">-1</span>][列index]
<br>
<a href="#span-out-eqns">式変数</a>[<span class="condition">-1</span>][列index]=&gt;
<br>
<a href="#span-out-eqns">式変数</a>[<span class="condition">-1</span>][列index](<a href="#span-out-eqns-args">arguments</a>)=&gt;
<br>
・<a href="#span-out-BT-square">行index</a>に<span class="condition">負値</span>を指定する
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][0] || (1,2:3,4)[<span class="condition">-1</span>][0] -> (1:3)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][1] || (1,2:3,4)[<span class="condition">-1</span>][1] -> (2:4)
<br>
・自動で抜け要素を埋める
<br>
A=(1:3,4); A[<span class="condition">-1</span>][1] || (1:3,4)[<span class="condition">-1</span>][1] -> (0:4)
<br>
A=(1:3,4:); A[<span class="condition">-1</span>][1] || (1:3,4)[<span class="condition">-1</span>][1] -> (0:4:0)
<br>
A=(1:3,4:); A[<span class="condition">-1</span>][0] || (1:3,4)[<span class="condition">-1</span>][0] -> (1:3:0)
<br>
・同義
<br>
get_vectorc(A,ic)=&lt;trans((trans(A))[ic]);
<br>
A=(1:3,4:); get_vectorc(=&lt;A,0) -> (1:3:0)
<br>
A=(1:3,4:); get_vectorc(=&lt;A,1) -> (0:4:0)
<br>
・未定義の<a href="#span-out-mat">行列</a>要素の参照不可
<br>
A=(1:3,4:); get_vectorc(=&lt;A,2) -> [MyErr]Invalid reference of array
<br>
A=(1:3,4:); A[<span class="condition">-1</span>][2] || (1:3,4)[<span class="condition">-1</span>][2] -> [MyErr]Invalid reference of array(column)
<br>
A=(1:3,4:); A[<span class="condition">-1</span>][0.3] || (1:3,4)[<span class="condition">-1</span>][0.3] -> [MyErr]Invalid reference of array(column)
<br>
・<a href="#span-out-BT-square">列index</a>が負の場合、<span class="selection">反転参照</span>を定義する
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-1</span>] || (1,2:3,4)[<span class="condition">-1</span>][<span class="selection">-1</span>] -> (2:4)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-2</span>] || (1,2:3,4)[<span class="condition">-1</span>][<span class="selection">-2</span>] -> (1:3)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-3</span>] || (1,2:3,4)[<span class="condition">-1</span>][<span class="selection">-3</span>] -> [MyErr]Invalid reference of array(column)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
area参照
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT-square-area"></span>
area参照の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.77.30</span>以降、<a href="#span-out-mat">行列</a>のarea参照と<a href="#span-out-substitution-mat-area">area代入</a>を追加
<br>
・<span class="clear">Ver.2.77.31</span>以降、開始行/列indexが非整数の場合、予期せぬerror終了を修正
<br>
・<span class="clear">Ver.2.77.31</span>以降、参照行/列sizeが非整数の場合、error終了に修正
<br>
・<span class="run">Ver.2.78.31</span>以降、<span class="selection">反転機能の有効範囲</span>を修正
<br>
<br>
area指定で範囲内の<a href="#span-out-mat">行列</a>要素を参照する場合
<br>
<a href="#span-out-mat">行列</a>[開始行index][開始列index][参照行size][参照列size]
<br>
<a href="#span-out-vars">変数</a>[開始行index][開始列index][参照行size][参照列size]
<br>
<a href="#span-out-eqns">式変数</a>[開始行index][開始列index][参照行size][参照列size]=&gt;
<br>
<a href="#span-out-eqns">式変数</a>[開始行index][開始列index][参照行size][参照列size](<a href="#span-out-eqns-args">arguments</a>)=&gt;
<br>
・<a href="#span-out-BT-square">角括弧[]</a>で指定する
<br>
A=(1,2:3,4:); A[0][0][0][0] || A[0][0][sizer(A)][sizec(A)] -> (1,2:3,4:0,0)
<br>
・参照行/列size=0の場合、参照size=<a href="#span-out-FNm">行列size</a>
<br>
A=(1,2:3,4:); A[0][0][0][1] || A[0][0][sizer(A)][1] -> (1:3:0)
<br>
A=(1,2:3,4:); A[0][0][1][0] || A[0][0][1][sizec(A)] -> (1,2)
<br>
・自動で抜け要素を埋める
<br>
A=(1,2:3,4:); A -> (1,2:3,4:0)
<br>
A=(1,2:3,4:); A[0][0][0][0] || trans(trans(A)) -> (1,2:3,4:0,0)
<br>
・参照行/列sizeを指定
<br>
A=(1,2:3,4:); A[0][0][1][1] || A[0][0] -> 1
<br>
A=(1,2:3,4:); A[1][0][1][1] || A[1][0] -> 3
<br>
A=(1,2:3,4:); A[0][1][1][1] || A[0][1] -> 2
<br>
A=(1,2:3,4:); A[0][0][2][2] -> (1,2:3,4)
<br>
・周期境界条件を適用
<br>
A=(1,2:3,4:); A[1][1][2][2] -> (4,3:0,0)
<br>
A=(1,2:3,4:); A[1][0][2][2] -> (3,4:0,0)
<br>
A=(1,2:3,4:); A[2][0][2][2] -> (0,0:1,2)
<br>
A=(1,2:3,4:); A[2][1][2][2] -> (0,0:2,1)
<br>
A=(1,2:3,4:); A[1][0][0][0] -> (3,4:0,0:1,2)
<br>
A=(1,2:3,4:); A[2][0][0][0] -> (0,0:1,2:3,4)
<br>
A=(1,2:3,4:); A[0][1][0][0] -> (2,1:4,3:0,0)
<br>
・未定義の<a href="#span-out-mat">行列</a>要素の参照不可
<br>
A=(1,2:3,4:); A[3][0][0][0] -> [MyErr]Invalid reference of array(area)
<br>
A=(1,2:3,4:); A[0][2][0][0] -> [MyErr]Invalid reference of array(area)
<br>
<span class="clear">A=(1,2:3,4:); A[0.1][0][0][0] -> [MyErr]Invalid reference of array(area)</span>
<br>
<span class="clear">A=(1,2:3,4:); A[0][0.1][0][0] -> [MyErr]Invalid reference of array(area)</span>
<br>
<span class="clear">A=(1,2:3,4:); A[0][0][0.1][0] -> [MyErr]Invalid reference of array(area)</span>
<br>
<span class="clear">A=(1,2:3,4:); A[0][0][0][0.1] -> [MyErr]Invalid reference of array(area)</span>
<br>
・開始行/列indexが負の場合、<span class="selection">反転参照</span>を定義する
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][0][0] -> (0,0:4,3:2,1)
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][0][0][0] -> (0,0:3,4:1,2)
<br>
A=(1,2:3,4:); A[<span class="selection">-2</span>][0][0][0] -> (3,4:1,2:0,0)
<br>
<span class="selection">A=(1,2:3,4:); A[-3][0][0][0] -> (1,2:0,0:3,4)</span>
<br>
<span class="selection">A=(1,2:3,4:); A[-4][0][0][0] -> [MyErr]Invalid reference of array(area)</span>
<br>
A=(1,2:3,4:); A[0][<span class="selection">-1</span>][0][0] -> (2,1:4,3:0,0)
<br>
<span class="selection">A=(1,2:3,4:); A[0][-2][0][0] -> (1,2:3,4:0,0)</span>
<br>
<span class="selection">A=(1,2:3,4:); A[0][-3][0][0] -> [MyErr]Invalid reference of array(area)</span>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
予約語
<br>
入力仕様
    </th>
    <td>
<span id="span-out-RW"></span>
予約語の入力仕様と付随する留意事項について記述する
<br>
<br>
予約語の種類を列挙する
<br>
・<a href="#span-out-UI-graphing">Graphing Calculator</a>'s <a href="#span-out-plot2d-command">plot2d-command</a>
<br>
・<a href="#span-out-comment">comment文</a>
<br>
・<a href="#span-out-command">命令文</a>
<br>
・<a href="#span-out-SR">区切り文字</a>・<a href="#span-out-BT">括弧</a>
<br>
・<a href="#span-out-FN0">定数</a>含む<a href="#span-out-FN">関数</a>名
<br>
・<a href="#span-out-prec-ope">演算子</a>記号
<br>
・operand記号
<br>
　・<a href="#span-out-ans">予約変数</a>
<br>
　・10進数値小数
<br>
　・10進数値指数
<br>
　・16進数値0x
<br>
<br>
予約語の規則を列挙する
<br>
・大文字・小文字・全角・半角を区別しない
<br>
・<a href="#span-out-vars">変数</a>名・<a href="#span-out-eqns">式変数</a>名に使用不可
<br>
stop=3 -> [MyErr]Invalid stop called
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
max=&lt;3 -> [MyErr]Invalid BTe([object Object])
<br>
ＭＡＸ=3 -> [MyErr]Invalid ans isFound
<br>
<br>
予約語の一覧は<a href="#span-in-FN">内部仕様</a>参照
   </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN0"></span>
定数の入力仕様と付随する留意事項について記述する
<br>
<br>
定数は引数<a href="#span-out-BT">括弧</a>なしで厳密には<a href="#span-out-FN">関数</a>に含めない
<br>
・実行文を作る<a href="#span-out-bracket">parse</a>段階で数値に変換する
<br>
・Excel同様に、空括弧()付を許容する
<br>
・空括弧()は<a href="#span-out-bracket">parse</a>段階で除去する
<br>
<br>
<a href="#span-out-FN">関数</a>を使用して円周率piと<a href="#span-out-com">Napier数</a>eを一例に示す
<br>
PI() || pi || 2acos(0) || 2asin(1) || 4atan(1) -> 3.141592653589793
<br>
E() || e || e^1 || exp(1) ||  -> 2.718281828459045
<br>
<br>
eは指数と区別するために空括弧()を付ける方が間違いが少ない
<br>
2e-1 || 2E-1 -> 0.2
<br>
2e()-1 || 2E()-1 -> 4.43656365691809
<br>
・<a href="#span-out-BRmo">記号省略乗算</a>を許容した弊害への対策
<br>
<br>
定数に限らず、空括弧()は<a href="#span-out-bracket">parse</a>段階ですべて除去する
<br>
()3()3() || 3*3 -> 9
<br>
()3()/()3() || 3/3 -> 1
<br>
() ->
<br>
(()) -> 0
<br>
(({})) -> 0
<br>
<del>・乱数</del><span class="run">Ver.2.30.15</span>以降、乱数は引数0個の<a href="#span-out-FN-rand">関数</a>に昇格
<br>
<del>random() || random || rand -> 0.7479324154774045</del>
<br>
・本来、<a href="#span-out-FN">関数</a>の呼出し時に空括弧を含めて判別するが、
<br>
・定数の引数<a href="#span-out-BT">括弧</a>の有無と<a href="#span-out-BRmo">記号省略乗算</a>を同時に許容した弊害への対策
<br>
<br>
次の場合、代入errorとは判別されず、右辺に移項して演算される
<br>
pi=3 || pi()=3 || =3-pi -> -0.14159265358979312
<br>
・<a href="#span-out-bracket">parse</a>後の実行文を示す
<br>
3.141592653589793=3 || =3-3.141592653589793 -> -0.14159265358979312
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
記号省略乗算
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BRmo"></span>
記号省略乗算入力仕様と付随する留意事項について記述する
<br>
<br>
2πの演算方法を円周率piを使用して次に示す
<br>
2pi || 2*pi -> 6.283185307179586
<br>
・pi2と入力した場合、<a href="#span-out-vars">変数</a>と判別される
<br>
pi2 -> [MyErr]Invalid REv(pi2)
<br>
・piの後に続ける場合、<a href="#span-out-BT">括弧</a>で区切るか乗算記号*を明示する
<br>
pi(2) || pi*2 -> 6.283185307179586
<br>
<br>
<a href="#span-out-BT-square">角括弧[]</a>は使用不可
<br>
pi[2] -> [MyErr]Invalid reference of array
<br>
[2]pi -> [MyErr]Invalid reference
<br>
x=2; x[0] -> 2
<br>
x=2; x[2] -> [MyErr]Invalid reference of array
<br>
x=2; [2]x -> [MyErr]Invalid reference
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-args">式変数のarguments</a>を追加
<br>
・記号省略乗算より<a href="#span-out-eqns-args">call先arguments</a>を優先する（<span class="clear">Ver.2.43.22</span>追記）
<br>
clear; x(t)=&lt;-t; f=&lt;x(1)+1; f -> 0
<br>
clear; x(t)=&lt;-t; f=&lt;x(1)2+1; f -> -1
<br>
clear; x(t)=&lt;-t; f=&lt;x(1)(2)+1; f -> -1
<br>
clear; x(t)=&lt;-t; f=&lt;(x(1))(2)+1; f -> -1
<br>
clear; x(t)=&lt;-t; f=&lt;x(1(-2))+1; f -> 3
<br>
clear; x(t)=&lt;-t; f=&lt;x(1(-2))(2)+1; f -> 5
<br>
clear; x(t)=&lt;-t; f=&lt;x(1(-2))2+1; f -> 5
<br>
clear; x(t)=&lt;-t; f=&lt;x((1(-2))3)+1; f -> 7
<br>
clear; x(t)=&lt;-t; f=&lt;x((1(-2))3+1); f -> 5
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)+1; f -> -998
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)=&gt;+1; f -> 0
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)=&gt;2+1; f -> -1
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)=&gt;(x)+1; f -> 1000
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)=&gt;x+1; f -> 0
<br>
clear; x(t)=&lt;-t; x=-999; f=&lt;x(1)=&gt;x+1; f; x -> -1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
複素数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-com"></span>
複素数の入力仕様と付随する留意事項について記述する
<br>
<br>
虚数単位iは<a href="#span-out-type-ope">後置単項演算子</a>とする
<br>
(+1)i || +(1)i || +1(i) || +(i) -> i
<br>
(-1)i || -(1)i || -1(i) || -(i) -> -i
<br>
3i/2 -> 1.5i
<br>
1/2i || 1/(2i) -> -0.5i
<br>
<br>
複素数を宣言する<a href="#span-out-FN">関数</a>を示す
<br>
complex(1,-1) || comp(1,-1) -> 1-i
<br>
<br>
複素数を実部と虚部に分離する<a href="#span-out-FN">関数</a>を示す
<br>
real(3+i) -> 3
<br>
imag(3+i) -> 1
<br>
<br>
iの2乗の演算方法を<a href="#span-out-type-ope">中置2項演算子</a>||<a href="#span-out-FN">関数</a>を使用して3種類示す
<br>
(i)^2 || (i)**2 || pow(i,2) -> -1+1.2246467991473532e-16i
<br>
・<a href="#span-out-float">浮動小数点演算</a>では、次のepsilonに相当する<a href="#span-out-epsilon">Machine epsilon</a>が残る
<br>
epsilon || eps -> 2.220446049250313e-16
<br>
・この傾向は<a href="#span-out-ope">演算量</a>に応じて<a href="#span-out-ope">実数演算</a>より顕著に現れる
<br>
<br>
-1の平方根の演算方法を3種類示す
<br>
(-1)^0.5 || pow(-1,0.5) || sqrt(-1) -> 6.123233995736766e-17+i
<br>
・先頭の丸括弧()を省略した場合、次のように演算される
<br>
-1^0.5 || -(1^0.5) -> -1
<br>
・符号付の分母の丸括弧()を省略した場合、error終了
<br>
1/-i || (1/)(-i) -> [MyErr]Invalid binary operation
<br>
1/(-i) -> i
<br>
<br>
Napier数eの空括弧()を省略してEulerの公式から極形式の複素数を示す
<br>
(sqrt2)e^(i{pi/4}) || sqrt2()ecomp(pi/4) -> 1.0000000000000002+i
<br>
sqrt2 || sqrt2() -> 1.4142135623730951
<br>
<br>
<a href="#span-out-vars">変数</a>を使用
<br>
・複素数zの偏角/piを示す
<br>
z=e^(i{pi/4}); arg(z)/pi -> 0.25
<br>
・複素数zの絶対値を示す
<br>
z=e^(i{pi/4}); abs(z) -> 1
<br>
<br>
以上より、次の複素数演算をtest caseとして初期表示する
<br>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
<br>
・<a href="#span-out-associativity">2項演算子のassociativity</a>は<a href="#span-out-option1">LA既定</a>で除算より<a href="#span-out-BRmo">記号省略乗算</a>を優先する
<br>
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
<br>
<br>
<a href="#span-out-associativity">2項演算子のassociativity</a>や<a href="#span-out-prec-ope">演算子のprecedence</a>によって解が異なる場合、入力を見直す
<br>
<br>
具体的には次のように対策する
<br>
a={5-3}-1; b=2/{2i(a)i}; e^(-i(1pi()b/(-4)))
<br>
・一部分を変数に代入し、semi-colon;区切りで演算順序を明確化する
<br>
・<a href="#span-out-type-ope">中置2項演算子</a>が連続する場合、<a href="#span-out-BT">括弧</a>を明示する
<br>
<br>
<a href="#span-out-ope">実数演算</a>の場合、虚数は0のため、次の極形式は使用不可
<br>
t=pi/4; e^(i{t}) || e^(real(i)t) || e^(0)  <span class="selection">// NG</span> -> 1
<br>
・極形式の<a href="#span-out-FN">関数</a>を使用
<br>
pcomp(1,t) || ecomp(t) || cos(t)+real(i)sin(t) || cos(t) -> 0.7071067811865476
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN"></span>
関数の入力仕様と付随する留意事項について記述する
<br>
<br>
関数の引数を括る<a href="#span-out-BT">括弧</a>は丸括弧()で統一する（<a href="#span-out-FNm-last">last行列関数</a>を除く）
<br>
<br>
関数の引数に<a href="#span-out-mat">行列</a>を指定した場合、<del>最終行vector</del>
<br>
<span class="run">Ver.2.73.29</span>以降、各行vectorの左から順に参照する
<br>
・引数1個の関数の場合
<br>
clear; x=(1,2,3); log(x) || log(1) -> 0
<br>
clear; x=(1,2,3:4,5,6); log(x) || (log(1):log(4)) -> (0:1.3862943611198906)
<br>
・引数1個||2個の関数の場合
<br>
clear; x=(1,2,3); log_ex(x) || log_ex(1,2) -> 0
<br>
clear; x=(1,2,3:4); log_ex(x) || (log_ex(1,2):log_ex(4)) -> (0:0.6020599913279623)
<br>
・引数2個の関数の場合
<br>
clear; x=(1,2,3); atan2(x) || atan2(1,2) -> 0.4636476090008061
<br>
clear; x=(1,2,3:4,5,6); atan2(x) || (atan2(1,2):atan2(4,5)) ->
<br>
(0.4636476090008061:0.6747409422235527)
<br>
clear; x=(1,2,3:4); atan2(x) || (atan2(1,2):atan2(4)) -> [MyErr]FN isNaN
<br>
・引数不定の関数の場合
<br>
clear; x=(1,2,3); max(x) || max(1,2,3) -> 3
<br>
clear; x=(1,2,3:4,5,6); max(x) || (max(1,2,3):max(4,5,6)) -> (3:6)
<br>
clear; x=(1,2,3:4,5,6); lcm(x) || (lcm(1,2,3):lcm(4,5,6)) -> (6:60)
<br>
clear; x=(1,2,3:4*(1,2,3)); gcd(x) || (gcd(1,2,3):gcd(4*(1,2,3))) -> (1:4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
関数の引数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-args"></span>
関数の引数の入力仕様と付随する留意事項について記述する
<br>
<br>
一部の実装関数において引数不足の場合、予期せぬerror終了が発生する
<br>
・pow関数を一例に示す
<br>
・<a href="#span-out-ope">実数演算</a>の場合、Nativeに同義
<br>
pow(2)  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
・<a href="#span-out-com">複素数</a>演算の場合、逐次引数不足を判定しないため、予期せぬerror終了
<br>
pow(2)  <span class="selection">// NG</span> -> Unexpected error
<br>
<br>
一部の実装関数において引数不足の場合、不正な結果を返す
<br>
cmin(i)  <span class="selection">// NG</span> -> i
<br>
cmin(0,-1+i,2i-2) -> 0
<br>
cmax(0,-1+i,2i-2) || abs(2i-2) -> 2.8284271247461903
<br>
cmin({0,-1+i,2i-2}) || cmin(2i-2)  <span class="selection">// NG</span> -> -2+2i
<br>
・引数不足を含めて一般化する場合、abs関数を使用
<br>
abs(cmin(i)) -> 1
<br>
abs(cmin({0,-1+i,2i-2})) || abs(cmin(2i-2)) -> 2.8284271247461903
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
cmin(trans({0,-1+i,2i-2})) || cmin(trans{0,-1+i,2i-2}) || cmin(0,-1+i,2i-2) -> 0
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
clear; x=(0,-1+i,2i-2); cmin(x) || cmin{x} || cmin({x}) || cmin{{x}} -> 0
<br>
・1重列挙の場合、外側に<a href="#span-out-BT-associativity">括弧のassociativity</a>は存在しない
<br>
<br>
一部の実装関数において引数不正の場合、未定義のfalseを返す（<span class="run">Ver.2.46.24</span>追記）
<br>
・最小公倍数を求めるlcm関数の引数は0を含む自然数のみ有効
<br>
lcm(0,2,4,6,0) -> 0
<br>
lcm(2,4,6) -> 12
<br>
・最大公約数を求めるgcd関数の引数は正の整数のみ有効
<br>
gcd(0,2,4,6,0) || gcd(2,4,6) -> 2
<br>
・引数不正の場合
<br>
lcm(-1,2,-3) || gcd(-1,2,-3) -> false
<br>
clear; false -> [MyErr]Invalid REv(false)
<br>
・falseは0として扱う
<br>
clear; x=gcd(-1,2,-3); x -> false
<br>
clear; x=gcd(-1,2,-3); x==0 || 0==x -> 1
<br>
clear; x=gcd(-1,2,-3); x*1 || 0*1 -> 0
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算子
<br>
代替関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-ope"></span>
演算子代替関数の入力仕様と付随する留意事項について記述する
<br>
<br>
leftとrightの数値の関係||大小を比較する関数について記述する
<br>
<br>
operandが<a href="#span-out-com">複素数</a>の場合
<br>
・equal判定関数: ceq(left, right)
<br>
・not equal判定関数: cne(left, right)
<br>
<br>
operandが実数の場合、<a href="#span-out-type-ope">中置2項演算子</a>を代替可
<br>
・left==rightを代替するequal判定関数: eq(left, right)
<br>
・left&lt;&gt;rightを代替するnot equal判定関数: ne(left, right)
<br>
・left&lt;rightを代替するless than判定関数: lt(left, right)
<br>
・left&lt;=rightを代替するless or equal判定関数: le(left, right)
<br>
・left&gt;rightを代替するgreater than判定関数: gt(left, right)
<br>
・left&gt;=rightを代替するgreater or equal判定関数: ge(left, right)
<br>
<br>
引数
<br>
・第1引数: leftの数値を値渡し
<br>
・第2引数: rightの数値を値渡し
<br>
<br>
返値
<br>
・成立時: 1を返す
<br>
・不成立時: 0を返す
<br>
<br>
test caseを列挙する
<br>
ceq(2+3i,3*i-(-2)) -> 1
<br>
cne(2+3i,3*i-(-2)) -> 0
<br>
eq(2+3i,2-3i) || eq(2,2) -> 1
<br>
ne(5,-5) -> 1
<br>
lt(1,2)&amp;lt(3,4) || 1&amp;1  <span class="selection">// AND</span> -> 1
<br>
lt(1,2)&amp;gt(3,4) || 1&amp;0  <span class="selection">// AND</span> -> 0
<br>
lt(1,2)@lt(3,4) || 1@1  <span class="selection">// XOR</span> -> 0
<br>
lt(1,2)@gt(3,4) || 1@0  <span class="selection">// XOR</span> -> 1
<br>
lt(1,2)|lt(3,4) || 1|1  <span class="selection">// OR</span> -> 1
<br>
lt(1,2)|gt(3,4) || 1|0  <span class="selection">// OR</span> -> 1
<br>
le(1,1)*ge(1,1) || 1*1 -> 1
<br>
le(1,1)*ge(1,2) || 1*0 -> 0
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
乱数関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-rand"></span>
乱数関数の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.30.15</span>以降、乱数の即時callに対応
<br>
<br>
乱数の仕様はNativeのMath.random()に同義
<br>
・返値は区間[0,1)の一様乱数（0以上~1未満の擬似乱数）
<br>
・乱数生成器のseed値は現在時刻（指定不可）
<br>
<br>
test caseを列挙する
<br>
random() || random || rand -> 0.7479324154774045
<br>
A=0; _rn(=&lt;A=(A,rand),,2); A -> (0,0.12740820474199377,0.7111903938956377)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
階乗関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-fact"></span>
階乗関数の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="clear">Ver.2.69.28</span>以降、階乗の仕様を見直して次の致命的な不具合に繋がる入力を回避
<br>
<span class="clear">Maximum call stack size exceeded</span>
<br>
・再帰処理を単なるfor-loopに修正
<br>
・順列||組合せ関数の引数不足による無限loopを修正
<br>
<br>
階乗の仕様を列挙する
<br>
・operandは0を含む自然数のみ対応
<br>
・<span class="jF">operandが負の場合、未定義で0を返す</span>
<br>
・<span class="condition">operand=0の場合、1を返す</span>
<br>
<br>
test caseを列挙する
<br>
・階乗fact(n)
<br>
fact(3.3) || 3.3! || 3! || 3*2*1 -> 6
<br>
fact(3i) || (3i)! || 0! -> 1
<br>
fact(3+3i) || (3+3i)! || 3! || 3*2*1 -> 6
<br>
<span class="jF">fact(-3) || (-3)! -> 0</span>
<br>
<span class="condition">fact(0) || 0! -> 1</span>
<br>
fact(1) || 1! || 1 -> 1
<br>
fact(2) || 2! || 2*1 -> 2
<br>
fact(3) || 3! || 3*2*1 -> 6
<br>
fact(4) || 4! || 4*3*2*1 -> 24
<br>
fact(5) || 5! || 5*4*3*2*1 -> 120
<br>
fact(6) || 6! || 6*5*4*3*2*1 -> 720
<br>
fact(7) || 7! || 7*6*5*4*3*2*1 -> 5040
<br>
fact(8) || 8! || 8*7*6*5*4*3*2*1 -> 40320
<br>
fact(9) || 9! || 9*8*7*6*5*4*3*2*1 -> 362880
<br>
fact(10) || 10! || 10*9*8*7*6*5*4*3*2*1 -> 3628800
<br>
fact(1e2) || 1e2! -> 9.332621544394418e+157
<br>
fact(1e3) || 1e3! -> Infinity
<br>
<span class="clear">fact(1e4) || 1e4! -> Infinity</span>
<br>
<span class="clear">fact(1e5) || 1e5! -> Infinity</span>
<br>
<span class="clear">fact(1e6) || 1e6! -> Infinity</span>
<br>
・順列permutation(n,k)
<br>
permut(3.3,1.6) || permut(3,1) || permutation(3,1) -> 3
<br>
permut(3i,1) || permut(0,1) -> 0
<br>
permut(3+3i,1) || permut(3,1) -> 3
<br>
permut(0,3) -> 0
<br>
<span class="jF">permut(-1,3) -> 0</span>
<br>
<span class="jF">permut(-1,0) -> 0</span>
<br>
<span class="jF">permut(0,-1) -> 0</span>
<br>
<span class="jF">permut(3,-1) -> 0</span>
<br>
<span class="condition">permut(0,0) -> 1</span>
<br>
permut(3,0) || 1 -> 1
<br>
permut(3,1) || 3 -> 3
<br>
permut(3,2) || 3*2 -> 6
<br>
permut(3,3) || 3*2*1 -> 6
<br>
permut(5,5) || 5*4*3*2*1 -> 120
<br>
permut(5,4) || 5*4*3*2 -> 120
<br>
permut(5,3) || 5*4*3 -> 60
<br>
permut(5,2) || 5*4 -> 20
<br>
permut(5,1) || 5 -> 5
<br>
permut(5,0) || 1 -> 1
<br>
<span class="jF">permut(5,-1) -> 0</span>
<br>
<span class="clear">permut(5) -> 0</span>
<br>
permut(1e2,1e2) || 1e2! -> 9.332621544394418e+157
<br>
permut(1e3,1e3) || 1e3! -> Infinity
<br>
<span class="clear">permut(1e4,1e4) || 1e4! -> Infinity</span>
<br>
<span class="clear">permut(1e5,1e5) || 1e5! -> Infinity</span>
<br>
<span class="clear">permut(1e6,1e6) || 1e6! -> Infinity</span>
<br>
・組合せcombination(n,r)
<br>
combin(3.3,1.6) || combin(3,1) || combination(3,1) -> 3
<br>
combin(3i,1) || combin(0,1) -> 0
<br>
combin(3+3i,1) || combin(3,1) -> 3
<br>
combin(0,3) -> 0
<br>
<span class="jF">combin(-1,3) -> 0</span>
<br>
<span class="jF">combin(-1,0) -> 0</span>
<br>
<span class="jF">combin(0,-1) -> 0</span>
<br>
<span class="jF">combin(3,-1) -> 0</span>
<br>
<span class="condition">combin(0,0) -> 1</span>
<br>
combin(3,0) || permut(3,0)/fact(0) || (1)/(1) -> 1
<br>
combin(3,1) || permut(3,1)/fact(1) || (3)/(1) -> 3
<br>
combin(3,2) || permut(3,2)/fact(2) || (3*2)/(2*1) -> 3
<br>
combin(3,3) || permut(3,3)/fact(3) || (3*2*1)/(3*2*1) -> 1
<br>
combin(5,5) || permut(5,5)/fact(5) || (5*4*3*2*1)/(5*4*3*2*1) -> 1
<br>
combin(5,4) || permut(5,4)/fact(4) || (5*4*3*2)/(4*3*2*1) -> 5
<br>
combin(5,3) || permut(5,3)/fact(3) || (5*4*3)/(3*2*1) -> 10
<br>
combin(5,2) || permut(5,2)/fact(2) || (5*4)/(2*1) -> 10
<br>
combin(5,1) || permut(5,1)/fact(1) || (5)/(1) -> 5
<br>
combin(5,0) || permut(5,0)/fact(0) || (1)/(1) -> 1
<br>
<span class="jF">combin(5,-1) -> 0</span>
<br>
permut(5,-1)/fact(-1) || (0)/(0) -> [MyErr]FN isNaN
<br>
<span class="clear">combin(5) -> 0</span>
<br>
combin(1e2,1e2) -> 1
<br>
・<a href="#span-out-com">複素数</a>演算の場合
<br>
permut(1e2,1e2)/fact(1e2)  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
9.332621544394418e+157/9.332621544394418e+157  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
permut(1e2,1e2)/fact(1e2)  <span class="selection">// OK</span> -> 1
<br>
9.332621544394418e+157/9.332621544394418e+157  <span class="selection">// OK</span> -> 1
<br>
combin(1e3,1e3) || Infinity/Infinity -> [MyErr]FN isNaN
<br>
<span class="clear">combin(1e4,1e4) || Infinity/Infinity -> [MyErr]FN isNaN</span>
<br>
<span class="clear">combin(1e5,1e5) || Infinity/Infinity -> [MyErr]FN isNaN</span>
<br>
<span class="clear">combin(1e6,1e6) || Infinity/Infinity -> [MyErr]FN isNaN</span>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
log関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-log"></span>
log関数の入力仕様と付随する留意事項について記述する
<br>
<br>
log関数の仕様はJavaScript準拠の自然対数とする
<br>
ln(e) || log(e) -> 1
<br>
ln(10) || ln10() -> 2.302585092994046
<br>
ln(2) || ln2() -> 0.6931471805599453
<br>
<br>
常用対数
<br>
log10(10) -> 1
<br>
x=10; log(x)log10e() -> 1
<br>
x=100; log(x)log10e() -> 2
<br>
<br>
Excel準拠の引数(値,底||10)は次のlog_exを使用する
<br>
log_ex(10) || log_ex(10,10) -> 1
<br>
log_ex(e) || log10e() -> 0.43429448190325176
<br>
log_ex(e,2) || log2e() -> 1.4426950408889634
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
atan2関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN-atan2"></span>
atan2関数の入力仕様と付随する留意事項について記述する
<br>
<br>
atan2関数の仕様はJavaScript準拠の引数(y,x)とする
<br>
atan2(1,0)/pi -> 0.5
<br>
deg_atan2(1,0) || degrees(atan2(1,0)) -> 90
<br>
<br>
<a href="#span-out-vars">変数</a>を使用
<br>
・実軸と虚軸の<a href="#span-out-com">複素数</a>平面から弧度数radに変換する場合
<br>
z=e^(i{pi/6}); atan2(imag(z),real(z)) -> 0.5235987755982987
<br>
z=e^(i{pi/6}); arg(z) -> 0.5235987755982987
<br>
・さらに、度数degに変換する場合
<br>
degrees(ans) || deg_atan2(imag(z),real(z)) -> 29.999999999999993
<br>
・再度、弧度数radに変換
<br>
radians(ans) -> 0.5235987755982987
<br>
<br>
Excel準拠の引数(x,y)は次のatan2_exを使用する
<br>
atan2_ex(0,1)/pi -> 0.5
<br>
deg_atan2_ex(0,1) || degrees(atan2_ex(0,1)) -> 90
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNspecial"></span>
特殊関数の入力仕様と付随する留意事項について記述する
<br>
<br>
特殊関数（非初等関数）は<a href="#span-out-eqns">式変数</a>と<a href="#span-out-FNh">高階関数</a>を使用して定義する
<br>
・標準正規分布SNDの区間確率P(x)
<br>
SND=&lt;exp(-t^2/2)/sqrt(2pi);
<br>
Px=&lt;_it(=&lt;SND,0,x)2;
<br>
・誤差関数erf(x)
<br>
erfx=&lt;_it(=&lt;SND,0,x(sqrt2))2;
<br>
・同義
<br>
erfx=&lt;_it(=&lt;{exp(-t^2)},0,x)(2/sqrt(pi));
<br>
・相補誤差関数erfc(x)
<br>
erfcx=&lt;1-erfx;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-mat"></span>
行列の入力仕様と付随する留意事項について記述する
<br>
<br>
vectorの入力方法2種類
<br>
・各vectorの要素はcomma,で区切る
<br>
行vector(1,2) || [1,2] -> (1,2)
<br>
列vector{1,3} -> (1:3)
<br>
<br>
2行2列の行列の入力方法
<br>
1　2
<br>
3　4
<br>
・各vectorはcolon:で区切る
<br>
(1,2:3,4) || [1,2:3,4] || {1,3:2,4} -> (1,2:3,4)
<br>
<br>
行vector列挙指定の行列（以降、行指定の行列と呼ぶ）
<br>
((1,2):(3,4)) -> (1,2:3,4)
<br>
((1:2):(3:4)) -> (1:2:3:4)
<br>
<br>
列vector列挙指定の行列（以降、列指定の行列と呼ぶ）
<br>
{{1,2}:{3,4}} || {1,2:3,4} -> (1,3:2,4)
<br>
{{1:2}:{3:4}} || {1:2:3:4} -> (1,2,3,4)
<br>
<br>
行指定の行列と列指定の行列は互いに<a href="#span-out-FNm-trans">転置の関係</a>
<br>
(1,2:3,4) -> (1,2:3,4)
<br>
{1,2:3,4} -> (1,3:2,4)
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
transpose({1,2:3,4}) || trans({1,2:3,4}) || trans{1,2:3,4} -> (1,2:3,4)
<br>
({1,2},{3:4}) || (trans(1,2),trans(3:4)) -> (1,3,4:2)
<br>
・1重列挙の場合、外側に<a href="#span-out-BT-associativity">括弧のassociativity</a>は存在しない
<br>
(1,2) || {(1,2)} || ({(1,2)}) || {({(1,2)})} -> (1,2)
<br>
{1,2} || ({1,2}) || {({1,2})} || ({({1,2})}) -> (1:2)
<br>
・多重列挙の場合、vectorを括る<a href="#span-out-BT-associativity">括弧のassociativity</a>に依存する
<br>
{(1,2),(3:4)} -> (1,2:3:4)
<br>
({1,2}:{3:4}) || (trans(1,2):trans(3:4)) -> (1:2:3,4)
<br>
{(1,2):(3:4)} -> (1,2,3:0,0,4)
<br>
(1,{2,(3,{4,5})}) -> (1,2:0,3,4:0,0,5)
<br>
(1,(2:3),4) -> (1,2,4:0,3)
<br>
(1,{2:3},4) -> (1,2,3,4)
<br>
{1,{2:3},4} -> (1:2,3:4)
<br>
{1,(2:3),4} -> (1:2:3:4)
<br>
<br>
定義可能な行列演算
<br>
・<a href="#span-out-mat-product">行列積</a>
<br>
・乗算記号*同様に積の記号*は省略可
<br>
(1,2:3,4)(1,2:3,4) -> (7,10:15,22)
<br>
・標準内積
<br>
(1,2,3){1,2,3} -> 14
<br>
・標準cross積
<br>
{1,2,3}(1,2,3) -> (1,2,3:2,4,6:3,6,9)
<br>
{1,2,3}(1,2) -> (1,2:2,4:3,6)
<br>
・Hermit内積
<br>
(1+i,1){1-i,1} -> 3
<br>
・Hermitian cross積
<br>
{1-i,1}(1+i,1) -> (2,1-i:1+i,1)
<br>
・空要素は0
<br>
(()) -> 0
<br>
(,) -> (0,0)
<br>
(2,:)(1,2:3,4) || (2,:,)(1,2:3,4) -> (2,4:0,0)
<br>
(1,2:3,4)(2,:) || (1,2:3,4)(2,:,) -> (2,0:6,0)
<br>
・抜け要素は0
<br>
(1,2,3:){1,2,3:} || (1,2,3:,,){1,2,3:,,} -> (14,0:0,0)
<br>
・単位行列
<br>
k=1; (k,:,k) -> (1,0:0,1)
<br>
・<a href="#span-out-FNm">Scalar行列</a>
<br>
k=-3; (k,:,k) -> (-3,0:0,-3)
<br>
・左右可換の<a href="#span-out-FNm">Scalar倍</a>（同sizeの<a href="#span-out-FNm">Scalar行列</a>との積）
<br>
k=-3; (k,:,k)(1,2:3,4) || (1,2:3,4)(k,:,k) -> (-3,-6:-9,-12)
<br>
k=-3; k(1,2:3,4)  <span class="selection">// NG</span> -> [MyErr]Invalid matrix operation
<br>
・符号
<br>
-(1,2:3,4) || (,:,)-(1,2:3,4) || (-1,:,-1)(1,2:3,4) -> (-1,-2:-3,-4)
<br>
・差
<br>
(1,2:3,4)-(1,2:3,4) -> (0,0:0,0)
<br>
・和
<br>
(1,2:3,4)+(1,2:3,4) -> (2,4:6,8)
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
x=1; y=(x,2x:3x,4x); y*y-y || (7,10:15,22)-(1,2:3,4) -> (6,8:12,18)
<br>
t=pi/4; (cos(t),sin(t):,){i(sin(t)),i(cos(t)):,} -> (i,0:0,0)
<br>
<br>
列指定のirregular行列
<br>
{1:2:3,4} -> (1,2,3:0,0,4)
<br>
{1:2,3} -> (1,2:0,3)
<br>
{1:2,,3} -> (1,2:0,0:0,3)
<br>
{1,2:3,,,4} -> (1,3:2,0:0,0:0,4)
<br>
{1,,,2:3,4:5,,,,,6} -> (1,3,5:0,4,0:0,0,0:2,0,0:0,0,0:0,0,6)
<br>
<br>
行指定のirregular行列
<br>
A=(11:21,22:31,32,33,34); A -> (11:21,22:31,32,33,34)
<br>
tA={11:21,22:31,32,33,34}; tA -> (11,21,31:0,22,32:0,0,33:0,0,34)
<br>
・行指定の行列で抜け要素がある場合、<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
A=(11:21,22:31,32,33,34); trans(trans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
A=(11:21,22:31,32,33,34); htrans(htrans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
・<a href="#span-in-tree">単位tree構造</a>の仕様上、行vectorの抜け要素を自動で埋めない
<br>
<br>
定義できない<a href="#span-out-mat-product">行列積</a>の場合、error終了
<br>
(1,2)(1,2) -> [MyErr]Invalid matrix operation
<br>
<br>
<a href="#span-out-FNm">行列size</a>の一致しない差と和の場合、error終了
<br>
(1,2:3,4)-(-1) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)-(-1,2) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)+(-1:) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)+(-1,2:,,) -> [MyErr]Invalid matrix operation
<br>
A=(1,2:); A[0]+A[1] -> [MyErr]Invalid matrix operation
<br>
A=(1,2:); ttA=trans(trans(A)); ttA[0]+ttA[1] -> (1,2)
<br>
A=(1,2:,); A[0]+A[1] -> (1,2)
<br>
<br>
抜け要素を埋めて<a href="#span-out-FNm">行列size</a>が一致する場合、差と和の演算を許容する
<br>
(1,2:3,4)-(-1,:) || (1,2:3,4)-(-1,:,) || (1,2:3,4)-(-1,0:0,0) -> (2,2:3,4)
<br>
(1,2:3,4)-(-1,2:) || (1,2:3,4)-(-1,2:,) || (1,2:3,4)-(-1,2:0,0) -> (2,0:3,4)
<br>
(1,2:3,4)+(-1,:) || (1,2:3,4)+(-1,:,) || (1,2:3,4)+(-1,0:0,0) -> (0,2:3,4)
<br>
(1,2:3,4)+(-1,2:) || (1,2:3,4)+(-1,2:,) || (1,2:3,4)+(-1,2:0,0) -> (0,4:3,4)
<br>
<br>
<a href="#span-out-ope">無次元</a>の演算の場合、行列の演算規則とは無関係に<a href="#span-out-FNm-last">最終要素</a>を演算する
<br>
(1,2:3)1 || (3)*1 -> 3
<br>
(1,2)/(3,4) || (2)/(4) -> 0.5
<br>
(1,2,3)+(4,5) || (3)+(5) -> 8
<br>
(1,2:3)-(4,5:6:7) || (3)-(7) -> -4
<br>
<br>
<span class="run">Ver.2.73.29</span>以降
<br>
定義できない行列演算の場合、<a href="#span-out-ope-extended">拡張行列演算</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数扱いの
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm0"></span>
定数扱いの行列の入力仕様と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-FN0">定数</a>同様に扱う行列を列挙する
<br>
vector2r || vector2r() -> (0,0)
<br>
vector3r -> (0,0,0)
<br>
vector4r -> (0,0,0,0)
<br>
vector2c -> (0:0)
<br>
vector3c -> (0:0:0)
<br>
vector4c -> (0:0:0:0)
<br>
zeros2 -> (0,0:0,0)
<br>
zeros3 -> (0,0,0:0,0,0:0,0,0)
<br>
zeros4 -> (0,0,0,0:0,0,0,0:0,0,0,0:0,0,0,0)
<br>
ones2 -> (1,1:1,1)
<br>
ones3 -> (1,1,1:1,1,1:1,1,1)
<br>
ones4 -> (1,1,1,1:1,1,1,1:1,1,1,1:1,1,1,1)
<br>
identity2 -> (1,0:0,1)
<br>
identity3 -> (1,0,0:0,1,0:0,0,1)
<br>
identity4 -> (1,0,0,0:0,1,0,0:0,0,1,0:0,0,0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm"></span>
行列関数の入力仕様と付随する留意事項について記述する
<br>
<br>
行vector
<br>
vectorr(3.3) || vectorr(3) || vector3r -> (0,0,0)
<br>
vectorr(6) -> (0,0,0,0,0,0)
<br>
vectorr(9) -> (0,0,0,0,0,0,0,0,0)
<br>
vectorr(0) || vectorr(-1) -> [MyErr]Invalid matrix size
<br>
vectorr(1001) -> [MyErr]Invalid matSizeMax over
<br>
<br>
列vector
<br>
vectorc(3) || vector3c -> (0:0:0)
<br>
vectorc(6) -> (0:0:0:0:0:0)
<br>
vectorc(9) -> (0:0:0:0:0:0:0:0:0)
<br>
<br>
単位行列
<br>
identity(3) -> (1,0,0:0,1,0:0,0,1)
<br>
identity(5) -> (1,0,0,0,0:0,1,0,0,0:0,0,1,0,0:0,0,0,1,0:0,0,0,0,1)
<br>
・行列sizeは正の整数にfloor
<br>
identity(3.3) || identity(3) -> (1,0,0:0,1,0:0,0,1)
<br>
・行列sizeが0以下の場合、error終了
<br>
identity(0) || identity(-1)  -> [MyErr]Invalid matrix size
<br>
・<a href="#span-in-options">内部option</a>のmatSizeMax既定値1000を超過の場合、error終了
<br>
identity(1001) -> [MyErr]Invalid matSizeMax over
<br>
・出力logの文字数制限log.length&lt;5000
<br>
identity(100) -> (1,0,0,...,0,0,0,...
<br>
・log表示負荷を下げる場合、変数に代入して<a href="#span-out-BT">括弧</a>で括る
<br>
(A=identity(100),A2=A*A) -> (0,0)
<br>
<br>
Scalar行列
<br>
scalars(2,-3) -> (-3,0:0,-3)
<br>
scalars(3,i) -> (i,0,0:0,i,0:0,0,i)
<br>
Scalars(4,3-5i) -> (3-5i,0,0,0:0,3-5i,0,0:0,0,3-5i,0:0,0,0,3-5i)
<br>
・任意size行列AのScalar倍
<br>
A=(1,2,3,4:5,6,7,8); scalars(sizer(A),2)*A || A*scalars(sizec(A),2) ->
<br>
(
<br>
2,4,6,8:
<br>
10,12,14,16
<br>
)
<br>
A={1,2,3,4:5,6,7,8}; scalars(sizer(A),2)*A || A*scalars(sizec(A),2) ->
<br>
(
<br>
2,10:
<br>
4,12:
<br>
6,14:
<br>
8,16
<br>
)
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
N=10; z=1+i; A=htrans(scalars(N,z))identity(N)scalars(N,z); A ||
<br>
N=10; z=1+i; A=scalars(N,z)identity(N)htrans(scalars(N,z)); A ->
<br>
(
<br>
2,0,0,0,0,0,0,0,0,0:
<br>
0,2,0,0,0,0,0,0,0,0:
<br>
0,0,2,0,0,0,0,0,0,0:
<br>
0,0,0,2,0,0,0,0,0,0:
<br>
0,0,0,0,2,0,0,0,0,0:
<br>
0,0,0,0,0,2,0,0,0,0:
<br>
0,0,0,0,0,0,2,0,0,0:
<br>
0,0,0,0,0,0,0,2,0,0:
<br>
0,0,0,0,0,0,0,0,2,0:
<br>
0,0,0,0,0,0,0,0,0,2
<br>
)
<br>
<br>
zeros行列
<br>
zeros(2,2) -> (0,0:0,0)
<br>
zeros(3,5) -> (0,0,0,0,0:0,0,0,0,0:0,0,0,0,0)
<br>
zeros(0,1) || zeros(-1,1)  -> [MyErr]Invalid matrix size
<br>
zeros(1001,1) -> [MyErr]Invalid matSizeMax over
<br>
<br>
ones行列
<br>
ones(2,2) -> (1,1:1,1)
<br>
ones(5,3) -> (1,1,1:1,1,1:1,1,1:1,1,1:1,1,1)
<br>
<br>
行列size（自動で抜け要素を埋める）
<br>
・行size
<br>
sizer(1,2:3,4) -> 2
<br>
sizer(1,2:3,4)[0] || sizer(1,2) -> 1
<br>
sizer(1:3,4) -> 2
<br>
sizer(1:3,4:) -> 3
<br>
・列size
<br>
size(1,2:3,4) || sizec(1,2:3,4) -> 2
<br>
sizec(1,2:3,4)[0] || sizec(1,2) -> 2
<br>
sizec(1,2:3) -> 2
<br>
sizec(1,2:3:4,5,) -> 3
<br>
・定義済み<a href="#span-out-vars">変数</a>を含まない場合
<br>
clear; sizer(a,b:c,d) || sizer(,:,) -> 2
<br>
clear; sizec(a,b:c,d) || sizec(,:,) -> 2
<br>
・定義済み<a href="#span-out-vars">変数</a>を含む場合
<br>
clear; A=(,:,); sizer(A,b:c,d) || sizer(A,:,) -> 3
<br>
clear; A=(,:,); sizec(A,b:c,d) || sizec(A,:,) -> 3
<br>
clear; A=(,:,); sizer(A,b:c,A) || sizer(A,:,A) -> 4
<br>
clear; A=(,:,); sizec(A,b:c,A) || sizec(A,:,A) -> 3
<br>
clear; A=(,:,); sizer(A,A:A,A) -> 4
<br>
clear; A=(,:,); sizec(A,A:A,A) -> 4
<br>
<br>
vectorの正規化
<br>
・行vectorを正規化する場合
<br>
vr=(1,i,-i); vr -> (1,i,-i)
<br>
normalizer(vr) ->
<br>
(0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・同義
<br>
・行vectorの左からnormの逆数を積
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
vr=(1,i,-i); (1/norm(trans(vr)))vr ->
<br>
(0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・列vectorを正規化する場合
<br>
vc={1,i,-i}; vc -> (1:i:-i)
<br>
normalize(vc) || normalizec(vc) -> 
<br>
(0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
・同義
<br>
・列vectorの右からnormの逆数を積
<br>
vc={1,i,-i}; vc(1/norm(vc)) ->
<br>
(0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
・行vectorを誤入力した場合
<br>
vr=(1,i,-i); normalizec(vr)  <span class="selection">// NG</span> -> (1,i,-i)
<br>
・zeros-vectorの場合
<br>
normalize({0,0,0})  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
<br>
行列の正規化（自動で抜け要素を埋める）
<br>
・すべての行vectorを正規化する場合
<br>
A=(1:1,i:1,i,-i); A -> (1:1,i:1,i,-i)
<br>
normalizer(A) ->
<br>
(1,0,0:
<br>
0.7071067811865475,0.7071067811865475i,0:
<br>
0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・各行vectorを<a href="#span-out-array">行列操作</a>で正規化する場合
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
(1/norm(trans(A[0])))A[0] -> 1
<br>
(1/norm(trans(A[1])))A[1]
<br>
-> (0.7071067811865475,0.7071067811865475i)
<br>
(1/norm(trans(A[2])))A[2]
<br>
-> (0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・すべての列vectorを正規化する場合
<br>
tA={1:1,i:1,i,-i}; tA -> (1,1,1:0,i,i:0,0,-i)
<br>
normalizec(tA) ->
<br>
(1,0.7071067811865475,0.5773502691896258:
<br>
0,0.7071067811865475i,0.5773502691896258i:
<br>
0,0,-0.5773502691896258i)
<br>
・各列vectorを<a href="#span-out-array">行列操作</a>で正規化する場合
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
tA={1:1,i:1,i,-i}; A=trans(tA); A -> (1,0,0:1,i,0:1,i,-i)
<br>
trans((1/norm(trans(A[0])))A[0]) -> (1:0:0)
<br>
trans((1/norm(trans(A[1])))A[1])
<br>
-> (0.7071067811865475:0.7071067811865475i:0)
<br>
trans((1/norm(trans(A[2])))A[2])
<br>
-> (0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
転置行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm-trans"></span>
転置行列関数の入力仕様と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-mat">行列</a>の転置
<br>
trans(1,2:3,4) -> (1,3:2,4)
<br>
・行vectorを列vectorに変換
<br>
transpose(1,2,3) || trans(1,2,3) -> (1:2:3)
<br>
・列vectorを行vectorに変換
<br>
trans({1,2,3}) || trans{1,2,3} -> (1,2,3)
<br>
<br>
<a href="#span-out-com">複素数</a>の<a href="#span-out-mat">行列</a>のHermit転置
<br>
htrans(1-i,1-2i:1-3i,1-4i) || Hermitian(1-i,1-2i:1-3i,1-4i) -> (1+i,1+3i:1+2i,1+4i)
<br>
<br>
列vectorのEuclidian norm（vectorの長さ）
<br>
norm(1:2:3) || norm{1,2,3} || norm({1,2,3}) -> 3.7416573867739413
<br>
norm(-i:2i:-3i) || norm{-i,2i,-3i} || norm({-i,2i,-3i}) -> 3.7416573867739413
<br>
norm((1-i)/sqrt2:2i:-3i) || norm({(1-i)/sqrt2,2i,-3i}) -> 3.7416573867739413
<br>
・<a href="#span-out-ope">有次元</a>の場合、同義
<br>
x={(1-i)/sqrt2,2i,-3i}; sqrt(htrans(x)x) -> 3.7416573867739413
<br>
・Hermit内積
<br>
x={(1-i)/sqrt2,2i,-3i}; htrans(x)x -> 14
<br>
・標準内積
<br>
x={(1-i)/sqrt2,2i,-3i}; trans(x)x -> -13-0.9999999999999998i
<br>
・よって<a href="#span-out-com">複素数</a>の場合、非同義
<br>
x={(1-i)/sqrt2,2i,-3i}; abs(sqrt(trans(x)x))  <span class="selection">// NG</span> -> 3.6108731368472777
<br>
・行vectorを誤入力した場合
<br>
norm((1-i)/sqrt2,2i,-3i) || norm(-3i)  <span class="selection">// NG</span> -> 3
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
last行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm-last"></span>
last行列関数の入力仕様と付随する留意事項について記述する
<br>
<br>
行列要素を取得
<br>
・最初要素（<a href="#span-out-mat">行列</a>の最初行の最初列の要素）
<br>
first(1,2:3,4) -> 1
<br>
first{1,2:3,4} -> 1
<br>
・最終要素（<a href="#span-out-mat">行列</a>の最終行の最終列の要素）
<br>
last(1,2:3,4) -> 4
<br>
last{1,2:3,4} -> 4
<br>
・<a href="#span-in-tree">単位tree構造</a>の仕様上、行vectorの抜け要素を自動で埋めない
<br>
A=(1,2:3,(,:,4),5); A ->
<br>
(
<br>
1,2:
<br>
3,0,0,5:
<br>
0,0,4
<br>
)
<br>
last(A) -> 4
<br>
last(trans(trans(A))) -> 0
<br>
<br>
last行列関数はNativeの<a href="#span-out-option4">comma演算子</a>同様に、<a href="#span-out-BT">括弧</a>内の最終要素を返す
<br>
・同じ<a href="#span-out-BT">括弧</a>でcomma,を括る場合
<br>
last((1,2):(3,4)) -> 4
<br>
last{{1,2}:{3,4}} -> 4
<br>
・colon:を含めて括る場合、意図とは異なる可能性
<br>
・最終列挙の要素が最終要素とは限らない
<br>
(1,(2:3),4) ->
<br>
(
<br>
1,2,4:
<br>
0,3
<br>
)
<br>
last(1,(2:3),4) -> 3
<br>
・<a href="#span-out-BT">括弧</a>を統一しない場合、意図とは異なる可能性
<br>
({1,2},3,4) ->
<br>
(
<br>
1,3,4:
<br>
2
<br>
)
<br>
last({1,2},3,4) -> 2
<br>
<br>
最終列挙の要素を取得する場合
<br>
・常にlast行列関数で<a href="#span-out-BT">括弧</a>内の最終要素を取り出す
<br>
last(1,last(2:3),4) -> 4
<br>
last(last{1,2},3,4) -> 4
<br>
last(last(last{1,2},3),4) -> 4
<br>
last(last(1,2),last(3,4)) -> 4
<br>
last(last(1,2),last(3:4)) -> 4
<br>
last(last(1,2),last{3:4}) -> 4
<br>
last(last{1,2},last(3:4)) -> 4
<br>
last(last{1,2},last{3:4}) -> 4
<br>
last(last{1,2}:last{3:4}) -> 4
<br>
・仕様上、<a href="#span-out-substitution">変数への代入</a>は次元を残さず、無次元の0を返す
<br>
(vc={1,2,3},vr=(1,2,3),norm(vc)) -> (0,0,3.7416573867739413)
<br>
last(ans) -> 3.7416573867739413
<br>
・次元を残した場合（参考）
<br>
({0,0,0},(0,0,0),1) -> (0,0,0,0,1:0:0)
<br>
(last{0,0,0},last(0,0,0),1) -> (0,0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列操作
<br>
入力仕様
    </th>
    <td>
<span id="span-out-array"></span>
行列操作の入力仕様と付随する留意事項について記述する
<br>
<br>
任意要素を取得
<br>
A=(1,2:3,4); A[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] -> 4
<br>
A=(1:1,i:1,i,-i); A[0][1] -> [MyErr]Invalid reference of array
<br>
・<a href="#span-out-eqns">式変数</a>を使用
<br>
clear; n=2; xn=&lt;(n,2n); xn[0][1] || (xn=&gt;)[0][1] -> 4
<br>
clear; n=2; xn=&lt;(n,2n); xn=&gt;[0][1] -> [MyErr]Invalid REe(=&gt;)
<br>
clear; n=2; xn=&lt;(n,2n)[0][1]; xn=&gt; -> 4
<br>
<br>
任意要素を演算
<br>
(1,2:3,4)[0][0]3 || 1*3 -> 3
<br>
(1)[0][0]3=(x=3) || 1*3=0 -> -3
<br>
<br>
行vectorを取得
<br>
A=(1,2:3,4); A[1] -> (3,4)
<br>
clear; (1,2:3,4)[x] -> [MyErr]Invalid REv(x)
<br>
<br>
列vectorを取得（<span class="run">Ver.2.76.29</span>以降、<a href="#span-out-BT-square-col">列参照</a>参照）
<br>
・<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
A=(1,2:3,4); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2:4)
<br>
A=(i,2i:3i,4i); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2i:4i)
<br>
trans((trans(1,2:3,4))[1]) || htrans((htrans(1,2:3,4))[1]) -> (2:4)
<br>
trans((trans(i,2i:3i,4i))[1]) || htrans((htrans(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
・<a href="#span-out-BT">括弧</a>は<a href="#span-out-FNm">関数</a>より優先するため、<a href="#span-out-FN">関数</a>の外側を上位の括弧で括る
<br>
A=(1,2:3,4); (trans(A))[1]  <span class="selection">// OK</span> -> (2,4)
<br>
(trans(1,2:3,4))[1]  <span class="selection">// OK</span> -> (2,4)
<br>
A=(1,2:3,4); trans(A)[1] || trans((A)[1])  <span class="selection">// NG</span> -> (3:4)
<br>
trans(1,2:3,4)[1] || trans((1,2:3,4)[1])  <span class="selection">// NG</span> -> (3:4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列への代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-mat"></span>
行列への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
行列への代入は<a href="#span-out-vars">変数</a>を使用する
<br>
・よって<a href="#span-out-substitution">変数への代入</a>に同義として扱う
<br>
<br>
定義済みの行列要素のみ代入可
<br>
・要素指定の代入
<br>
A=(1,2:3,4); A[0][0]=-1; A -> (-1,2:3,4)
<br>
A=(1,2:3,4); ii=1; A[ii][ii]=-1; A -> (1,2:3,-1)
<br>
A=(1,2:3,4); A[1][1]=(x=2); A -> (1,2:3,0)
<br>
・行列を代入した場合、<a href="#span-out-FNm-last">最終要素</a>を代入
<br>
A=(1,2:3,4); A[0][0]=A; A -> (4,2:3,4)
<br>
A=(1,2:3,4); A[1][1]=(x=2,-2x); A -> (1,2:3,-4)
<br>
・行指定の代入
<br>
A=(1,2:3,4); A[1]=A[0]; A -> (1,2:1,2)
<br>
A=(1,2:3,4); A[1]=-A[1]; A -> (1,2:-3,-4)
<br>
A=(1,2:3,4); A[1]=-2A[1]; A -> (1,2:-6,-8)
<br>
A=(1,2:3,4); A[1]=(,); A -> (1,2:0,0)
<br>
A=(1,2:3,4); w=A[1]; A[1]=A[0]; A[0]=w; A -> (3,4:1,2)
<br>
A=(1,2:); A[0]=A[1] -> [MyErr]Invalid store array
<br>
A=(1,2:); A[1]=A[0] -> [MyErr]Invalid store array
<br>
A=(1,2:); ttA=trans(trans(A)); ttA[0]=ttA[1]; ttA -> (0,0:0,0)
<br>
A=(1,2:); ttA=trans(trans(A)); ttA[1]=ttA[0]; ttA -> (1,2:1,2)
<br>
A=(1,2:,); A[0]=A[1]; A -> (0,0:0,0)
<br>
A=(1,2:,); A[1]=A[0]; A -> (1,2:1,2)
<br>
・行列を代入した場合、最終行vectorを代入
<br>
A=(1,2:3,4); A[0]=A; A -> (3,4:3,4)
<br>
A=(1,2:3,4); A[0]=(A:A(2,:,2)); A -> (6,8:3,4)
<br>
・列指定で代入する場合、<a href="#span-out-FNm-trans">転置行列関数</a>を使用（<span class="run">Ver.2.76.29</span>以降、<a href="#span-out-substitution-mat-col">列代入</a>参照）
<br>
A=(1,2:3,4); tA=trans(A); tA[0]=-tA[0]; A=trans(tA); A -> (-1,2:-3,4)
<br>
・<a href="#span-out-FNm">列size</a>の異なる代入不可
<br>
A=(1,2:3,4); A[1]=0 || A[1]=(1) || A[1]=(,,) || A[1]={,} -> [MyErr]Invalid store array
<br>
・未定義の行列要素への代入不可
<br>
A=(1,2:3,4); A[2]=A[1] -> [MyErr]Invalid reference of array
<br>
A=(1,2:3,4); A[1]=-1 -> [MyErr]Invalid store array
<br>
A=(1,2:3,4); A[2][0]=5 -> [MyErr]Invalid reference of array
<br>
A=(1,2:3,4); A[0.5][0]=-1 -> [MyErr]Invalid reference of array
<br>
・<a href="#span-out-eqns">式変数</a>への要素指定・行指定の代入不可
<br>
clear; A=&lt;(1,2:3,4); A[1][1]=0 -> [MyErr]Invalid SEv-scope(A)
<br>
clear; A=&lt;(1,2:3,4); A[1]=(,) -> [MyErr]Invalid SEv-scope(A)
<br>
clear; A=&lt;(1,2:3,4); (A=&gt;)[1][1]=0 || =0-4 -> -4
<br>
clear; A=&lt;(1,2:3,4); (A=&gt;)[1]=(,) || =(,)-(A=&gt;)[1] -> (-3,-4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-mat-row"></span>
行代入の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.78.31</span>以降、行列の<a href="#span-out-BT-square-row">行参照</a>と行代入の<span class="selection">反転機能</span>を追加
<br>
<br>
行指定の代入
<br>
・行vectorを代入する場合、<a href="#span-out-BT-square">列index</a>を省略する
<br>
A=(,:,); A[0]=(1,2); A -> (1,2:0,0)
<br>
A=(,:,); A[1]=(1,2); A -> (0,0:1,2)
<br>
・<a href="#span-out-BT-square-row">行参照</a>を使用
<br>
A=(1,2:3,4); A[0]=A[1]; A -> (3,4:3,4)
<br>
A=(1,2:3,4); A[1]=A[0]; A -> (1,2:1,2)
<br>
・抜け要素を自動で埋めない
<br>
A=(,:); A[0]=(1,2); A -> (1,2:0)
<br>
A=(:,); A[1]=(1,2); A -> (0:1,2)
<br>
・<a href="#span-out-BT-square">行index</a>が負の場合、<span class="selection">反転代入</span>を定義する
<br>
A=(,:,); A[<span class="selection">-1</span>]=(1,2); A -> (0,0:1,2)
<br>
A=(,:,); A[<span class="selection">-2</span>]=(1,2); A -> (1,2:0,0)
<br>
・未定義の行列要素の代入不可
<br>
A=(,:,); A[<span class="selection">-3</span>]=(1,2); A -> [MyErr]Invalid reference of array
<br>
A=(,:,); A[2]=(1,2); A -> [MyErr]Invalid reference of array
<br>
A=(,:,); A[0.3]=(1,2); A -> [MyErr]Invalid reference of array
<br>
・行列を代入した場合、最終行vectorを代入
<br>
A=(1,2:3,4); A[0]=A; A -> (3,4:3,4)
<br>
A=(1,2:3,4); A[1]=A; A -> (1,2:3,4)
<br>
A=(1,2:3,4); A[1]=trans(A); A -> (1,2:2,4)
<br>
・<a href="#span-out-FNm">列size</a>の異なる代入不可
<br>
A=(1,2:3,4); A[1]=1 -> [MyErr]Invalid store array
<br>
A=(1,2:3,4); A[1]=(,,) -> [MyErr]Invalid store array
<br>
A=(1,2:3,4); A[1]=(::) -> [MyErr]Invalid store array
<br>
A=(1,2:3); A[1]=0 -> (1,2:0)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
列代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-mat-col"></span>
列代入の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.76.29</span>以降、行列の<a href="#span-out-BT-square-col">列参照</a>と列代入を追加
<br>
・<span class="run">Ver.2.78.31</span>以降、行列の<a href="#span-out-BT-square-col">列参照</a>と列代入の<span class="selection">反転機能</span>を追加
<br>
<br>
列指定の代入
<br>
・列vectorを代入する場合、<a href="#span-out-BT-square">行index</a>に<span class="condition">負値</span>を指定する
<br>
A=(,:,); A[<span class="condition">-1</span>][0]={1,2}; A -> (1,0:2,0)
<br>
A=(,:,); A[<span class="condition">-1</span>][1]={1,2}; A -> (0,1:0,2)
<br>
・<a href="#span-out-BT-square-col">列参照</a>を使用
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][1]=A[-1][0]; A -> (1,1:3,3)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][1]=A[-1][1]; A -> (1,2:3,4)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][0]=A[-1][1]; A -> (2,2:4,4)
<br>
・自動で抜け要素を埋める
<br>
A=(:,); A[<span class="condition">-1</span>][1]={1,2}; A -> (0,1:0,2)
<br>
A=(:,:); A[<span class="condition">-1</span>][1]={1,2,3}; A -> (0,1:0,2:0,3)
<br>
A=(:,:); A[<span class="condition">-1</span>][0]={1,2,3}; A -> (1,0:2,0:3,0)
<br>
・同義
<br>
set_vectorc(A,ic,vc)=&lt;[tA=trans(A),tA[ic]=trans(vc),=&lt;trans(tA)]=&gt;;
<br>
A=(:,:); A=set_vectorc(=&lt;A,0,=&lt;{1,2,3}); A -> (1,0:2,0:3,0)
<br>
A=(:,:); A=set_vectorc(=&lt;A,1,=&lt;{1,2,3}); A -> (0,1:0,2:0,3)
<br>
・未定義の行列要素への代入不可
<br>
A=(:,:); A=set_vectorc(=&lt;A,2,=&lt;{1,2,3}); A -> [MyErr]Invalid reference of array
<br>
A=(:,:); A[<span class="condition">-1</span>][2]={1,2,3}; A -> [MyErr]Invalid reference of array(column)
<br>
A=(:,:); A[<span class="condition">-1</span>][0.3]={1,2,3}; A -> [MyErr]Invalid reference of array(column)
<br>
・行列を代入した場合、最終列vectorを代入
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][0]=A; A -> (2,2:4,4)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][0]=(A,A(2,:,2)); A -> (4,2:8,4)
<br>
・<a href="#span-out-FNm">行size</a>の異なる代入不可
<br>
A=(,:,); A[<span class="condition">-1</span>][0]=(1) -> [MyErr]Invalid store array(column)
<br>
A=(,:,); A[<span class="condition">-1</span>][0]=(1,2) -> [MyErr]Invalid store array(column)
<br>
A=(,:,); A[<span class="condition">-1</span>][0]={1,2,3} -> [MyErr]Invalid store array(column)
<br>
・<a href="#span-out-BT-square">列index</a>が負の場合、<span class="selection">反転代入</span>を定義する
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-1</span>]=A[-1][0]; A -> (1,1:3,3)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-1</span>]=A[-1][1]; A -> (1,2:3,4)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-2</span>]=A[-1][1]; A -> (2,2:4,4)
<br>
A=(1,2:3,4); A[<span class="condition">-1</span>][<span class="selection">-3</span>]=A[-1][1]; A -> [MyErr]Invalid reference of array(column)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
area代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-mat-area"></span>
area代入の入力仕様と付随する留意事項について記述する
<br>
<br>
<span class="run">Ver.2.77.30</span>以降、行列の<a href="#span-out-BT-square-area">area参照</a>とarea代入を追加
<br>
・<span class="clear">Ver.2.77.31</span>以降、<a href="#span-out-BT-square-area">開始行/列index</a>が非整数の場合、予期せぬerror終了を修正
<br>
・<span class="run">Ver.2.78.31</span>以降、<span class="selection">反転機能の有効範囲</span>を修正
<br>
<br>
area指定の代入
<br>
・自動で抜け要素を埋める
<br>
A=(1,2:3,4:); A=A; A -> (1,2:3,4:0)
<br>
A=(1,2:3,4:); ttA=trans(trans(A)); ttA -> (1,2:3,4:0,0)
<br>
A=(1,2:3,4:); A[0][0][0][0]=A; A -> (1,2:3,4:0,0)
<br>
A=(1,2:3,4:); A[0][0][sizer(A)][sizec(A)]=A; A -> (1,2:3,4:0,0)
<br>
・周期境界条件を適用
<br>
A=(1,2:3,4:); A[1][0][0][0]=A; A -> (0,0:1,2:3,4)
<br>
A=(1,2:3,4:); A[2][0][0][0]=A; A -> (3,4:0,0:1,2)
<br>
A=(1,2:3,4:); A[0][1][0][0]=A; A -> (2,1:4,3:0,0)
<br>
A=(1,2:3,4:); A[0][0][2][2]=A[1][1][2][2]; A -> (4,3:0,0:0,0)
<br>
A=(1,2:3,4:); A[1][1][2][2]=A[0][0][2][2]; A -> (1,2:2,1:4,3)
<br>
・未定義の行列要素への代入不可
<br>
A=(1,2:3,4:); A[3][0][0][0]=A; A -> [MyErr]Invalid reference of array(area)
<br>
A=(1,2:3,4:); A[0][2][0][0]=A; A -> [MyErr]Invalid reference of array(area)
<br>
<span class="clear">A=(1,2:3,4:); A[0.1][0][0][0]=A; A -> [MyErr]Invalid reference of array(area)</span>
<br>
<span class="clear">A=(1,2:3,4:); A[0][0.1][0][0]=A; A -> [MyErr]Invalid reference of array(area)</span>
<br>
A=(1,2:3,4:); A[0][0][0.1][0]=A; A -> [MyErr]Invalid reference of array(area)
<br>
A=(1,2:3,4:); A[0][0][0][0.1]=A; A -> [MyErr]Invalid reference of array(area)
<br>
A=(1,2:3,4:); A[0][0][5][5]=A; A -> [MyErr]Invalid reference of array(area)
<br>
A=(1,2:3,4:); A[0][0][2][2]=A; A -> [MyErr]Invalid store array(area)
<br>
・<a href="#span-out-BT-square-area">開始行/列index</a>が負の場合、<span class="selection">反転代入</span>を定義する
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][0][0]=A; A -> (0,0:4,3:2,1)
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][0][0][0]=A; A -> (0,0:3,4:1,2)
<br>
A=(1,2:3,4:); A[<span class="selection">-2</span>][0][0][0]=A; A -> (3,4:1,2:0,0)
<br>
<span class="selection">A=(1,2:3,4:); A[-3][0][0][0]=A; A -> (1,2:0,0:3,4)</span>
<br>
<span class="selection">A=(1,2:3,4:); A[-4][0][0][0]=A; A -> [MyErr]Invalid reference of array(area)</span>
<br>
A=(1,2:3,4:); A[0][<span class="selection">-1</span>][0][0]=A; A -> (2,1:4,3:0,0)
<br>
<span class="selection">A=(1,2:3,4:); A[0][-2][0][0]=A; A -> (1,2:3,4:0,0)</span>
<br>
<span class="selection">A=(1,2:3,4:); A[0][-3][0][0]=A; A -> [MyErr]Invalid reference of array(area)</span>
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][0][0]=A[-1][-1][0][0]; A -> (1,2:3,4:0,0)
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][2][2]=A[-1][-1][2][2]; A -> (1,2:3,4:0,0)
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][2][2]=A[0][0][2][2]; A -> (1,2:4,3:2,1)
<br>
A=(1,2:3,4:); A[<span class="selection">-1</span>][<span class="selection">-1</span>][2][2]=A[1][1][2][2]; A -> (1,2:0,0:3,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列結合
<br>
入力仕様
    </th>
    <td>
<span id="span-out-concatination"></span>
行列結合の入力仕様と付随する留意事項について記述する
<br>
<br>
vectorの結合
<br>
((1,2),(3,4)) -> (1,2,3,4)
<br>
x=(1,2); y=(3,4); (x,y) -> (1,2,3,4)
<br>
A=(1,2:3,4); (A[0],A[1]) -> (1,2,3,4)
<br>
(vector4c,vector4c,vector4c) -> (0,0,0:0,0,0:0,0,0:0,0,0)
<br>
・<a href="#span-out-SR">区切り文字</a>の左から順に結合する
<br>
((1,2),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4,},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
<br>
行列の結合
<br>
((1,2:5,6),(3,4:7,8):{-1,-5:-2,-6},{-3,-7:-4,-8})
<br>
-> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
<br>
(zeros2,zeros2:zeros2,zeros2) -> (0,0,0,0:0,0,0,0:0,0,0,0:0,0,0,0)
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
mat00=(1,2:5,6);
<br>
mat01=(3,4:7,8);
<br>
mat10={-1,-5:-2,-6};
<br>
mat11={-3,-7:-4,-8};
<br>
mat=(mat00,mat01:mat10,mat11);
<br>
mat -> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
<br>
・irregular行列
<br>
(1,2),{3,4:5:6,7:8} -> (1,2,3,5,6,8:0,0,4,0,7)
<br>
(1,2),{3,4:5:6,7:8,9,10} -> (1,2,3,5,6,8:0,0,4,0,7,9:0,0,0,0,0,10)
<br>
(1,2),{3,4:5:6,7:8,(9,10)} -> (1,2,3,5,6,8:0,0,4,0,7,9,10)
<br>
(1,(2,3):({4,5}),6,{7,8,(9,10)}) ->
<br>
(
<br>
1,2,3:
<br>
4,6,7:
<br>
5,0,8:
<br>
0,0,9,10
<br>
)
<br>
・複雑なnestingは意図とは異なる可能性
<br>
A=(1,{2,3,4,5},(6,7,{8,9}):({10,11}),12,{13,14,(15,16,{17,18})}); A ->
<br>
(
<br>
1,2,6,7,8:
<br>
0,3,0,0,9:
<br>
0,4:
<br>
0,5:
<br>
10,12,13:
<br>
11,0,14:
<br>
0,0,15,16,17:
<br>
0,0,0,0,18
<br>
)
<br>
ttA=trans(trans(A)); ttA ->
<br>
(
<br>
1,2,6,7,8:
<br>
0,3,0,0,9:
<br>
0,4,0,0,0:
<br>
0,5,0,0,0:
<br>
10,12,13,0,0:
<br>
11,0,14,0,0:
<br>
0,0,15,16,17:
<br>
0,0,0,0,18
<br>
)
<br>
A-ttA ->
<br>
(
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊
<br>
行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmspecial"></span>
特殊行列関数の入力仕様と付随する留意事項について記述する
<hr>
<br>
特殊行列関数は通常の<a href="#span-out-FNspecial">特殊関数</a>と異なり、特殊な演算仕様を意味する
<br>
・右手系をRHS(Right Handed System)と省略する
<br>
・左手系をLHS(Left Handed System)と省略する
<br>
<br>
回転行列
<br>
・3次元Euclid実空間の右手系直交座標系各軸周りの回転行列を演算して返す
<br>
・代数学に準ずる右手系直交座標系
<br>
　紙面x-y平面に対して鉛直上向きをz軸の正とする（左手系はその逆）
<br>
　x軸を親指、y軸を人差し指、z軸を中指とする
<br>
　回転方向は、x⇒y⇒z⇒x軸の正循環で各軸に向ける方向を正とする
<br>
・返値の回転行列は引数の<a href="#span-out-error">誤差情報</a>を継承しない
<br>
<br>
rotationx(第1引数)
<br>
rotationy(第1引数)
<br>
rotationz(第1引数)
<br>
・第1引数: Euler角の弧度数実数値radを値渡し
<br>
<br>
test caseを列挙する
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,-1:
<br>
0,1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(-pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,1:
<br>
0,-1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(pi/4) ->
<br>
(1.0000000000000002,0,1:
<br>
0,1.4142135623730951,0:
<br>
-1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(-pi/4) ->
<br>
(1.0000000000000002,0,-1:
<br>
0,1.4142135623730951,0:
<br>
1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(pi/4) ->
<br>
(1.0000000000000002,-1,0:
<br>
1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(-pi/4) ->
<br>
(1.0000000000000002,1,0:
<br>
-1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i; t
<br>
-> infoLost[ i] 0.7853981633974194+1000i+O(8e-13+8e-13i)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(t) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000289,-0.9999999999999711:
<br>
0,0.9999999999999711,1.0000000000000289)
<br>
<br>
回転行列の引数の<a href="#span-out-error">誤差情報</a>を継承する場合
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i;
<br>
rt=real(t); rt -> infoLost[ i] 0.7853981633974194+O(8e-13)
<br>
rotx=&lt;(1,0,0:0,cos(rt),-sin(rt):0,sin(rt),cos(rt));
<br>
rotx ->
<br>
(1,0,0:
<br>
0,infoLost[ i] 0.7071067811865679+O(6e-13),
<br>
infoLost[ i] -0.707106781186527+O(6e-13):
<br>
0,infoLost[ i] 0.707106781186527+O(6e-13),
<br>
infoLost[ i] 0.7071067811865679+O(6e-13))
<br>
・一続きにまとめる場合
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i;
<br>
rotx=&lt;{rt=real(t),=&lt;(1,0,0:0,cos(rt),-sin(rt):0,sin(rt),cos(rt))}=&gt;;
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotx ->
<br>
(1.4142135623730951,infoLost[ i] 0,infoLost[ i] 0:
<br>
0,infoLost[ i] 1.0000000000000289+O(8e-13),
<br>
infoLost[ i] -0.9999999999999711+O(8e-13):
<br>
0,infoLost[ i] 0.9999999999999711+O(8e-13),
<br>
infoLost[ i] 1.0000000000000289+O(8e-13))
<br>
<br>
回転行列を<a href="#span-out-eqns">式変数</a>で定義する場合
<br>
・各軸x/y/zに対するEuler角をphi/theta/psiとする
<br>
rotx=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),-sin(rt):,sin(rt),cos(rt))}=&gt;;
<br>
roty=&lt;{rt=real(theta),=&lt;(cos(rt),,sin(rt):,1,:-sin(rt),,cos(rt))}=&gt;;
<br>
rotz=&lt;{rt=real(psi),=&lt;(cos(rt),-sin(rt),:sin(rt),cos(rt),:,,1)}=&gt;;
<br>
phi=pi/5; rotx-rotationx(phi) -> (0,0,0:0,0,0:0,0,0)
<br>
theta=pi/5; roty-rotationy(theta) -> (0,0,0:0,0,0:0,0,0)
<br>
psi=pi/5; rotz-rotationz(psi) -> (0,0,0:0,0,0:0,0,0)
<br>
<br>
回転行列を一般化する場合
<br>
・関数を使用する場合
<br>
rotx=&lt;{rotationx(phi)};
<br>
roty=&lt;{rotationy(theta)};
<br>
rotz=&lt;{rotationz(psi)};
<br>
・<a href="#span-out-eqns">式変数</a>で定義する場合
<br>
rotx=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),-sin(rt):,sin(rt),cos(rt))}=&gt;;
<br>
roty=&lt;{rt=real(theta),=&lt;(cos(rt),,sin(rt):,1,:-sin(rt),,cos(rt))}=&gt;;
<br>
rotz=&lt;{rt=real(psi),=&lt;(cos(rt),-sin(rt),:sin(rt),cos(rt),:,,1)}=&gt;;
<br>
・一般化した回転行列rot_は対象行列matの左から演算する
<br>
mat_after=rot_*mat_before
<br>
・よって回転順序は回転行列並び順の逆順となる
<br>
・回転順序x⇒y⇒z
<br>
rot_zyx=&lt;{rotz*roty*rotx};
<br>
phi=pi/4; theta=3pi/4; psi=-3pi/4;
<br>
ans_zyx=rot_zyx; ans_zyx ->
<br>
(0.4999999999999999,0.14644660940672638,-0.8535533905932737:
<br>
0.5,-0.8535533905932737,0.14644660940672605:
<br>
-0.7071067811865476,-0.4999999999999999,-0.5)
<br>
・回転順序z⇒y⇒x
<br>
rot_xyz=&lt;{rotx*roty*rotz};
<br>
phi=-pi/4; theta=-3pi/4; psi=3pi/4;
<br>
ans_xyz=rot_xyz; ans_xyz ->
<br>
(0.4999999999999999,0.5,-0.7071067811865476:
<br>
0.14644660940672638,-0.8535533905932737,-0.4999999999999999:
<br>
-0.8535533905932737,0.14644660940672605,-0.5)
<br>
・回転の逆回転を順序通りに記憶して演算すると単位行列に戻る
<br>
rot_xyz*rot_zyx  <span class="selection">// NG</span> -> ...
<br>
ans_xyz*ans_zyx ->
<br>
(1,5.551115123125783e-17,5.551115123125783e-17:
<br>
5.551115123125783e-17,0.9999999999999999,0:
<br>
5.551115123125783e-17,0,0.9999999999999999)
<br>
ans_zyx*ans_xyz ->
<br>
(0.9999999999999999,0,-5.551115123125783e-17:
<br>
0,0.9999999999999999,-5.551115123125783e-17:
<br>
-5.551115123125783e-17,-5.551115123125783e-17,1)
<br>
・回転順序y⇒x⇒z
<br>
rot_zxy=&lt;{rotz*rotx*roty};
<br>
phi=pi/4; theta=3pi/4; psi=-3pi/4;
<br>
ans_zxy=rot_zxy; ans_zxy ->
<br>
(0.8535533905932737,0.5000000000000001,-0.14644660940672627:
<br>
0.14644660940672627,-0.5,-0.8535533905932737:
<br>
-0.5000000000000001,0.7071067811865475,-0.5)
<br>
・回転順序z⇒x⇒y
<br>
rot_yxz=&lt;{roty*rotx*rotz};
<br>
phi=-pi/4; theta=-3pi/4; psi=3pi/4;
<br>
ans_yxz=rot_yxz; ans_yxz ->
<br>
(0.8535533905932737,0.14644660940672627,-0.5000000000000001:
<br>
0.5000000000000001,-0.5,0.7071067811865475:
<br>
-0.14644660940672627,-0.8535533905932737,-0.5)
<br>
・同じく回転の逆回転を順序通りに記憶して演算すると単位行列に戻る
<br>
ans_yxz*ans_zxy ->
<br>
(1,5.551115123125783e-17,0:5.551115123125783e-17,1,0:0,0,1)
<br>
ans_zxy*ans_yxz ->
<br>
(1,0,-5.551115123125783e-17:0,1,0:-5.551115123125783e-17,0,1)
<br>
<br>
3D-graphicsで主流の左手系の場合
<br>
rotx_LHS=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),sin(rt):,-sin(rt),cos(rt))}=&gt;;
<br>
roty_LHS=&lt;{rt=real(theta),=&lt;(cos(rt),,-sin(rt):,1,:sin(rt),,cos(rt))}=&gt;;
<br>
rotz_LHS=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;;
<br>
・同義
<br>
rotx_LHS=&lt;{w=phi,phi=-phi,ret=rotx,phi=w,=&lt;ret}=&gt;;
<br>
roty_LHS=&lt;{w=theta,theta=-theta,ret=roty,theta=w,=&lt;ret}=&gt;;
<br>
rotz_LHS=&lt;{w=psi,psi=-psi,ret=rotz,psi=w,=&lt;ret}=&gt;;
<br>
・test caseを示す
<br>
phi=pi/4;
<br>
rotx ->
<br>
(
<br>
1,0,0:
<br>
0,0.7071067811865476,-0.7071067811865475:
<br>
0,0.7071067811865475,0.7071067811865476
<br>
)
<br>
rotx_LHS ->
<br>
(
<br>
1,0,0:
<br>
0,0.7071067811865476,0.7071067811865475:
<br>
0,-0.7071067811865475,0.7071067811865476
<br>
)
<br>
<br>
2DのHTML5描画canvasも同様にCSS/z-index含めて左手系
<br>
・browser左上originのclient座標系に対して手前方向をCSS/z-indexの正とする
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-vars"></span>
変数の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への代入・再代入方法は、変数名=代入値とする
<br>
x=2; x -> 2
<br>
x=2; x=4; x -> 4
<br>
x=2; x=2x; x -> 4
<br>
<br>
変数の命名規則を列挙する
<br>
・大文字と小文字を区別する
<br>
x=1; X=2; x+X -> 3
<br>
・変数名の後に続く数字は変数名に含まれる
<br>
x0=1; x1=2; x0+x1 -> 3
<br>
・binary文字の全角は半角に変換される
<br>
Ｘ＝３；X -> 3
<br>
・Multi-Byte文字を使用可
<br>
番号=1; 番号 -> 1
<br>
・<a href="#span-out-RW">予約語</a>は使用不可
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
・<span class="clear">Ver.2.27.15</span>以降、$から開始不可
<br>
$a=1 -> [MyErr]Invalid SEv($a)
<br>
$$a=1 -> [MyErr]Invalid SEv($$a)
<br>
・数字から開始不可
<br>
clear; 2x=4 -> [MyErr]Invalid ans isFound
<br>
・single||double quotation mark使用不可
<br>
' || " || '' || "" -> [MyErr]Invalid null string
<br>
"x"=2; "x" || x -> 2
<br>
""=2 || =2 -> 2
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数名
<br>
symbol
<br>
入力仕様
    </th>
    <td>
<span id="span-out-vars-symbol"></span>
変数名symbolの入力仕様と付随する留意事項について記述する
<br>
<br>
変数名symbolと表記するcaseを列挙する
<br>
・<a href="#span-out-plot2d-command">plot2d-command</a>の引数に変数名を渡す場合
<br>
・<a href="#span-out-FNc">最上位関数</a>の引数に変数名を渡す場合
<br>
・<a href="#span-out-FNh">高階関数</a>の引数に変数名を<a href="#span-out-call-by-equation">式渡し</a>で渡す場合
<br>
・<a href="#span-out-FNmh">高階行列関数</a>の引数に変数名を<a href="#span-out-call-by-equation">式渡し</a>で渡す場合
<br>
・<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>の代入する<a href="#span-out-eqns">式変数</a>に変数名を渡す場合
<br>
<br>
変数名symbolの<a href="#span-out-call-by-equation">式渡し</a>が不要なcaseを列挙する
<br>
・<a href="#span-out-BT">括弧</a>より関数優先の場合
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、すべての変数名symbolは<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
delVar($x) -> [MyErr]Invalid REv($x)
<br>
f(=&lt;$x)=&lt;x; f(=&lt;x) -> [MyErr]Invalid REv($x)
<br>
f(=&lt;x)=&lt;x; f(=&lt;$x) -> [MyErr]Invalid symbol($x)
<br>
Jacobi(=&lt;{2x^2},=&lt;{$x},=&lt;{1}) -> [MyErr]Invalid REv($x)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
予約変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-ans"></span>
予約変数の入力仕様と付随する留意事項について記述する
<br>
<br>
予約変数ans
<br>
・直前の実行文の演算結果を保持する
<br>
2; ans*2; ans*2; ans -> 8
<br>
2; (ans*2,ans*3); ans -> (4,6)
<br>
・<a href="#span-out-substitution">変数への代入</a>||<a href="#span-out-substitution-equation">式変数への式代入</a>の場合、ansは更新されない
<br>
2; x=3; ans -> 2
<br>
2; x=&lt;3; ans -> 2
<br>
・error終了の場合、ansは更新されない
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数への
<br>
代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution"></span>
変数への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への値の代入規則を列挙する
<br>
・代入する変数の左側に数値や演算子を置けない
<br>
clear; 2x=3 -> [MyErr]Invalid ans isFound
<br>
clear; 3+x=4 -> [MyErr]Invalid binary operation
<br>
・未定義変数の代入不可
<br>
clear; x=y(z) -> [MyErr]Invalid ans isFound
<br>
・このような場合、<a href="#span-out-eqns">式変数</a>を使用する
<br>
<br>
代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) -> 0
<br>
<br>
代入をcomma,||colon:で区切った場合、0を返す
<br>
clear; x=2,3x -> (0,6)
<br>
clear; x=2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
<br>
<br>
代入のnestingを許容する
<br>
clear; (a=(b=1),{c=2}) -> (0,0)
<br>
a,b,c -> (0,1,2)
<br>
clear; {a=((b=1),{c=2})}=(d=3)+1 -> 1
<br>
a,b,c,d -> (0,0,1,2,3)
<br>
clear; ({a=((b=1),{c=b+1})}=(d=c+1)+d) -> 3
<br>
a,b,c,d -> (0,0,1,2,3)
<br>
clear; d={a={(b=1),{c=2}}}; d -> 0
<br>
a,b,c,d -> (0,1,2,0:0)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列要素
<br>
pattern
<br>
matching
<br>
入力仕様
    </th>
    <td>
<span id="span-out-matching"></span>
行列要素pattern matchingの入力仕様と付随する留意事項について記述する
<br>
<br>
行列要素pattern matchingの定義
<br>
・<a href="#span-out-BT">括弧</a>のnestingを解決後、左辺と右辺の対応する各行列要素を比較
<br>
<br>
行列要素pattern matchingによる変数への値の代入規則を列挙する
<br>
・変数は無次元
<br>
・<a href="#span-out-vars-symbol">変数名symbol</a>を$でescapeして右辺||左辺の値を代入
<br>
clear; ($a,{$b,3})=(1,{2,$c}); (a,{b,c}) -> (1,2:0,3)
<br>
・再代入も同様
<br>
($a,$b)=1(1,2); (a,b) -> (1,2)
<br>
・代入に無関係の要素は変化しない
<br>
($a,(a,c))=(b,{$b,c},4); (a,{b,c}) -> (2,1:0,3)
<br>
<del>・変数$aが定義済みの場合、変数aへの代入不可
<br>
clear; $a=-1; ($a)=1 || (-1)=1 || =1-(-1) -> 2
<br>
clear; ($a)=1; a -> 1
</del><span class="clear">Ver.2.27.15</span>以降、<a href="#span-out-vars">変数の命名規則</a>で対策済み
<br>
・$でescapeしない場合、error終了
<br>
clear; (a)=1 -> [MyErr]Invalid REv(a)
<br>
・変数に代入する値が存在しない場合、error終了
<br>
clear; ($a,$b)=(1,$b) -> [MyErr]Invalid matching
<br>
clear; ($a,$b)=(1) -> [MyErr]Invalid matching(vars)
<br>
<del>・<a href="#span-out-substitution">変数への代入</a>と異なり、nesting不可
<br>
clear; ($a,(($b)=3))=(1,2) -> [MyErr]Invalid matching(vars)
</del><span class="run">Ver.2.29.15</span>以降、対応
<br>
・変数を含む演算不可
<br>
clear; ($a,2)=2(1,$b) -> [MyErr]Invalid FN operation
<br>
・<a href="#span-out-substitution">変数への代入</a>と判別される場合、左右交換不可
<br>
clear; c=&lt;(1,2); ($a,$b)=c; a,b -> (1,2)
<br>
clear; c=&lt;(1,2); c=($a,$b) -> [MyErr]Invalid REv($a)
<br>
・1重列挙の場合
<br>
clear; c=&lt;(1,2); (c)=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); {c}=($a,$b); a,b -> (1,2)
<br>
・2重列挙の場合
<br>
clear; c=&lt;(1,2); (c,)=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); (,c)=($a,$b); a,b -> (0,1)
<br>
clear; c=&lt;(1,2); {c,}=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); {,c}=($a,$b); a,b -> [MyErr]Invalid matching(vars)
<br>
・複数列挙の場合
<br>
clear; {($a,$b)=(1,2):($c,$d)=(3,4),(a,b,c,d)} -> (0,0:0,1,2,3,4)
<br>
・<a href="#span-out-RW">予約語</a>への代入不可
<br>
clear; $max || $$max || $$$max ->  [MyErr]Invalid max called
<br>
clear; ($max)=(2) -> [MyErr]Invalid max called
<br>
clear; ($$max)=(2) -> [MyErr]Invalid max called
<br>
clear; ($$$max)=(2) -> [MyErr]Invalid max called
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、代入のnestingを許容する
<br>
clear; ($a,(($b)=3))=(1,2); (a,b) -> (1,3)
<br>
clear; ($a,(($b,($c)=4)=3))=(1,2); (a,b,c) -> (1,3,4)
<br>
clear; ($a,(($b,($c)=4)=(,3)))=(1,2); (a,b,c) -> (1,0,4)
<br>
clear; ($a,(($b,($c)={,4})=(,3)))=(1,2); (a,b,c) -> (1,0,0)
<br>
<br>
<span class="clear">Ver.2.30.16</span>以降、<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
($$a)=1 -> [MyErr]Invalid SEv($a)
<br>
($$$a)=1 -> [MyErr]Invalid SEv($$a)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-eqns"></span>
式変数の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数への代入・再代入方法は、式変数名=&lt;方程式||関数式とする
<br>
・式変数への代入を以降、<a href="#span-out-substitution-equation">式代入</a>と呼ぶ
<br>
y=&lt;{a*x+b=0}; -> stored_eqn(y)
<br>
y=&lt;a*x+b=0; -> stored_eqn(y)
<br>
y=&lt;{a*x+b}; -> stored_eqn(y)
<br>
y=&lt;a*x+b; -> stored_eqn(y)
<br>
・null-rightの場合、error終了
<br>
=&lt; -> [MyErr]Invalid =&lt;null
<br>
・<span class="clear">Ver.2.27.15</span>以降、null代入不可
<br>
x=&lt;; x -> [MyErr]Invalid =&lt;null
<br>
・式変数は<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
$a=&lt;1 -> [MyErr]Invalid SEe($a)
<br>
$$a=&lt;1 -> [MyErr]Invalid SEe($$a)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式読出し
<br>
入力仕様
    </th>
    <td>
<span id="span-out-eqns-call"></span>
式読出しの入力仕様と付随する留意事項について記述する
<br>
<br>
式変数から値を読出す方法は、式変数名=&gt;とする
<br>
式変数から<a href="#span-out-vars">変数</a>に値代入する方法は、式変数名=&gt;変数名とする
<br>
・式変数からの値読出しを以降、式読出しと呼ぶ
<br>
y=&lt;a*x+b; y=&gt; -> [MyErr]Invalid binary operation
<br>
y=&lt;a*x+b; y=&gt;y0 -> [MyErr]Invalid binary operation
<br>
・<span class="clear">Ver.2.27.15</span>以降、null-leftの場合、error終了
<br>
=&gt; -> [MyErr]Invalid null=&gt;
<br>
<br>
<span class="run">Ver.2.31.17</span>以降、<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>の式読出し記号==&gt;を追加
<br>
<br>
関数式の<a href="#span-out-vars">変数</a>を定義して再度読出す
<br>
y=&lt;a*x+b; a=1; b=2; x=3; y=&gt; || 1*3+2 -> 5
<br>
y=&lt;a*x+b; a=1; b=2; x=3; y=&gt;y0; y0 -> 5
<br>
・式読出しを<a href="#span-out-BT">括弧</a>で括れば変数同様に扱える
<br>
2; y=&lt;ans; max(3,4(y=&gt;)2) || max(3,4*2*2) -> 16
<br>
2; y=&lt;ans; max(3,4(y=&gt;y0)2); y=&gt; -> 16
<br>
<br>
式変数と同名の変数が未定義の場合、直接、式読出し可
<br>
clear; y=&lt;a*x+b; a=1; b=2; x=3; 2y -> 10
<br>
clear; y=&lt;a*x+b; a=1; b=2; x=3; y0=2y; y0 -> 10
<br>
・ただし、式読出し記号=&gt;を明示する方が間違いが少ない
<br>
y=-1; y=&lt;a*x+b; a=1; b=2; x=3; 2y -> -2
<br>
y=-1; y=&lt;a*x+b; a=1; b=2; x=3; 2(y=&gt;) -> 10
<br>
・さらに、式変数名と変数名は区別する方が間違いが少ない
<br>
y=3; y=&lt;3y-1; 2y -> 6
<br>
y=3; y=&lt;3y-1; y=&gt;y; 2y -> 16
<br>
y0=3; y=&lt;3y0-1; y=&gt;y1; 2y1 -> 16
<br>
<br>
式変数名で明示して直接読出す方法もあり得る
<br>
clear; eqn_x=&lt;(a*x+b=0); a=1; b=2; x=3; 2eqn_x || 2*(-5) -> -10
<br>
<br>
以降、変数名と式変数名は被らない前提で式読出し記号=&gt;を省略する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式渡し
<br>
入力仕様
    </th>
    <td>
<span id="span-out-call-by-equation"></span>
式渡しの入力仕様と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-FN">関数</a>の引数に方程式||関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を渡す場合
<br>
・値||<a href="#span-out-vars-symbol">変数名symbol</a>の値渡しに対して式渡しと定義する
<br>
・この場合の関数を<a href="#span-out-FNh">高階関数</a>と定義する
<br>
<br>
式渡しの方法は、=&lt;方程式||関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>とする
<br>
・<a href="#span-out-substitution-equation">式代入</a>記号=&lt;を流用
<br>
・よって<a href="#span-out-substitution-equation">式代入</a>同等の<a href="#span-out-prec">演算のprecedence</a>
<br>
<br>
Native無名関数を代替する式渡しの直接式読出し
<br>
・Native無名関数(function(){return 3;})();の一例
<br>
(=&lt;3)=&gt; || {=&lt;3}=&gt; -> 3
<br>
(=&lt;{3})=&gt; || {=&lt;{3}}=&gt; -> 3
<br>
=&lt;3=&gt; || =&lt;(3)=&gt; || =&lt;{3}=&gt; -> [MyErr]Invalid BTe([object Object],[object Object])
<br>
3=&gt; || (3)=&gt; || {3}=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; a=3; a=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; a=3; (a)=&gt; || {a}=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; a=3; [a]=&gt; -> [MyErr]Invalid reference
<br>
・Native無名関数(function(){1; 2; return 3;})();の一例
<br>
(1,2,=&lt;3)=&gt; || {1,2,=&lt;3}=&gt; -> 3
<br>
(1,2,3)=&gt; || {1,2,3}=&gt; -> [MyErr]Invalid mat([object Object])
<br>
・Native無名関数(function(){var a=1, b=2, c=3; return [a,b,c];})();の一例
<br>
(a=1,b=2,c=3,=&lt;(a,b,c))=&gt; -> (1,2,3)
<br>
{a=1,b=2,c=3,=&lt;(a,b,c)}=&gt; -> (1,2,3)
<br>
・<a href="#span-out-FNm-last">last行列関数</a>は<a href="#span-out-FNm-last">最終要素</a>のみ取り出す
<br>
clear; (x=(1,2),=&lt;x)=&gt; -> (1,2)
<br>
clear; {x=(1,2:3,4),x=-x,=&lt;x}=&gt; -> (-1,-2:-3,-4)
<br>
clear; last(x=(1,2),x) -> 2
<br>
clear; last{x=(1,2:3,4),x=-x,x} -> -4
<br>
・式変数の場合も同様
<br>
clear; f=&lt;{x}; x=(1,2); f=&gt; -> (1,2)
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f)=&gt; -> (1,2)
<br>
clear; (f=&lt;{x},x=(1,2),f) -> (0,0,1,2)
<br>
clear; (f=&lt;{x},x=(1,2),f)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; last(f=&lt;{x},x=(1,2),f) -> 2
<br>
clear; last(f=&lt;{x},x=(1,2),=&lt;f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f=&lt;{x},x=(1,2),eqn_f=&lt;f); eqn_f -> (1,2)
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合、式変数の式読出し記号=&gt;省略不可
<br>
clear; a=1; (=&lt;a)=&gt; -> 1
<br>
clear; a=&lt;2; (=&lt;a)=&gt; -> [MyErr]Invalid REv(a)
<br>
clear; a=1; a=&lt;2; (=&lt;a)=&gt; -> 1
<br>
clear; a=1; a=&lt;2; (=&lt;a=&gt;)=&gt; -> 2
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f)=&gt; -> [MyErr]Invalid REv(f)
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f=&gt;)=&gt; -> (1,2)
<br>
clear; (f=&lt;x,x=(1,2),=&lt;f=&gt;)=&gt; -> (1,2)
<br>
clear; (f=&lt;x,x=&lt;(1,2),=&lt;f=&gt;)=&gt; -> [MyErr]Invalid REv(x)
<br>
clear; (f=&lt;x=&gt;,x=&lt;(1,2),=&lt;f=&gt;)=&gt; -> (1,2)
<br>
clear; (f=&lt;{x=&gt;},x=&lt;(1,2),=&lt;{f=&gt;})=&gt; -> (1,2)
<br>
clear; (f=&lt;{(x=&gt;)},x=&lt;(1,2),=&lt;{(f=&gt;)})=&gt; -> (1,2)
<br>
<br>
<span class="clear">Ver.2.27.15</span>以降、式渡しの直接式読出しのnestingに対応
<br>
clear; (f=&lt;{(x=&gt;)},x=&lt;(1,2),=&lt;{=&lt;{(f=&gt;)}}=&gt;)=&gt; -> (1,2)
<br>
・debug機能なしで無名関数の最短表記を許容
<br>
・(function(){return (function(){return (function(){return 3;})();})();})();
<br>
(=&lt;(=&lt;(=&lt;3)=&gt;)=&gt;)=&gt; -> 3
<br>
・(function(){return (function(){return (function(){return 3;})()+1;})()+2;})();
<br>
(=&lt;(=&lt;(=&lt;3)=&gt;+1)=&gt;+2)=&gt; -> 6
<br>
・var a=3; (function(){return (function(){return (function(){return a;})();})();})();
<br>
clear; a=3; (=&lt;(=&lt;(=&lt;{a})=&gt;)=&gt;)=&gt; -> 3
<br>
clear; a=&lt;3; (=&lt;(=&lt;(=&lt;{a=&gt;})=&gt;)=&gt;)=&gt; -> 3
<br>
・var a=[1,2]; (function(){1; return (function(){1; return (function(){1; return a;})();})();})();
<br>
clear; a=(1,2); (1,=&lt;(1,=&lt;(1,=&lt;{a})=&gt;)=&gt;)=&gt; -> (1,2)
<br>
clear; a=&lt;(1,2); (1,=&lt;(1,=&lt;(1,=&lt;{a=&gt;})=&gt;)=&gt;)=&gt; -> (1,2)
<br>
・(function(){return (function(){var a=1; return (function(){return 3;})()+a;})()*2;})();
<br>
clear; (=&lt;(=&lt;(a=1,=&lt;3)=&gt;+a)=&gt;*2)=&gt; -> 8
<br>
clear; (=&lt;(a=1,=&lt;(=&lt;3)=&gt;+a)=&gt;*2)=&gt; -> 8
<br>
clear; (a=1,=&lt;(=&lt;(=&lt;3)=&gt;+a)=&gt;*2)=&gt; -> 8
<br>
clear; a=1,(=&lt;(=&lt;(=&lt;3)=&gt;+a)=&gt;*2)=&gt; -> (0,8)
<br>
・(function(){var a=1; return (function(){return (function(){return 3;})()+1;})()*a;})();
<br>
clear; (=&lt;(=&lt;(a=1,=&lt;3)=&gt;+1)=&gt;*a)=&gt; -> 4
<br>
clear; (=&lt;(a=1,=&lt;(=&lt;3)=&gt;+1)=&gt;*a)=&gt; -> 4
<br>
clear; (a=1,=&lt;(=&lt;(=&lt;3)=&gt;+1)=&gt;*a)=&gt; -> 4
<br>
clear; a=1,(=&lt;(=&lt;(=&lt;3)=&gt;+1)=&gt;*a)=&gt; -> (0,4)
<br>
<br>
<span class="run">Ver.2.30.15</span>以降、<a href="#span-out-FN">関数</a>の引数に限定して、<a href="#span-out-substitution-equation">式代入</a>同様に、式渡しの仕様を緩和
<br>
・<a href="#span-out-FNh-SX">総和高階関数</a>を使用
<br>
・次の場合、<a href="#span-out-vars-symbol">式変数名symbol</a>と判別する
<br>
clear; _sn(=&lt;n,0,2) -> [MyErr]Invalid =&lt;Call-by-Equation
<br>
clear; n=1; _sn(=&lt;n,0,2) -> [MyErr]Invalid =&lt;Call-by-Equation
<br>
clear; n=&lt;n; _sn(=&lt;n,0,2) || 0+1+2 -> 3
<br>
・次の場合、dummy変数と判別する
<br>
clear; _sn(=&lt;{n},0,2) || 0+1+2 -> 3
<br>
clear; n=2; _sn(=&lt;{n},0,2) || 0+1+2 -> 3
<br>
・次の場合、<a href="#span-out-BT">括弧</a>省略と判別する
<br>
clear; _sn(=&lt;n+1,0,2) || _sn(=&lt;{n+1},0,2) || 1+2+3 -> 6
<br>
clear; n=&lt;n; _sn(=&lt;n=&gt;,0,2) || _sn(=&lt;{n=&gt;},0,2) || 0+1+2 -> 3
<br>
・次の場合、<a href="#span-out-BT">括弧</a>省略と判別する
<br>
clear; _sn(=&lt;1,0,2) || _sn(=&lt;{1},0,2) || 1+1+1 -> 3
<br>
<br>
本仕様は<a href="#span-out-BT">括弧</a>優先の<a href="#span-out-FNh">高階関数</a>の実装において必須
<br>
・引数が値渡しの場合、関数呼出し前に引数の演算を実行するが、
<br>
・引数が式渡しの場合、関数呼出しまで引数の演算を実行しない
<br>
<br>
実装の経緯
<br>
・当初、括弧より関数優先で式渡しの仕様はなかったが、
<br>
・式渡しの記号を明示した方が間違いが少ないと判断し、括弧優先で実装し直した
<br>
・さらに、Native無名関数の代替手段として流用した
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数への
<br>
式代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-equation"></span>
式変数への式代入の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数を循環参照した場合、error終了
<br>
・<a href="#span-out-FNh-RX">再帰高階関数</a>で代替のreccursive call非対応（call stackの独自実装なし）
<br>
clear; a=&lt;a; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a}; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;a=&gt;; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a=&gt;}; a -> [MyErr]Invalid circular(a)
<br>
・<a href="#span-out-config-strict">strict-mode</a>の場合
<br>
clear; a=&lt;a=&gt;; a=&gt; -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a=&gt;}; a=&gt; -> [MyErr]Invalid circular(a)
<br>
<br>
<span class="run">Ver.2.19.6</span>以降、<a href="#span-out-FN">関数</a>の参照渡しの仕様を廃止（無駄仕様と判断）
<br>
<del>
式変数名=&lt;関数名として<a href="#span-out-FN">関数</a>名を任意に変更可（参照渡しを模擬）
<br>
clear; tr=&lt;trans; tr(1,2:3,4) || (tr=&gt;)(1,2:3,4) -> (1,3:2,4)
<br>
clear; htr=&lt;htrans; htr((htr(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
clear; tr=&lt;trans; tr[2] -> [MyErr]Invalid FNm(transpose)
<br>
clear; trans=&lt;trans -> [MyErr]Invalid FNm(transpose)
<br>
・<a href="#span-out-FNh">高階関数</a>の場合
<br>
clear; d=&lt;_d -> [MyErr]Invalid FNh called
<br>
clear; dx=&lt;_dx; dx(=&lt;{x^2},1,2)
<br>
-> 3.999999999999929+3.5537737875913754e-14i+O(2e-11+1e-12i)
</del>
<br>
<br>
式代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=&lt;3) -> 0
<br>
<br>
式代入をcomma,||colon:で区切った場合、0を返す
<br>
clear; x=&lt;2,3x -> (0,6)
<br>
clear; x=&lt;2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
<br>
<br>
式変数を式代入可
<br>
・式読出し記号=&gt;を明示する場合
<br>
clear; eqn_x=&lt;3x; eqn_y=&lt;(eqn_x=&gt;); x=3; eqn_y=&gt; -> 9
<br>
clear; a=&lt;1; b=&lt;a=&gt;; b=&gt; -> 1
<br>
clear; a=&lt;1; b=&lt;a=&gt;; (b)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; a=&lt;1; b=&lt;a=&gt;; (=&lt;{b=&gt;})=&gt; -> 1
<br>
clear; a=&lt;1; b=&lt;a=&gt;; (=&lt;b=&gt;)=&gt; -> 1
<br>
clear; a=&lt;1; b=&lt;a=&gt;; =&lt;b=&gt; -> [MyErr]Invalid BTe([object Object],[object Object])
<br>
・同名の変数未定義の前提で式読出し記号=&gt;を省略する場合
<br>
clear; eqn_x=&lt;3x; eqn_y=&lt;eqn_x; x=3; eqn_y -> 9
<br>
clear; a=&lt;1; b=&lt;a; b -> 1
<br>
clear; a=&lt;1; b=&lt;a; (=&lt;b)=&gt; -> 1
<br>
<br>
式代入のnestingを一例に示す
<br>
・式変数aのみ定義される
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); b -> [MyErr]Invalid REv(b)
<br>
clear; (a=&lt;(b={c=2})); b -> [MyErr]Invalid REv(b)
<br>
・式変数aとbを順番に実行することで式変数cが定義される
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,c -> [MyErr]Invalid REv(c)
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,b -> (0,0)
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,b,c -> (0,0,2)
<br>
・式変数aを実行することで<a href="#span-out-vars">変数</a>bとcが定義される
<br>
clear; (a=&lt;(b={c=2})); a,c -> (0,2)
<br>
clear; (a=&lt;(b={c=2})); a,b -> (0,0)
<br>
clear; (a=&lt;(b={c=2})); a,b,c -> (0,0,2)
<br>
・以下、同様
<br>
clear; {a=&lt;((b=&lt;1),{c=&lt;2})}=(d=&lt;3)+1; a,b,c,d -> (0,0,1,2,3)
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)+d) -> [MyErr]Invalid binary operation
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)); d -> [MyErr]Invalid binary operation
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)); a,b,c,d -> (0,0,1,2,3)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; a -> [MyErr]Invalid REv(a)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,b -> [MyErr]Invalid REv(b)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,c -> [MyErr]Invalid REv(c)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,a,b,c -> (0,0,1,2:0,0)
<br>
<br>
応用例は<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh"></span>
高階関数を列挙する
<br>
・<a href="#span-out-FNh-switch">switch高階関数</a>
<br>
・<a href="#span-out-FNh-SX">総和高階関数</a>
<br>
・<a href="#span-out-FNh-PX">総乗・総積高階関数</a>
<br>
・<a href="#span-out-FNh-RX">再帰高階関数</a>
<br>
・<a href="#span-out-FNh-DX">微分高階関数</a>
<br>
・<a href="#span-out-FNh-IX">積分高階関数</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
switch
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-switch"></span>
switch高階関数
<br>
・任意個数の条件分岐による処理を実行する
<br>
・条件文と成立時に実行する処理を対にしてcolon:区切りで引数を渡す
<br>
・引数の左から順に条件文を判定する
<br>
・条件文が成立した場合、対の処理を実行して終了する
<br>
・条件文が不成立の場合、対の処理は実行されない
<br>
<br>
switch(第1引数,=&lt;第2引数:第3引数,=&lt;第4引数:...)
<br>
switch((第1引数,=&lt;第2引数):(第3引数,=&lt;第4引数):...)
<br>
switch({第1引数:=&lt;第2引数}:{第3引数:=&lt;第4引数}:...)
<br>
・引数
<br>
　・第奇数番引数: 0||not0の実数値を返す条件文を値渡し
<br>
　・第偶数番引数: 条件文成立時に実行する処理||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・返値
<br>
　条件文成立時: 対の処理の演算結果を返す
<br>
　全条件文不成立時: 0を返す
<br>
<br>
値を返す場合
<br>
switch(第1引数,第2引数:第3引数,第4引数:...)
<br>
・引数
<br>
　・第奇数番引数: 0||not0の実数値を返す条件文を値渡し
<br>
　・第偶数番引数: 条件文成立時の返却値を値渡し
<br>
・返値
<br>
　条件文成立時: 対の返却値を返す
<br>
　全条件文不成立時: 0を返す
<br>
<br>
Nativeのif文を一例に示す
<br>
if(x &gt;= 4) return 4;
<br>
else if(x &gt; 3) return 3;
<br>
else if(x &gt; 2) return 2;
<br>
else return -x;
<br>
・対の処理を値渡しで記述する場合
<br>
x=2; switch(x&gt;=4,4:x&gt;3,3:x&gt;2,2:1,-x) -> -2
<br>
x=2; switch(ge(x,4),4:gt(x,3),3:gt(x,2),2:1,-x) -> -2
<br>
・値渡しの場合、行列要素の演算を実行後、次の実行文を実行する
<br>
x=2; switch(0,4:0,3:0,2:1,-2) -> -2
<br>
・対の処理を<a href="#span-out-call-by-equation">式渡し</a>で記述する場合、条件文が成立したcaseのみ実行する
<br>
x=2; switch(x&gt;=4,=&lt;4:x&gt;3,=&lt;3:x&gt;2,=&lt;2:1,=&lt;{-x}) -> -2
<br>
x=2; switch(ge(x,4),=&lt;4:gt(x,3),=&lt;3:gt(x,2),=&lt;2:1,=&lt;{-x}) -> -2
<br>
<br>
Nativeの<a href="#span-out-type-ope">中置3項演算子</a>を一例に示す
<br>
var y = ((x &lt; 0)? -x: x);
<br>
・対の処理を値渡しで記述する場合
<br>
y=&lt;switch(x&lt;0,-x:1,x);
<br>
y=&lt;switch(lt(real(x),0),-real(x):1,real(x));
<br>
x=2; y -> 2
<br>
x=-2; y -> 2
<br>
・対の処理を<a href="#span-out-call-by-equation">式渡し</a>で記述する場合
<br>
y=&lt;switch(x&lt;0,=&lt;-x:1,=&lt;{x});
<br>
y=&lt;switch(lt(real(x),0),=&lt;-real(x):1,=&lt;real(x));
<br>
x=2; y -> 2
<br>
x=-2; y -> 2
<br>
・<a href="#span-out-eqns">式変数</a>を使用
<br>
cond_m=&lt;lt(real(x),0); proc_m=&lt;-real(x); cond_p=&lt;1; proc_p=&lt;real(x);
<br>
x=-2; (cond_m,proc_m:cond_p,proc_p) -> (1,2:1,-2)
<br>
x=-2; switch(cond_m,proc_m:cond_p,proc_p) -> 2
<br>
x=-2; (cond_m,=&lt;proc_m:cond_p,=&lt;proc_p) -> [MyErr]Invalid BTe([object Object])
<br>
x=-2; switch(cond_m,=&lt;proc_m:cond_p,=&lt;proc_p) -> 2
<br>
・<a href="#span-out-BT">丸括弧()</a>で<a href="#span-out-substitution">代入</a>・<a href="#span-out-substitution-equation">式代入</a>のnesting可（<a href="#span-out-BT">括弧</a>より優先の<a href="#span-out-FNc">最上位関数</a>を除く）
<br>
・対の処理を値渡しで記述する場合
<br>
cp_m=&lt;(cond_m,proc_m); cp_p=&lt;(cond_p,proc_p);
<br>
cp_mp=&lt;(cp_m:cp_p);
<br>
x=-2; (cp_mp) -> (1,2:1,-2)
<br>
x=-2; switch(cp_mp) -> 2
<br>
・対の処理を<a href="#span-out-call-by-equation">式渡し</a>で記述する場合
<br>
cp_m=&lt;(cond_m,=&lt;proc_m); cp_p=&lt;(cond_p,=&lt;proc_p);
<br>
cp_mp=&lt;(cp_m:cp_p);
<br>
x=-2; (cp_mp) -> [MyErr]Invalid BTe([object Object])
<br>
x=-2; switch(cp_mp) -> 2
<br>
<br>
<a href="#span-out-prec-ope-logical">論理演算子</a>を<a href="#span-out-prec-ope-bit">bit演算子</a>で代替する場合、<a href="#span-out-BT">括弧</a>を明示するか<a href="#span-out-FN-ope">関数</a>を使用する
<br>
・if(1==1 || 1==-1) return 1;
<br>
switch((1==1)|(1==-1),1) || switch(eq(1,1)|eq(1,-1),1) || switch(1|0,1) -> 1
<br>
・if(1==1 &amp;&amp; 1==-1) return 1;
<br>
switch((1==1)&amp;(1==-1),1) || switch(eq(1,1)&amp;eq(1,-1),1) || switch(1&amp;0,1) -> 0
<br>
・<span class="run">Ver.2.59.26</span>以降、<a href="#span-out-prec-ope-logical">論理演算子</a>を追加
<br>
switch(1==1||1==-1,1) || switch((1==1)||(1==-1),1) || switch(1||0,1) -> 1
<br>
switch(1==1&amp;&amp;1==-1,1) || switch((1==1)&amp;&amp;(1==-1),1) || switch(1&amp;&amp;0,1) -> 0
<br>
<br>
test caseを列挙する
<br>
switch(0) -> 0
<br>
switch(1) -> 0
<br>
switch(i) -> 0
<br>
switch(1,1) -> 1
<br>
switch(i,1) -> 0
<br>
switch(0,0:1,2:3,4) -> 2
<br>
switch(0,0:1i,2:3,4) -> 4
<br>
switch(0,0:real(1i),2:3,4) -> 4
<br>
switch(0,0:imag(1i),2:3,4) -> 2
<br>
switch(0,0:1(1-i),2:3,4) -> 2
<br>
switch(0,0:real(1(1-i)),2:3,4) -> 2
<br>
switch(0,0:imag(1(1-i)),2:3,4) -> 2
<br>
switch(1,=&lt;{1}) -> 1
<br>
switch(0:1,=&lt;{1}) -> 1
<br>
switch(0,0:1,=&lt;{1}) || switch((0,0):(1,=&lt;{1})) || switch({0:0}:{1:=&lt;{1}}) -> 1
<br>
switch(0,0,1,=&lt;{1})  <span class="selection">// NG</span> -> 0
<br>
switch(0,0:0,0:0,0:1,=&lt;{1}:1,=&lt;{2}) -> 1
<br>
clear; b=1; a=&lt;b=2; b=&lt;b; switch(0,a:1,=&lt;b) -> 2
<br>
clear; b=1; a=&lt;b=2; b=&lt;b; switch(1,=&lt;b:0,a) -> 2
<br>
clear; b=1; a=&lt;b=2; b=&lt;b; switch(1,=&lt;b:0,=&lt;a) -> 1
<br>
clear; b=1; a=&lt;b=2; b=&lt;b; switch(0,=&lt;a:1,=&lt;b) -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
総和
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-SX"></span>
総和高階関数
<br>
・任意関数のdummy変数整数範囲[a,b]の総和を演算して返す
<br>
・_sdummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_sdummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: dummy変数の範囲下限a（整数）を値渡し
<br>
・第3引数: dummy変数の範囲上限b（整数）を値渡し
<br>
option
<br>
・第4引数: dummy変数のstep（正の整数）を値渡し[省略時、1]
<br>
<br>
test caseを列挙する
<br>
・dummy変数n=1~10のnの総和
<br>
_sn(=&lt;{n},1,10) || 1+2+3+4+5+6+7+8+9+10 || (10+1)10/2 -> 55
<br>
・範囲反転を単なる逆順の演算で定義する
<br>
_Sn(=&lt;{n},10,1) || 10+9+8+7+6+5+4+3+2+1 -> 55
<br>
・dummy変数が負の場合も同様に定義する
<br>
_sn(=&lt;{n},-10,-1) || -10-9-8-7-6-5-4-3-2-1 -> -55
<br>
_Sn(=&lt;{n},-1,-10) || -1-2-3-4-5-6-7-8-9-10 -> -55
<br>
_Sn(=&lt;{n},1,-3) || 1+0-1-2-3 -> -5
<br>
・以降、dummy変数に0を含めて記述する
<br>
・step=2の場合
<br>
_sn(=&lt;{n},0,10,2) || 0+2+4+6+8+10 -> 30
<br>
_Sn(=&lt;{n},10,0,2) || 10+8+6+4+2+0 -> 30
<br>
_Sn(=&lt;{n},1,-3,2) || 1-1-3 -> -3
<br>
・step&lt;1の場合、暗黙で既定値に変換
<br>
_sn(=&lt;{n},0,10,0) || _sn(=&lt;{n},0,10,1) -> 55
<br>
・step&lt;0の場合、暗黙で絶対値に変換
<br>
_sn(=&lt;{n},0,10,-2) || _sn(=&lt;{n},0,10,2) -> 30
<br>
_Sn(=&lt;{n},10,0,-2) || _Sn(=&lt;{n},10,0,2) -> 30
<br>
・n=0~10の行列の総和
<br>
_sn(=&lt;{(n,2n:3n,4n)},N=2,5N) -> (55,110:165,220)
<br>
_Sn(=&lt;{(n,2n:3n,4n)},10,0) -> (55,110:165,220)
<br>
・2変数の多重総和
<br>
_sy(=&lt;{_sx(=&lt;{x+y},0,y)},0,2) || 0+1+2+2+3+4 -> 12
<br>
_Sy(=&lt;{_Sx(=&lt;{x+y},y,0)},2,0) || 4+3+2+2+1+0 -> 12
<br>
_sy(=&lt;{_Sx(=&lt;{x+y},y,0)},0,2) || 0+2+1+4+3+2 -> 12
<br>
_Sy(=&lt;{_sx(=&lt;{x+y},0,y)},2,0) || 0+2+3+4+1+2 -> 12
<br>
・総和を取るdummy変数はlocal変数から独立
<br>
x=-1; y=-2; _sy(=&lt;{_sx(=&lt;{x+y},0,y)},0,2); x+y -> -3
<br>
・<a href="#span-out-FNh">高階関数</a>の引数も<a href="#span-out-FN">関数</a>同様に最終行vectorの左から順に参照
<br>
_sn(,is=0,:,ie=10,:=&lt;{n},is,ie) -> 55
<br>
・dummy変数は<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
_smax(=&lt;{0},1,2) -> [MyErr]Invalid max called
<br>
_spi(=&lt;{0},1,2) -> [MyErr]Invalid pi called
<br>
_s3(=&lt;{0},1,2) -> [MyErr]Invalid 3 called
<br>
_s3n(=&lt;{0},1,2) -> [MyErr]Invalid FNh called
<br>
・<span class="run">Ver.2.29.15</span>以降
<br>
_s$n(=&lt;{0},1,2) -> [MyErr]Invalid dummy($n)
<br>
_s$$n(=&lt;{0},1,2) -> [MyErr]Invalid dummy($$n)
<br>
<br>
応用例を示す
<br>
・1回試行で当たりの確率をPb[%]とする
<br>
・10回試行中、n回当たりの確率Pn[%]を<a href="#span-out-eqns">式変数</a>で定義する
<br>
storage cleared
<br>
Pb=3; Pn=&lt;{100combin(10,n)(Pb/100)^n((100-Pb)/100)^(10-n)};
<br>
n=0; Pn -> 73.74241268949281
<br>
n=1; Pn -> 22.806931759636946
<br>
n=2; Pn -> 3.1741606057226677
<br>
n=3; Pn -> 0.2617864417090862
<br>
n=4; Pn -> 0.014168853803842281
<br>
n=5; Pn -> 0.0005258543679776511
<br>
n=6; Pn -> 0.000013552947628290013
<br>
n=7; Pn -> 2.3952190212e-7
<br>
n=8; Pn -> 2.7779602049999973e-9
<br>
n=9; Pn -> 1.909250999999996e-11
<br>
n=10; Pn -> 5.904899999999982e-14
<br>
・10回試行中、N回以上当たりの確率[%]
<br>
N=10; _sn(=&lt;Pn,N,10) || 100(Pb/100)^N -> 5.904899999999982e-14
<br>
N=9; _sn(=&lt;Pn,N,10) -> 1.9151558999999963e-11
<br>
N=8; _sn(=&lt;Pn,N,10) -> 2.7971117639999973e-9
<br>
N=7; _sn(=&lt;Pn,N,10) -> 2.42319013884e-7
<br>
N=6; _sn(=&lt;Pn,N,10) -> 0.000013795266642174013
<br>
N=5; _sn(=&lt;Pn,N,10) -> 0.0005396496346198251
<br>
N=4; _sn(=&lt;Pn,N,10) -> 0.014708503438462106
<br>
N=3; _sn(=&lt;Pn,N,10) -> 0.27649494514754835
<br>
N=2; _sn(=&lt;Pn,N,10) -> 3.4506555508702164
<br>
N=1; _sn(=&lt;Pn,N,10) -> 26.257587310507166
<br>
N=0; _sn(=&lt;Pn,N,10) -> 99.99999999999999
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
総乗・総積
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-PX"></span>
総乗・総積高階関数
<br>
・任意関数のdummy変数整数範囲[a,b]の総乗・総積を演算して返す
<br>
・_pdummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_pdummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: dummy変数の範囲下限a（整数）を値渡し
<br>
・第3引数: dummy変数の範囲上限b（整数）を値渡し
<br>
option
<br>
・第4引数: dummy変数のstep（正の整数）を値渡し[省略時、1]
<br>
<br>
test caseを列挙する
<br>
・dummy変数n=1~10のnの総乗
<br>
_pn(=&lt;{n},1,10) || 1*2*3*4*5*6*7*8*9*10 -> 3628800
<br>
・範囲反転を単なる逆順の演算で定義する
<br>
_Pn(=&lt;{n},10,1) || 10*9*8*7*6*5*4*3*2*1 -> 3628800
<br>
・dummy変数が負の場合も同様に定義する
<br>
_pn(=&lt;{n},-3,-1) || (-3)(-2)(-1) -> -6
<br>
_Pn(=&lt;{n},-1,-3) || (-1)(-2)(-3) -> -6
<br>
_Pn(=&lt;{n},1,-3) || (1)(0)(-1)(-2)(-3) -> 0
<br>
・step=2の場合
<br>
_pn(=&lt;{n},1,10,2) || 1*3*5*7*9 || 9!! -> 945
<br>
_Pn(=&lt;{n},10,1,2) || 10*8*6*4*2 || 10!! -> 3840
<br>
_Pn(=&lt;{n},1,-3,2) || (1)(-1)(-3) -> 3
<br>
・step=3の場合
<br>
_pn(=&lt;{n},1,2,3) || 1 -> 1
<br>
_Pn(=&lt;{n},2,1,3) || 2 || 2!!! -> 2
<br>
・n=1~2の行列の総積
<br>
An=&lt;(n,2n:3n,4n); _pn(=&lt;{An},1,2) || (1,2:3,4)(2,4:6,8) -> (14,20:30,44)
<br>
An=&lt;(n,2n:3n,4n); _Pn(=&lt;{An},2,1) || (2,4:6,8)(1,2:3,4) -> (14,20:30,44)
<br>
・2変数の多重総乗
<br>
_py(=&lt;{_px(=&lt;{(x*y)},1,y)},1,3) || (1*1)(1*2)(2*2)(1*3)(2*3)(3*3) -> 1296
<br>
_Py(=&lt;{_Px(=&lt;{(x*y)},y,1)},3,1) || (3*3)(2*3)(1*3)(2*2)(1*2)(1*1) -> 1296
<br>
_py(=&lt;{_Px(=&lt;{(x*y)},y,1)},1,3) || (1*1)(2*2)(1*2)(3*3)(2*3)(1*3) -> 1296
<br>
_Py(=&lt;{_px(=&lt;{(x*y)},1,y)},3,1) || (1*3)(2*3)(3*3)(1*2)(2*2)(1*1) -> 1296
<br>
・任意行列Aの累乗
<br>
A=(1,2:3,4); N=2; _pn(=&lt;{A},1,N) -> (7,10:15,22)
<br>
A=(1,2:3,4); N=5; _pn(=&lt;{A},1,N) -> (1069,1558:2337,3406)
<br>
A=(1,2:3,4); N=5; _pn(=&lt;{trans(A)},1,N) -> (1069,2337:1558,3406)
<br>
・<a href="#span-out-com">複素数</a>の任意行列cAの累乗
<br>
cA=(e^{i(pi/4)},:,e^{i(-pi/4)}); N=4; _pn(=&lt;{cA},1,N)
<br>
-> (-1+2.7755575615628914e-16i,0:0,-1-2.7755575615628914e-16i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
再帰
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-RX"></span>
再帰高階関数
<br>
・任意処理の演算結果をdummy変数に代入する操作を再帰回数繰り返す
<br>
・最後の演算結果を返す
<br>
・_rdummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_rdummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数,第2引数,第3引数[,=&lt;第4引数])
<br>
・第1引数: 任意処理||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: dummy変数の初期値を値渡し
<br>
・第3引数: 再帰回数（正の整数）を値渡し
<br>
option
<br>
<span class="run">Ver.2.30.15</span>以降、第4引数追加
<br>
・第4引数: 再帰処理をbreakする条件（not0でbreak）を<a href="#span-out-call-by-equation">式渡し</a>[省略時、break判定なし]
<br>
<br>
test caseを列挙する
<br>
・再帰回数が0以下の場合、初期値を返す
<br>
・加算の漸化式
<br>
_rn(=&lt;{n+1},,0) -> 0
<br>
_rn(=&lt;{n+1},,1) -> 1
<br>
_rn(=&lt;{n+1},,2) -> 2
<br>
・同義
<br>
Pn=0; _rn(=&lt;{Pn=Pn+1},0,2); Pn -> 2
<br>
_rn(=&lt;{Pn=Pn+1},Pn=0,2); Pn -> 2
<br>
・初期値未定義の場合、error終了
<br>
clear; _rn(=&lt;{Pn=Pn+1},,2); Pn -> [MyErr]Invalid binary operation
<br>
・非同義（<a href="#span-out-substitution">変数への代入</a>は0が返る）
<br>
clear; _rn(=&lt;{n=n+1},,2)  <span class="selection">// NG</span> -> 0
<br>
clear; _rn(=&lt;{n=n+1},,2); n -> [MyErr]Invalid REv(n)
<br>
clear; _rn(=&lt;{n=n+1},n=0,2); n -> 0
<br>
・乗算の漸化式
<br>
_rn(=&lt;{n*2},1,0) -> 1
<br>
_rn(=&lt;{n*2},1,1) || 2^1 -> 2
<br>
_rn(=&lt;{n*2},1,2) || 2^2 -> 4
<br>
_rn(=&lt;{n*2},1,3) || 2^3 -> 8
<br>
・同義
<br>
Pn=1; _rn(=&lt;{Pn=Pn*2},0,3); Pn -> 8
<br>
_rn(=&lt;{Pn=Pn*2},Pn=1,3); Pn -> 8
<br>
・任意行列Aの累乗
<br>
An=(1,:,1); A=(1,2:3,4); N=2; _rn(=&lt;{An=An*A},,N); An -> (7,10:15,22)
<br>
_rn(=&lt;{An=An*(1,2:3,4)},An=(1,:,1),5); An -> (1069,1558:2337,3406)
<br>
・2変数の多重再帰
<br>
_ry(=&lt;{_rx(=&lt;{x+y},1,2)},1,2) || (1+(3))+3<span class="selection">/*(x)+y*/</span> -> 7
<br>
_Ry(=&lt;{_Rx(=&lt;{x+y+1},1,2)},1,2) -> 13
<br>
<br>
<span class="run">Ver.2.30.15</span>以降、第4引数追加
<br>
・第4引数で再帰処理のbreak条件を指定可
<br>
・本来、Maximum call stack sizeの制限O(10000~1000000)を受けるが、
<br>
・単なるfor-loopのため、再帰回数とbreak条件以外の制限はない
<br>
・test caseを列挙する
<br>
_rn(=&lt;{n+1},,100,=&lt;1) -> 1
<br>
_rn(=&lt;{n+1},,100,=&lt;{n&gt;=50}) -> 51
<br>
_rn(=&lt;{n+1},,1000000,=&lt;{n&gt;=500000}) -> 500001
<br>
_rn(=&lt;{Pn=Pn+1},Pn=0,100,=&lt;{Pn&gt;=50}); Pn -> 50
<br>
_rn(=&lt;{Pn=Pn+1},Pn=0,100,=&lt;{n&gt;=50}); Pn -> 100
<br>
_rn(=&lt;{last{Pn=Pn+1,Pn}},Pn=0,100,=&lt;{n&gt;=50}); Pn -> 51
<br>
_rn(=&lt;{Pn=Pn*2},Pn=1,10,=&lt;{Pn>100}); Pn -> 128
<br>
_rn(=&lt;{last{Pn=Pn*2,n+1}},Pn=1,10,=&lt;{Pn>100}) -> 7
<br>
_ry(=&lt;{_rx(=&lt;{x+y},1,2,=&lt;{y==1})},1,2) || (1+(2))+2<span class="selection">/*(x)+y*/</span> -> 5
<br>
<br>
<a href="#span-out-FN-fact">階乗</a>の一例10!=3628800を示す
<br>
・n=10を初期値に設定
<br>
・Pn=1を初期値とする漸化式last{Pn=Pn*n,n-1}を設定
<br>
・一般的な再帰回数上限値1e6を設定
<br>
・break条件にn==1を設定
<br>
_rn(=&lt;{last{Pn=Pn*n,n-1}},last(Pn=1,10),1e6,=&lt;{n==1}),Pn -> (0,3628800)
<br>
・Pn=Pn*1の演算後、n-1して0が返る
<br>
・自明の演算Pn=Pn*1を除く場合、break条件にn==2を設定
<br>
_rn(=&lt;{last{Pn=Pn*n,n-1}},last(Pn=1,10),1e6,=&lt;{n==2}),Pn -> (1,3628800)
<br>
・同様に、Pn=Pn*2の演算後、n-1して1が返る
<br>
<br>
応用例を示す
<br>
・<a href="#span-out-non-linear">非線形方程式の解法</a>を使用
<br>
・絶対誤差指定で収束判定条件を設定する場合
<br>
clear;
<br>
run=&lt;last{mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1})};
<br>
_rn(=&lt;run,Nmax=10,Nmax,=&lt;{norm(mdx)&lt;1e-3});
<br>
norm(mdx) -> 2.0548659974995737e-10
<br>
clear;
<br>
run=&lt;last{mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1})};
<br>
_rn(=&lt;run,Nmax=10,Nmax,=&lt;{norm(mdx)&lt;1e-12});
<br>
norm(mdx) -> infoLost[ri] 2.2204460494935903e-15
<br>
・相対誤差指定で収束判定条件を設定する場合
<br>
clear;
<br>
run=&lt;last{mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1})};
<br>
_rn(=&lt;run,Nmax=10,Nmax,=&lt;{norm(mdx)/norm({x0,x1})&lt;1e-3});
<br>
norm(mdx) -> 2.0548659974995737e-10
<br>
norm(mdx)/norm({x0,x1}) -> 3.4129466559497216e-11
<br>
clear;
<br>
run=&lt;last{mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1})};
<br>
_rn(=&lt;run,Nmax=10,Nmax,=&lt;{norm(mdx)/norm({x0,x1})&lt;1e-12});
<br>
norm(mdx) -> infoLost[ri] 2.2204460494935903e-15
<br>
norm(mdx)/norm({x0,x1}) -> infoLost[ri] 3.6879601533907295e-16
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
微分
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-DX"></span>
微分高階関数
<br>
・連続関数のdummy変数微分位置における微分係数を数値的に演算して返す
<br>
・精度優先で微分位置に応じた<a href="#span-out-error">情報落ち</a>を対策する
<br>
・<a href="#span-out-error-numerical">数値誤差</a>O(dx^4以上)を含み、演算結果に<a href="#span-out-error-numerical">目安の解析誤差</a>を表示する
<br>
・1階微分の差分刻み実数値dxD既定値dxD=1e-3
<br>
・微分位置xでの差分刻みdx既定値dx=max(1,abs(x))dxD(1+i)
<br>
・_ddummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照するが、上書きしない
<br>
<br>
_ddummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数[,第2引数[,第3引数[,第4引数]]])
<br>
・第1引数: dummy変数の関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
option
<br>
・第2引数: 微分階数Ndash（正の整数）を値渡し[省略時、1]
<br>
・第3引数: 微分位置aを値渡し[省略時、local変数を参照]
<br>
・第4引数: 1階微分の差分刻みdx0を値渡し[0||省略時、dx既定値]
<br>
<br>
<a href="#span-out-error-numerical">数値誤差</a>に関する精度次数について記述する
<br>
・<a href="#span-out-error-numerical">数値誤差</a>は絶対誤差
<br>
・微分階数が1階上がる毎に差分刻み2倍を仮定
<br>
　stencilに応じたdx=dx0*2^(Ndash-1)
<br>
・微分階数が2階までは中心差分法による4次精度以下
<br>
・微分階数が3階以降は中心差分法による2次精度以下
<br>
<br>
詳細は<a href="#span-out-fdm-differential">微分の数値解法</a>参照
<br>
<br>
test caseを列挙する
<br>
・f(x)=(x+i)^5のx=1における微分を示す
<br>
x=1; dxD=1e-3; dx=max(1,abs(x))dxD(1+i); f=&lt;{(x+i)^5} -> stored_eqn(f)
<br>
・0階微分
<br>
_dx(=&lt;f,) || _dx(=&lt;f,0)
<br>
-> -4.000000000000002-4.000000000000001i
<br>
f -> -4.000000000000002-4.000000000000001i
<br>
・1階微分は4次精度
<br>
_dx(=&lt;f,1)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
_dx(=&lt;f)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
・2階微分は4次精度以下
<br>
・差分刻みが異なる多重化とは完全には一致しない
<br>
_dx(=&lt;f,2)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
_dx(=&lt;{_dx(=&lt;f)})
<br>
-> -40.00000000012216+40.00000000037086i+O(7e-10+1e-12i)
<br>
・2階微分を4次精度1階微分で厳密に多重化する場合、4次精度以下
<br>
_dx(=&lt;{_dx(=&lt;f,1,x,1dx)},1,x,2dx)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
・3階微分以降は2次精度
<br>
・多重化は1階上がる毎に精度悪化
<br>
_dx(=&lt;f,3)
<br>
-> 2.6203811256259035e-11+120.00084001140233i+O(2e-2+2e-2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})
<br>
-> 4.378068605950494e-8+120.00000084539053i+O(2e-7+2e-7i)
<br>
・3階微分を4次精度1階微分で厳密に多重化する場合、3次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)},1,x,2dx)},1,x,4dx)
<br>
-> -3.5859384520417787e-10+120.00000000321582i+O(3e-8+3e-8i)
<br>
・4階微分
<br>
_dx(=&lt;f,4)
<br>
-> 120.00000006268098+120.0000001718161i+O(1e+0+2e-2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})
<br>
-> 120.00001615650766+120.00019838028798i+O(1e-4+7e-7i)
<br>
・4階微分を4次精度1階微分で厳密に多重化する場合、2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)},1,x,2dx)},1,x,4dx)},1,x,8dx)
<br>
-> 119.99999887453464+120.00000028081901i+O(2e-6+1e-7i)
<br>
・5階微分
<br>
_dx(=&lt;f,5)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(2e+1+2e+1i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})
<br>
-> 119.18659727305976+0.3620753183716584i+O(5e-2+5e-2i)
<br>
・5階微分を4次精度1階微分で厳密に多重化する場合、2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(5e-5+5e-5i)
<br>
・6階微分
<br>
_dx(=&lt;f,6)
<br>
-> -0.0004498352662456228+0.0005560189878646384i+O(2e+2+4e+0i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})})
<br>
-> -322.002293591315+54.781879309774695i+O(3e+1+2e-1i)
<br>
・6階微分を4次精度1階微分で厳密に多重化する場合、2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)
<br>
-> -0.004201126114795549+0.005541058257682469i+O(1e-3+5e-5i)
<br>
・7階微分
<br>
_dx(=&lt;f,7)
<br>
-> -0.0007280114418273857+0.0030141311391229672i+O(9e+2+9e+2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})})})
<br>
-> -177398.93670986558-669172.3211788241i+O(1e+4+1e+4i)
<br>
・7階微分を4次精度1階微分で厳密に多重化する場合、2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)},1,x,64dx)
<br>
-> -0.009902789205100404+0.05048924924402281i+O(5e-3+5e-3i)
<br>
・8階微分
<br>
_dx(=&lt;f,8)
<br>
-> 0.03950452954492218+0.04027593568552271i+O(4e+3+6e+1i)
<br>
・9階微分
<br>
_dx(=&lt;f,9)
<br>
-> -0.16566502311270223-0.015219989707358128i+O(4e+3+3e+3i)
<br>
・10階微分
<br>
_dx(=&lt;f,10)
<br>
-> 0.044163954487214524-0.06480605313760723i+O(3e+3+6e+1i)
<br>
・微分位置を大きくした場合
<br>
_dx(=&lt;{x^2},1,1e10)
<br>
-> 20000000000.027855-2.790277777777778e-12i+O(1e+28+1e-12i)
<br>
_dx(=&lt;{x^2},2,1e10)
<br>
-> 1.9999999995176474+9.657789228690995e-20i+O(2e+29+3e+10i)
<br>
_dx(=&lt;{x^2},3,1e10)
<br>
-> 1.894235601707095e-17-5.686908543633962e-27i+O(2e+15+5e-4i)
<br>
・微分位置を小さくした場合
<br>
_dx(=&lt;{x^2},1,1e-10)
<br>
-> 2.0000000041847774e-10+7.305374602696278e-19i+O(1e-12+1e-12i)
<br>
_dx(=&lt;{x^2},2,1e-10)
<br>
-> 2.0000000000000013+9.411477191714447e-16i+O(3e-10+2e-11i)
<br>
_dx(=&lt;{x^2},3,1e-10)
<br>
-> 1.5072697186506098e-13-7.131763305997033e-14i+O(2e-2+2e-2i)
<br>
・2変数の多重微分
<br>
_Dy(=&lt;{_Dx(=&lt;{x*y*y},1,0)},1,1)
<br>
-> 1.9999999999998288+1.8785308474662037e-13i+O(7e-10+1e-12i)
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、微分の差分刻みdx0=0の場合、省略に同義として扱う
<br>
_dx(=&lt;{x^2},1,1,0) || _dx(=&lt;{x^2},1,1)
<br>
-> 1.9999999999998392+1.6112448952215134e-13i+O(1e-12+1e-12i)
<br>
<br>
応用例を示す
<br>
・<a href="#span-out-non-linear">非線形方程式の解法</a>を使用
<br>
・微分方程式(x^3)"+x-7(1+i)=0の解析解x=1+iの求解
<br>
storage cleared
<br>
f=&lt;{_dx(=&lt;{x^3},2)+x-7(1+i)=0};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ri] 2.3549912261033786e-10+O(8e+0)
<br>
x -> infoLost[ri] 0.9999999999877383+1.0000000000273828i+O(1e-5+9e-6i)
<br>
・normが<a href="#span-out-epsilon">Machine epsilon</a>まで収束困難のため、一定回数の反復で打切る
<br>
・次に<a href="#span-out-error-numerical">数値解</a>の一例を示す
<br>
storage cleared
<br>
f=&lt;{2x*_dx(=&lt;{x*exp(3x)})=i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> 3.844899655887233e-14+O(8e+0)
<br>
x -> -0.17989326929739397-0.5079280004968542i+O(2e-1+5e-1i)
<br>
・続けて厳密解同等の<a href="#span-out-error-numerical">数値解</a>を示す
<br>
storage cleared
<br>
f=&lt;{2x*(1*exp(3x)+x*exp(3x)3)=i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[r ] 3.3306690738754696e-16
<br>
x -> infoLost[r ] -0.17989326929046887-0.5079280004963925i
<br>
・連立方程式の解析解{x0,x1}={1,1}の求解
<br>
storage cleared
<br>
f0=&lt;{1*x0^2+x1};
<br>
f1=&lt;{i*x1^3+x0};
<br>
x=&lt;{x0,x1};
<br>
f=&lt;{x0+x1=2,_dx0(=&lt;{f0})+_dx1(=&lt;{f1},2)=2+6i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[ri] 3.236567392072123e-11+O(7e+0)
<br>
x ->
<br>
(
<br>
infoLost[ri] 1.000000000003112+3.106688703682062e-12i+O(6e-5+5e-5i):
<br>
infoLost[ri] 0.9999999999968879-3.106688703682063e-12i+O(1e-5+2e-5i)
<br>
)
<br>
・同じく<a href="#span-out-ope">実数演算</a>の場合
<br>
storage cleared
<br>
f0=&lt;{1*x0^2+x1};
<br>
f1=&lt;{i*x1^3+x0};
<br>
x=&lt;{x0,x1};
<br>
f=&lt;{x0+x1=2,_dx0(=&lt;{f0})+_dx1(=&lt;{f1},2)=2+6i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> 7.724854831493598e-14+O(7e+0)
<br>
x -> (1.000000000000009+O(3e-5):0.9999999999999909+O(3e-5))
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
積分
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-IX"></span>
積分高階関数
<br>
・連続関数のdummy変数積分範囲[a,b]における定積分を数値的に演算して返す
<br>
・<a href="#span-out-error-numerical">数値誤差</a>O(dxI^4以上)を含み、演算結果に<a href="#span-out-error-numerical">目安の解析誤差</a>を表示する
<br>
・積分範囲の分割数の既定値NI=100
<br>
・積分の差分刻みdxI=(b-a)/NI
<br>
・_idummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照するが、上書きしない
<br>
<br>
_idummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: dummy変数の積分下限aを値渡し
<br>
・第3引数: dummy変数の積分上限bを値渡し
<br>
option
<br>
・第4引数: 積分範囲の分割数NI（正の偶数）を値渡し[0||省略時、NI既定値]
<br>
<br>
<a href="#span-out-error-numerical">数値誤差</a>に関する精度次数について記述する
<br>
・<a href="#span-out-error-numerical">数値誤差</a>は絶対誤差
<br>
・既定で合成Simpson公式による4次精度
<br>
・台形公式による2次精度を<a href="#span-in-options">内部option</a>で選択可
<br>
<br>
詳細は<a href="#span-out-fdm-integral">積分の数値解法</a>参照
<br>
<br>
test caseを列挙する
<br>
・f(x)=x^4の積分範囲[0,1+i]における定積分を示す
<br>
a=0; b=1+i; ab=[a,b]; f=&lt;{x^4} -> stored_eqn(f)
<br>
・分割数100
<br>
_ix(=&lt;f,ab) || _ix(=&lt;f,a,b)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数10
<br>
_ix(=&lt;f,ab,10)
<br>
-> -0.8000533333333335-0.8000533333333333i+O(1e-4+1e-4i)
<br>
・分割数1000
<br>
_ix(=&lt;f,ab,1000)
<br>
-> -0.8000000000005332-0.800000000000533i+O(1e-12+1e-12i)
<br>
・積分範囲を反転
<br>
_ix(=&lt;f,[b,a]) || _ix(=&lt;f,b,a)
<br>
-> 0.8000000053333336+0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が奇数の場合、暗黙で+1して偶数に変換される
<br>
_ix(=&lt;f,ab,99) || _ix(=&lt;f,ab,99+1)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が負の場合、暗黙で絶対値に変換される
<br>
_ix(=&lt;f,ab,-100)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・2次精度選択の場合（参考）
<br>
_ix(=&lt;f,ab)
<br>
-> -0.8001333320000001-0.8001333319999999i+O(1e-4+1e-4i)
<br>
・2変数の多重積分
<br>
_iy(=&lt;{_ix(=&lt;{x^2*y},0,y)},0,2) -> 2.1333333475555563+O(2e-7)
<br>
_iy(=&lt;{y^4/3},0,2) -> 2.1333333475555563+O(2e-7)
<br>
・微分・積分
<br>
_ix(=&lt;{_dx(=&lt;{x^3})},1,2)
<br>
-> 7.000000000000061-3.369899113923336e-14i+O(1e-8+1e-14i)
<br>
_Ix(=&lt;{_Dx(=&lt;{sin(x)},1,0)},-pi,pi)
<br>
-> 6.283185307180439+2.010557877134426e-14i+O(2e-5+8e-14i)
<br>
・積分・微分
<br>
_dx(=&lt;{_ix(=&lt;{x^3},0,x)},1,2)
<br>
-> 7.999999999998895+5.517384388870678e-13i+O(4e-5+2e-5i)
<br>
<br>
応用例を示す
<br>
・<a href="#span-out-non-linear">非線形方程式の解法</a>を使用
<br>
・f(x)=x^2のx=[0,b]の定積分=3^3/3となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f=&lt;{_ix(=&lt;{x^2},0,b)=3^3/3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{b},=&lt;{1}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[ i] 1.3839478914652153e-28+O(8e-7)
<br>
b -> infoLost[ri] 2.9999999999999996+4.613167602434132e-34i+O(1e-1+2e-1i)
<br>
・2次関数の積分の場合、補間多項式に一致するため、<a href="#span-out-error-numerical">数値誤差</a>が出ない
<br>
_ix(=&lt;{x^2},0,3,2) -> 9+O(5e+0)
<br>
_ix(=&lt;{x^2},0,3,10) -> 8.999999999999998+O(8e-3)
<br>
_ix(=&lt;{x^2},0,3,100) -> 8.999999999999998+O(8e-7)
<br>
_ix(=&lt;{x^2},0,3,1000) -> 8.999999999999998+O(8e-11)
<br>
・f(x)=x^4のx=[0,b]の定積分=3^5/5となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f=&lt;{_ix(=&lt;{x^4},0,b)=3^5/5};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{b},=&lt;{1}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,20) -> 1.4210854715508634e-14+O(8e-7)
<br>
b -> infoLost[r ] 2.9999999959999992-1.15251646351758e-21i+O(2e-2+2e-2i)
<br>
・高次関数の積分の場合、収束までの反復回数が増える
<br>
・得られる近似解の精度は分割数に依存する
<br>
_ix(=&lt;{x^4},0,3,2) -> 50.62499999999998+O(5e+0)
<br>
_ix(=&lt;{x^4},0,3,10) -> 48.60323999999998+O(8e-3)
<br>
_ix(=&lt;{x^4},0,3,100) -> 48.60000032400001+O(8e-7)
<br>
_ix(=&lt;{x^4},0,3,1000) -> 48.60000000003241+O(8e-11)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh"></span>
高階行列関数を列挙する
<br>
・<a href="#span-out-FNmh-jacobian">Jacobi高階行列関数</a>
<br>
・<a href="#span-out-FNmh-newtonian">Newton高階行列関数</a>
<br>
・<a href="#span-out-FNmh-OX">ODE高階行列関数</a>
<br>
・<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Jacobi
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-jacobian"></span>
Jacobi高階行列関数
<br>
・Jacobi行列を数値的に演算して返す
<br>
・数値的安定性・収束性を最優先
<br>
　精度を上げると不必要にNewton法の収束速度が悪化する
<br>
　微分位置に応じて差分刻みを可変すると収束速度が悪化する
<br>
・1次精度の<a href="#span-out-error-numerical">数値誤差</a>O(dx)を含むが、<a href="#span-out-error-numerical">目安の解析誤差</a>を評価・表示しない
<br>
・1階偏微分の差分刻み実数値dxJ既定値dxJ=1e-5
<br>
・微分位置xでの差分刻みdx既定値dx=dxJ(1+i)
<br>
・未知変数のlocal変数を参照するが、上書きしない
<br>
<br>
Jacobi(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数]])
<br>
・第1引数: 方程式||関数式の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: 未知<a href="#span-out-vars-symbol">変数名symbol</a>の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>[0||省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: 偏微分の差分刻みdxを値渡し[0||省略時、dx既定値]
<br>
<br>
xの1次方程式の偏微分係数を求める場合
<br>
clear; Jacobi(=&lt;{3x-3=0},=&lt;{x},=&lt;{0})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
clear; Jacobi(=&lt;{3x-3=0},=&lt;{x})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
・右辺に移項した関数=-3x+3のx=0周辺の傾き-3を返す
<br>
<br>
xの2次関数の偏微分係数を求める場合
<br>
clear; Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{1})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
・1階偏微分の解析解=4xからx=1周辺の傾き4を返す
<br>
<br>
微分位置を大きくした場合
<br>
clear; Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{1e10})  <span class="selection">// NG</span>
<br>
-> 19999999999.999996+19999999999.999996i
<br>
clear; a=1e10; h=max(1,abs(a))1e-5(1+i); Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{a},h)  <span class="selection">// OK</span>
<br>
-> 40000200000.65538+199999.3446694911i
<br>
・<a href="#span-out-error">情報落ち</a>の対策が必要
<br>
・1階偏微分の解析解=4xからx=1e10周辺の傾き4e10を返す
<br>
<br>
未知変数のlocal変数を参照するが、上書きしない
<br>
storage cleared
<br>
x=1;
<br>
Jacobi(=&lt;{2x^2},=&lt;{x})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
x -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Newton
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-newtonian"></span>
Newton高階行列関数
<br>
・Newton法による反復1回の演算結果を返す
<br>
・引数は第4引数まで<a href="#span-out-FNmh-jacobian">Jacobi高階行列関数</a>に同じ
<br>
・返値は符号付の解の修正vector（以降、残差と呼ぶ）
<br>
・絶対誤差の残差norm収束判定実数値epsN既定値epsN=1e-16
<br>
・未知変数のlocal変数を参照、上書きする
<br>
<br>
Newton(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数[,第5引数[,第6引数[,第7引数]]]]])
<br>
・第1引数: 方程式||関数式の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: 未知<a href="#span-out-vars-symbol">変数名symbol</a>の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>[0||省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: 偏微分の差分刻みdxを値渡し[0||省略時、dx既定値]
<br>
<span class="run">Ver.2.29.15</span>以降、第5~7引数追加
<br>
・第5引数: 反復回数（正の整数）を値渡し[省略時、1]
<br>
・第6引数: 絶対誤差の残差norm収束判定実数値epsNを値渡し[省略時、epsN既定値]
<br>
・第7引数: 第6引数epsNを相対誤差に変換する0||not0のflag[省略時、0]
<br>
<br>
応用例は<a href="#span-out-linear">連立方程式の解法</a>参照
<br>
<br>
test caseを列挙する
<br>
・<a href="#span-out-config-strict">strict-mode</a>で<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>する場合
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{0,0};
<br>
f=&lt;{x0+2*x1=5,3*x0+4*x1=6};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f=&gt;),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.2204460494935903e-15
<br>
・<a href="#span-out-config-strict">strict-mode</a>で直接<a href="#span-out-call-by-equation">式渡し</a>する場合
<br>
storage cleared
<br>
run=&lt;last(mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},=&lt;{0,0}),norm(mdx));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.2204460494935903e-15
<br>
・<a href="#span-out-config-strict">strict-mode</a>の最短表記
<br>
storage cleared
<br>
_rn(=&lt;{
<br>
last(mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},=&lt;{0,0}),norm(mdx))
<br>
},,3) -> infoLost[ri] 2.2204460494935903e-15
<br>
<br>
<span class="run">Ver.2.29.15</span>以降
<br>
・第3引数0の場合、zeros-vector
<br>
・第4引数0の場合、偏微分の差分刻みdx=dx既定値
<br>
・第5引数で反復回数を指定可
<br>
・第6引数で絶対誤差の収束判定値を指定可
<br>
・第7引数で第6引数を相対誤差に変換するflagを指定可
<br>
・反復0回の場合、初期値を返す
<br>
storage cleared
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,0);
<br>
norm(mdx) -> 0
<br>
{x0,x1} -> (0:0)
<br>
・残差の最大値を演算する場合、<a href="#span-out-FNm-trans">転置行列関数</a>を使用
<br>
・残差を結合した列vectorを転置して行vectorに変換後、maxを取る
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> 0
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> 0
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> 0
<br>
・反復3回の場合
<br>
・反復最後の残差を<a href="#span-out-error-numerical">目安の解析誤差</a>として表示する
<br>
storage cleared
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,3);
<br>
norm(mdx) -> infoLost[ri] 2.2204460494935903e-15
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> infoLost[ri] 1.7763568394338757e-15
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> infoLost[ri] 2.1963410797410362e-20
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> infoLost[ri] 1.7763568395696568e-15
<br>
{x0,x1} ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i+O(2e-15+2e-20i):
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i+O(1e-15+2e-20i)
<br>
)
<br>
・反復10回以内に絶対誤差のnorm収束判定値1e-8を指定する場合
<br>
・収束判定成立時の残差を<a href="#span-out-error-numerical">目安の解析誤差</a>として表示する
<br>
storage cleared
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,10,1e-8);
<br>
norm(mdx) -> 2.0548659974995737e-10
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> 1.0355938329098548e-10
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> 1.0355819825427455e-10
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> 1.464542464160083e-10
<br>
{x0,x1} ->
<br>
(
<br>
-4.000000000000001+2.1963377172690418e-20i+O(1e-10+1e-10i):
<br>
4.500000000000001-1.7499160954924154e-20i+O(1e-10+1e-10i)
<br>
)
<br>
・反復10回以内に相対誤差のnorm収束判定値1e-8を指定する場合
<br>
・未知変数の初期化が必要
<br>
・zeros-vectorで初期化の場合、反復2回以上が確定する
<br>
storage cleared
<br>
{$x0,$x1}={,};
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,10,1e-8*norm({x0,x1}));
<br>
norm(mdx) -> infoLost[ri] 2.2204460494895584e-15
<br>
1e-8*norm({x0,x1}) -> infoLost[ri] 6.02079728939615e-8+O(2e-33i)
<br>
norm(mdx)/norm({x0,x1}) -> infoLost[ri] 3.6879601533840316e-16+O(1e-41i)
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> infoLost[ri] 1.7763568395916467e-15
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> infoLost[ri] 2.250213020433239e-25
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> infoLost[ri] 1.7763568395916467e-15
<br>
{x0,x1} ->
<br>
(
<br>
infoLost[ri] -4.000000000000001+1.9139665347514104e-25i+O(2e-15+2e-25i):
<br>
infoLost[ri] 4.500000000000001-1.4354751880569493e-25i+O(1e-15+2e-25i)
<br>
)
<br>
・反復10回以内に相対誤差のnorm収束判定値1e-8を指定する場合
<br>
・第7引数で相対誤差のflag-ONを指定する場合、未知変数の初期化不要
<br>
storage cleared
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,10,1e-8,1);
<br>
norm(mdx) -> 2.0548659974995737e-10
<br>
norm(mdx)/norm({x0,x1}) -> 3.4129466559497216e-11+O(4e-22+4e-22i)
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> 1.0355938329098548e-10
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> 1.0355819825427455e-10
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> 1.464542464160083e-10
<br>
{x0,x1} ->
<br>
(
<br>
-4.000000000000001+2.1963377172690418e-20i+O(1e-10+1e-10i):
<br>
4.500000000000001-1.7499160954924154e-20i+O(1e-10+1e-10i)
<br>
)
<br>
・反復1回指定で3回繰り返した場合
<br>
・反復1回目の最大残差が<a href="#span-out-error-numerical">目安の解析誤差</a>として残る
<br>
storage cleared
<br>
_rn(=&lt;{
<br>
mdx=Newton(=&lt;{x0+2*x1=5,3*x0+4*x1=6},=&lt;{x0,x1},,,1)
<br>
},,3);
<br>
norm(mdx) -> infoLost[ri] 2.2204460494935903e-15+O(2e-5+5e-6i)
<br>
max(trans({mdx,-mdx}))  <span class="selection">// real-part</span> -> infoLost[ri] 1.7763568394338757e-15+O(2e-5)
<br>
max(i*trans({mdx,-mdx}))  <span class="selection">// imag-part</span> -> infoLost[ri] 2.1963410797410362e-20+O(1e-5)
<br>
cmax(trans(mdx))  <span class="selection">// |both-part|</span> -> infoLost[ri] 1.7763568395696568e-15+O(2e-5)
<br>
{x0,x1} ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i+O(4e+0+2e-10i):
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i+O(4e+0+1e-5i)
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
ODE
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-OX"></span>
ODE高階行列関数
<br>
・dummy変数を媒介する常微分方程式の1step定積分を数値的に演算して返す
<br>
・<a href="#span-out-error-numerical">数値誤差</a>O(dt^4以上)を含み、演算結果に<a href="#span-out-error-numerical">目安の解析誤差</a>を表示する
<br>
・1階常微分の差分刻み実数値dxT既定値dxT=1e-3
<br>
・_odummy<a href="#span-out-vars-symbol">変数名symbol</a>でcallする
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照、上書きする
<br>
・未知変数のlocal変数を参照、上書きする
<br>
<br>
_odummy<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数[,第5引数[,第6引数]]]])
<br>
・第1引数: 1階常微分方程式右辺の関数式||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
・第2引数: 未知<a href="#span-out-vars-symbol">変数名symbol</a>の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vector||<a href="#span-out-vars-symbol">式変数名symbol</a>を<a href="#span-out-call-by-equation">式渡し</a>[0||省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: dummy変数初期値t0を値渡し[省略時、0]
<br>
　第4引数はdummy変数と同名のlocal変数未定義時のみ有効
<br>
・第5引数: 常微分の差分刻みdtを値渡し[省略時、dxT既定値]
<br>
<span class="run">Ver.2.29.15</span>以降、第6引数追加
<br>
・第6引数: 反復回数（正の整数）を値渡し[省略時、1]
<br>
<br>
<a href="#span-out-error-numerical">数値誤差</a>に関する精度次数について記述する
<br>
・<a href="#span-out-error-numerical">数値誤差</a>は絶対誤差
<br>
・既定で陽的Runge-Kutta法による4次精度
<br>
・陽的improved Euler法による2次精度を<a href="#span-in-options">内部option</a>で選択可
<br>
<br>
応用例は<a href="#span-out-evolution">時間発展の解法</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
symbolic
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-EX"></span>
symbolic高階行列関数
<br>
・未知<a href="#span-out-vars-symbol">変数名symbol</a>連番0~のm行n列の<a href="#span-out-mat">行列</a>を<a href="#span-out-eqns">式変数</a>に<a href="#span-out-substitution-equation">式代入</a>して0を返す
<br>
・_e式<a href="#span-out-vars-symbol">変数名symbol</a>(=&lt;{未知<a href="#span-out-vars-symbol">変数名symbol</a>},m,n)でcallする
<br>
<br>
test caseを列挙する
<br>
・x=&lt;(x0,x1,x2,x3)
<br>
clear; _ex(=&lt;{x},1,4) -> 0
<br>
clear; _ex(=&lt;{x},1,4); x -> [MyErr]Invalid REv(x0)
<br>
clear; _ex(=&lt;{x},1,4); ($x0,$x1:$x2,$x3)=identity2; x -> (1,0,0,1)
<br>
clear; x=&lt;(x0,x1,x2,x3); ($x0,$x1:$x2,$x3)=identity2; x -> (1,0,0,1)
<br>
・x=&lt;(x0:x1:x2:x3)
<br>
clear; _ex(=&lt;{x},4,1); ($x0,$x1:$x2,$x3)=identity2; x -> (1:0:0:1)
<br>
clear; x=&lt;(x0:x1:x2:x3); ($x0,$x1:$x2,$x3)=identity2; x -> (1:0:0:1)
<br>
・x=&lt;(x0,x1:x2,x3)
<br>
clear; _ex(=&lt;{x},2,2); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
clear; x=&lt;(x0,x1:x2,x3); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
・symbol名は<a href="#span-out-FNm-last">最終要素</a>を参照
<br>
clear; _ex(=&lt;{test,test:x},2,2); x -> [MyErr]Invalid REv(test0)
<br>
clear; _ex(=&lt;{test,test:test,x},2,2); x -> [MyErr]Invalid REv(x0)
<br>
clear; _ex(=&lt;{test,test:test,x},2,2); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
・引数不正の場合、error終了
<br>
clear; _ex(=&lt;{x},2,0) -> [MyErr]Invalid matrix size
<br>
clear; _ex(=&lt;{x},2) -> [MyErr]Invalid EX arguments
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、<a href="#span-out-vars">変数の命名規則</a>に準拠
<br>
_ex(=&lt;{$x},2,2) -> [MyErr]Invalid REv($x)
<br>
_ex(=&lt;{$$x},2,2) -> [MyErr]Invalid REv($$x)
<br>
_e$x(=&lt;{x},2,2) -> [MyErr]Invalid dummy($x)
<br>
_e$$x(=&lt;{x},2,2) -> [MyErr]Invalid dummy($$x)
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、第1引数の<a href="#span-out-BT">括弧</a>省略可
<br>
clear; _ex(=&lt;x,1,4); ($x0,$x1:$x2,$x3)=identity2; x -> (1,0,0,1)
<br>
<br>
応用例は<a href="#span-out-inverse">逆行列の解法</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列積
<br>
の解法
    </th>
    <td>
<span id="span-out-mat-product"></span>
通常の行列積LR=L*Rのalgorithmについて記述する
<br>
<br>
通常の行列積LR=L*Rの定義を次に示す
<br>
・Lの列sizeとRの行sizeが一致するcaseのみ、積を定義する
<br>
・内積
<br>
(1,2){3,4} -> 11
<br>
・cross積
<br>
{1,2}(3,4) -> (3,4:6,8)
<br>
・正方行列の累乗
<br>
(1,2:0,0)(1,2:0,0) -> (1,2:0,0)
<br>
(3,4:0,0)(3,4:0,0) -> (9,12:0,0)
<br>
<br>
<a href="#span-out-FNm">行列size</a>の異なる次のLとRを一例に示す
<br>
L=(1,2:3:4,5:6);
<br>
R=(1,2:3,4,5);
<br>
・演算子による行列積L*R
<br>
L*R -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
・<a href="#span-out-FNm">行列size</a>
<br>
sizer(L) -> 4
<br>
sizec(L) -> 2
<br>
sizer(R) -> 2
<br>
sizec(R) -> 3
<br>
sizer(L*R) -> 4
<br>
sizec(L*R) -> 3
<br>
・<a href="#span-out-FNm">行列size</a>について次の関係が成立する
<br>
sizer(L*R)=sizer(L) -> 0
<br>
sizec(L*R)=sizec(R) -> 0
<br>
<br>
以上より、行列積のalgorithmを以下に示す
<br>
・L指定行とR指定列の内積を取る<a href="#span-out-eqns">式変数</a>productを定義する
<br>
・さらに、行列積LRを返す<a href="#span-out-eqns">式変数</a>LpRを定義する
<br>
LpR=&lt;{product=&lt;last{LR[ir][ic]=ttL[ir]trans((trans(ttR))[ic])},
<br>
ttL=trans(trans(L)),
<br>
ttR=trans(trans(R)),
<br>
LR=zeros(sizer(ttL),sizec(ttR)),
<br>
_sir(=&lt;{_sic(=&lt;product,0,sizec(ttR)-1)},0,sizer(ttL)-1),
<br>
=&lt;LR}=&gt;;
<br>
・演算子による行列積L*Rでは1回の転置trans(R)に最適化される
<br>
・また、この転置時にRの抜け要素を埋める
<br>
trans(R) -> (1,3:2,4:0,5)
<br>
・さらに、Lの抜け要素の部分はRと内積を取らない（自明の演算は行わない）
<br>
<br>
行列積L*Rの<a href="#span-out-ope">演算量</a>を多少減らすために抜け要素を許容する
<br>
・N次下三角行列Lの場合、最高効率で<a href="#span-out-ope">演算量</a>が半減する
<br>
・行列積の乗算回数を以下に比較して示す
<br>
・抜け要素を許容しない場合
<br>
N=4; N*N*N -> 64
<br>
N=10; N*N*N -> 1000
<br>
・抜け要素を許容する場合
<br>
N=4; _sn(=&lt;{n*n},1,N) -> 30
<br>
N=10; _sn(=&lt;{n*n},1,N) -> 385
<br>
・4次下三角行列Lの行列積
<br>
L=(1:2,3:4,5,6:7,8,9,10);
<br>
R=identity4;
<br>
LpR -> (1,0,0,0:2,3,0,0:4,5,6,0:7,8,9,10)
<br>
L*R -> (1,0,0,0:2,3,0,0:4,5,6,0:7,8,9,10)
<br>
<br>
test caseを列挙する
<br>
・上記例
<br>
L=(1,2:3:4,5:6);
<br>
R=(1,2:3,4,5);
<br>
LpR -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
L*R -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
・定義できない行列積
<br>
L=(1,2);
<br>
R=(1,2);
<br>
LpR -> [MyErr]Invalid matrix operation
<br>
L*R -> [MyErr]Invalid matrix operation
<br>
・内積
<br>
L=(1+i,1);
<br>
R={1-i,1};
<br>
LpR -> 3
<br>
L*R -> 3
<br>
・cross積
<br>
L={1-i,1};
<br>
R=(1+i,1);
<br>
LpR -> (2,1-i:1+i,1)
<br>
L*R -> (2,1-i:1+i,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
有限差分法
    </th>
    <td>
<span id="span-out-fdm"></span>
有限差分法Finite Difference Methodの解法を列挙する
<br>
・<a href="#span-out-fdm-differential">微分の数値解法</a>
<br>
・<a href="#span-out-fdm-integral">積分の数値解法</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
微分
<br>
の数値解法
    </th>
    <td>
<span id="span-out-fdm-differential"></span>
有限差分による微分の数値解法について記述する
<br>
<br>
差分刻みをhとして連続関数f(x)のx周辺の2次打切りTaylor級数から
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+O(h^3)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+O(h^3)
<br>
・1階微分の2次精度中心差分
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O(h^2)
<br>
・2階微分の2次精度中心差分
<br>
f"(x)=(f(x+h)-2f(x)+f(x-h))/(h^2)+O(h^2)
<br>
<br>
2次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(f'(x+h)-f'(x-h))/(2h)=(f(x+2h)-f(x)-f(x)+f(x-2h))/(2h)^2+O(h)
<br>
・本来、2階微分の精度次数が落ちるが、H=2hとすれば精度次数が落ちない
<br>
f"(x)=(f(x+H)-2f(x)+f(x-H))/(H^2)+O(H^2)
<br>
・よって微分階数が1階上がる毎に差分刻み2倍の関係が成立すると仮定して
<br>
・3階微分以降も同様に、再帰的に多重化する
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O((h)^2)
<br>
f"(x)=(f'(x+2h)-f'(x-2h))/(4h)+O((2h)^2)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+8h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
<br>
<br>
続いて4次打切りTaylor級数から
<br>
f(x-2h)=f(x)+f'(x)(-2h)+f"(x)(-2h)^2/2!+f"'(x)(-2h)^3/3!+f""(x)(-2h)^4/4!+O(h^5)
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+f"'(x)(-h)^3/3!+f""(x)(-h)^4/4!+O(h^5)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+f"'(x)(h)^3/3!+f""(x)(h)^4/4!+O(h^5)
<br>
f(x+2h)=f(x)+f'(x)(2h)+f"(x)(2h)^2/2!+f"'(x)(2h)^3/3!+f""(x)(2h)^4/4!+O(h^5)
<br>
・次の3階微分を消去すれば
<br>
f(x+2h)-f(x-2h)=f'(x)(4h)-f"'(x)(2h)^3/3+O(h^5)
<br>
f(x+h)-f(x-h)=f'(x)(2h)-f"'(x)(h)^3/3+O(h^5)
<br>
・1階微分の4次精度中心差分
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
<br>
さらに、5次打切りTaylor級数から
<br>
・次の4階微分を消去すれば
<br>
f(x+2h)+f(x-2h)=2f(x)+f"(x)(2h)^2+f""(x)(2h)^4/12+O(h^6)
<br>
f(x+h)+f(x-h)=2f(x)+f"(x)(h)^2+f""(x)(h)^4/12+O(h^6)
<br>
・2階微分の4次精度中心差分
<br>
f"(x)=(16(f(x+h)+f(x-h))-(f(x+2h)+f(x-2h))-30f(x))/(12h^2)+O(h^4)
<br>
<br>
4次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
・2次精度の場合と異なり、必要な離散点数が増えるが、
<br>
f'(x+h)=(8(f(x+2h)-f(x))-(f(x+3h)-f(x-h)))/(12h)
<br>
f'(x-h)=(8(f(x)-f(x-2h))-(f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)=(8(f(x+3h)-f(x+h))-(f(x+4h)-f(x)))/(12h)
<br>
f'(x-2h)=(8(f(x-h)-f(x-3h))-(f(x)-f(x-4h)))/(12h)
<br>
・stencilが2倍に広がる点は変わらない
<br>
f'(x+h)-f'(x-h)=(8(f(x+2h)-2f(x)+f(x-2h))-(f(x+3h)-f(x-h)+f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)-f'(x-2h)=(8(f(x+3h)-f(x+h)-f(x-h)+f(x-3h))-(f(x+4h)-2f(x)+f(x-4h)))/(12h)
<br>
・よって再帰的に多重化した場合、微分階数が上がる毎に精度が悪化する
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
f"'(x)=(8(f"(x+h)-f"(x-h))-(f"(x+2h)-f"(x-2h)))/(12h)+O(h^2)
<br>
f""(x)=(8(f"'(x+h)-f"'(x-h))-(f"'(x+2h)-f"'(x-2h)))/(12h)+O(h)
<br>
...
<br>
<br>
2階微分の演算結果を示す
<br>
_dx(=&lt;{(x+i)^5},2,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
　・1階微分を多重化して再帰的に微分階数を上げる際、
<br>
　・拡張なしは差分刻み一定
<br>
　・拡張ありは1階上がる毎に差分刻み2倍の関係を仮定
<br>
-> -40.000079995027676+40.000100045239535i+O(5e-4+1e-6i)
<br>
-> -40.000199999917704+40.00019999969536i+O(2e-4+4e-6i)
<br>
-> -40.00000000012216+40.00000000037086i+O(7e-10+1e-12i)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
・2階微分までは拡張の有無で定量的に大差なし
<br>
<br>
5階微分の演算結果を示す
<br>
_dx(=&lt;{(x+i)^5},5,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
-> -2376.9807493302333+2495.6629047556085i+O(2e+4+2e+4i)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(2e+1+2e+1i)
<br>
-> 119.18659727305976+0.3620753183716584i+O(5e-2+5e-2i)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(5e-5+5e-5i)
<br>
・3階微分以降は拡張必須
<br>
<br>
以上より、微分階数が2階までは4次精度拡張、それ以降は2次精度拡張とする
<br>
・3階微分以降は精度より<a href="#span-out-ope">演算速度</a>を優先
<br>
・よって非線形性が強い<a href="#span-out-FN">関数</a>・<a href="#span-out-series">級数</a>・<a href="#span-out-limit">極限</a>の演算結果は当てにならない
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+2h)-f'(x-2h))-(f'(x+4h)-f'(x-4h)))/(24h)+O(h^3)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+4h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
積分
<br>
の数値解法
    </th>
    <td>
<span id="span-out-fdm-integral"></span>
有限差分による積分の数値解法について記述する
<br>
<br>
前提を列挙する
<br>
・<a href="#span-out-associativity">2項演算子のassociativity</a>は<a href="#span-out-option1">LA既定</a>を前提に記述する
<br>
・除算より<a href="#span-out-BRmo">記号省略乗算</a>優先を前提に記述する
<br>
・<a href="#span-out-FNm">行列</a>は本manualの構文を前提に記述する
<br>
・総和をΣ&lt;変数=開始値,終了値&gt;で記述する
<br>
・線形結合をvectorの内積で記述する
<br>
<br>
公式を導出する
<br>
・連続関数f(x)の積分範囲[a,b]をN等分割して差分刻みをhとする
<br>
h=(b-a)/N
<br>
・分割した離散点xiに対する関数の離散点f[i]を定義する
<br>
xi:=x[i]=a+i*h, i=0~N
<br>
f[i]=f(xi)
<br>
・分割した微小区間の面積dS[i]と全区間の面積Sを定義する
<br>
dS[i], i=0~N-1
<br>
S=Σ&lt;i=0,N-1&gt;dS[i]
<br>
・各変数は列vectorとして添字iで各要素の離散点を参照する
<br>
<br>
微小区間の関数fを線形補間する場合、2次精度の台形公式
<br>
・微小区間の台形の面積の総和を取ることで
<br>
dS[0]=(f[0]+f[1])h/2+O(h^3)
<br>
dS[i]=(f[i]+f[i+1])h/2+O(h^3)
<br>
S=Σ&lt;i=0,N-1&gt;dS[i]=Σ&lt;i=0,N-1&gt;(f[i]+f[i+1])h/2+O(h^2)
<br>
・次の台形公式が導出される
<br>
S=(f[0]+2Σ&lt;i=1,N-1&gt;f[i]+f[N])h/2+O(h^2)
<br>
・両端を除く離散点f[i]は2回足されて2倍
<br>
・全区間の<a href="#span-out-error">離散化誤差</a>のOrderは微小区間の正方形面積h*h
<br>
・総和によって微小区間の<a href="#span-out-error">離散化誤差</a>が積算されて精度次数が1次落ちる
<br>
<br>
微小区間の関数fを1次多項式で補間する場合も同様
<br>
・1次の補間多項式P1(x)を定義する
<br>
P1(x)=(1,x)(l:m)
<br>
・独立する2点の離散点xiに対する離散点f[i]から
<br>
P1(x0)=(1,x0)(l:m)=f[0]
<br>
P1(x1)=(1,x1)(l:m)=f[1]
<br>
・次の連立線形方程式V1*y1=r1を解くことで
<br>
V1=(1,x0:1,x1)
<br>
y1=(l:m)
<br>
r1=(f[0]:f[1])
<br>
・P1(x)の係数vector y1が求まる
<br>
・VはVandermonde行列
<br>
・離散点がすべて独立であればVの逆行列が一意に存在する
<br>
・予め逆行列を解いた方が<a href="#span-out-error">丸め誤差</a>の影響を受けにくい
<br>
・その形式に変形したLagrange基底の補間多項式を導出する
<br>
m=(f[0]-f[1])/(x0-x1)
<br>
l=f[0]-(f[0]-f[1])/(x0-x1)*x0
<br>
(l:m)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))(f[0]:f[1])
<br>
・y1=inverse(V1)*r1から
<br>
・V1の逆行列inverse(V1)
<br>
inverse(V1)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
・P1(x)=(1,x)(l:m)=(1,x)*inverse(V1)*(f[0]:f[1])から
<br>
・1次のLagrange基底多項式のvector L1=(1,x)*inverse(V1)
<br>
L1=(1,x)(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・1次のLagrange型の補間多項式
<br>
P1(x)=L1*(f[0]:f[1])
<br>
L1=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・P1(x)の不定積分integral(P1(x))
<br>
h=x1-x0
<br>
L1=(1/h)(-(x-x1),(x-x0))
<br>
integral(P1(x))=(1/2h)(-(x-x1)^2+C[0],(x-x0)^2+C[1])(f[0]:f[1])
<br>
・C[i]は積分定数
<br>
・P1(x)の微小区間[x0,x1]における定積分
<br>
dS[0]=(1/2h)(h^2,h^2)(f[0]:f[1])=(h/2)(1,1)(f[0]:f[1])=(f[0]+f[1])h/2
<br>
・以上より、次の台形公式が導出される
<br>
S=(f[0]+2Σ&lt;i=1,N-1&gt;f[i]+f[N])h/2+O(h^2)
<br>
<br>
微小区間の関数fを2次多項式で補間する場合、4次精度の合成Simpson公式
<br>
・2次の補間多項式P2(x)を定義する
<br>
P2(x)=(1,x,x^2)(l:m:n)
<br>
・独立する3点の離散点xiに対する離散点f[i]から
<br>
P2(x0)=(1,x0,x0^2)(l:m:n)=f[0]
<br>
P2(x1)=(1,x1,x1^2)(l:m:n)=f[1]
<br>
P2(x2)=(1,x2,x2^2)(l:m:n)=f[2]
<br>
・次の連立線形方程式V2*y2=r2を解くことで
<br>
V2=(1,x0,x0^2:1,x1,x1^2:1,x2,x2^2)
<br>
y2=(l:m:n)
<br>
r2=(f[0]:f[1]:f[2])
<br>
・P2(x)の係数vector y2が求まる
<br>
・以下、1次の場合同様に導出
<br>
・2次のLagrange型の補間多項式
<br>
P2(x)=L2*(f[0]:f[1]:f[2])
<br>
L2=(
<br>
(x-x1)(x-x2)/(x0-x1)(x0-x2),
<br>
(x-x0)(x-x2)/(x1-x0)(x1-x2),
<br>
(x-x0)(x-x1)/(x2-x0)(x2-x1))
<br>
・P2(x)の不定積分integral(P2(x))
<br>
h=x1-x0=x2-x1
<br>
L2=(1/(2h^2))((x-x1)(x-x2),-2(x-x0)(x-x2),(x-x0)(x-x1))
<br>
integral(P2(x))=(1/(2h^2))(
<br>
x^3/3-(x1+x2)x^2/2+x1*x2*x+C[0],
<br>
-2(x^3/3-(x0+x2)x^2/2+x0*x2*x+C[1]),
<br>
x^3/3-(x0+x1)x^2/2+x0*x1*x+C[2])(f[0]:f[1]:f[2])
<br>
・C[i]は積分定数
<br>
・P2(x)の微小2区間[x0,x2]における定積分
<br>
・1列目のみ示す
<br>
x0=x1-h
<br>
x2=x1+h
<br>
(x2^3-x0^3)/3-(x1+x2)(x2+x0)(x2-x0)/2+x1*x2(x2-x0)
<br>
=((x1+h)^3-(x1-h)^3)/3-(2x1+h)(2x1)h+x1(x1+h)2h
<br>
=(3x1^2+h^2)2h/3-(2x1+h)(x1)2h+x1(x1+h)2h
<br>
=(3x1^2+h^2-(2x1+h)(x1)3+x1(x1+h)3)2h/3
<br>
=(h^2)2h/3
<br>
・2列目以降も同様
<br>
・以上より、次のSimpson公式が導出される
<br>
dS[0]+dS[1]=(h/3)(1,4,1)(f[0]:f[1]:f[2])+O(h^5)
<br>
・さらに、分割数Nは正の偶数を前提として総和を取ることで
<br>
S=Σ&lt;k=0,N/2-1&gt;(dS[2k]+dS[2k+1])+O(h^4)
<br>
=(h/3)(Σ&lt;k=0,N/2-1&gt;((1,4,1)(f[2k]:f[2k+1]:f[2k+2])))+O(h^4)
<br>
・次の合成Simpson公式が導出される
<br>
S=(f[0]+4Σ&lt;k=0,N/2-1&gt;f[2k+1]+2Σ&lt;k=1,N/2-1&gt;f[2k]+f[N])h/3+O(h^4)
<br>
・両端を除く偶数の離散点f[2k]は2回足されて2倍
<br>
・全区間の<a href="#span-out-error">離散化誤差</a>のOrderは微小区間の正方形面積h*hの2乗
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
有限体積法
    </th>
    <td>
<span id="span-out-fvm"></span>
有限体積法Finite Volume Methodの解法を列挙する
<br>
・<a href="#span-out-fvm-about">有限体積法の概要</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
有限体積法
<br>
の概要
    </th>
    <td>
<span id="span-out-fvm-about"></span>
有限体積法の概要について記述する
<br>
<br>
有限体積法は状態量（物理量）のfluxを基準にcontrol volume内の保存則を離散化する
<br>
・主な示強性状態量は温度||速さ||濃度||電位potential
<br>
・fluxは離散化した基準面を通過する単位面積当たりの状態量（Fick's first law）
<br>
・1次元の場合、x方向の左右の面を通過するfluxを考慮する
<br>
・2次元の場合、左右に加えてy方向の上下の面を通過するfluxを考慮する
<br>
・3次元の場合、上下左右に加えてz方向の面を通過するfluxを考慮する
<br>
・よって単位体積当たりの状態量の<a href="#span-out-evolution">時間微分</a>は
<br>
　fluxのdivergence項とsource||sink項の和で表される（Fick's second law）
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
simplified
<br>
modelling
    </th>
    <td>
<span id="span-out-modelling"></span>
simplified modellingの応用手順を列挙する
<br>
・<a href="#span-out-modelling-usefulness">simplified modellingの有用性</a>
<br>
・<a href="#span-out-modelling-trade-off">simplified modellingのtrade-off</a>
<br>
・<a href="#span-out-modelling-application1">RC並列回路simplified modelling</a>
<br>
・<a href="#span-out-modelling-application2">拡散方程式simplified modelling</a>
<br>
・<a href="#span-out-simulation-EIS">EIS simulation</a>
<br>
・<a href="#span-out-modelling-application3">1D-cell simplified modelling</a>
<br>
・<a href="#span-out-simulation-EIS-1D-cell">1D-cell EIS simulation</a>
<br>
・<a href="#span-out-simulation-IV-1D-cell">1D-cell IV simulation</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
simplified
<br>
modelling
<br>
の有用性
    </th>
    <td>
<span id="span-out-modelling-usefulness"></span>
simplified modellingの有用性について記述する
<br>
<br>
<a href="#span-out-fdm">有限差分法</a>||<a href="#span-out-fvm">有限体積法</a>に基づくsimplified modellingの有用性を列挙する
<br>
・一般的な漸化式に帰結するmodel式を、制御のfeed-forward||backward項に応用する
<br>
・定性的に物理定数||物性値と紐付くため、model式のparameter数を最少化する
<br>
・各parameterを分離可能な特定条件の実測値から逆算して各物性値のOrderを推定する
<br>
・各parameterの最適化||機械学習によって制御量の定量性を改善する（<a href="#span-out-error">modelling誤差</a>を除く）
<br>
・環境温度等による状態量の変化傾向を理論的に予測する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
simplified
<br>
modelling
<br>
のtrade-off
    </th>
    <td>
<span id="span-out-modelling-trade-off"></span>
simplified modellingのtrade-offについて記述する
<br>
<br>
simplified modellingのtrade-offを列挙する
<br>
・一般的に、modelling対象の性能を最大化する実用想定では<a href="#span-out-error">modelling誤差</a>を無視できない
<br>
・詳細modellingからsimplifiedの過程で次元||自由度を落とした現象||影響が顕著になる
<br>
・この影響をparameterで誤学習||過学習した場合、全体の定量性を悪化させる可能性がある
<br>
・制御の場合、tableを含む次元の拡張等、対策が考えられるが、hard/softの制約が存在する
<br>
・さらに科学的な対策の根拠と定量的な効果を示すには仮説と実証実験の繰り返しを伴う上、
<br>
・耐久性を評価するcycle試験||加速試験の場合、相当の時間を要する
<br>
・よって詳細modellingから寄与度に応じてparameter数を削減するapproachもあり得る
<br>
・一方、現象の強連成が困難な場合、机上見積もりでsimplifiedと擬似||弱連成を許容する
<br>
・他方、未知の現象（劣化mode等）が判明した場合、手戻りが発生する懸念が残るが、
<br>
・結局、parameter学習と<a href="#span-out-error">modelling誤差</a>を含めた許容誤差の見極めが重要になると考えられる
<br>
・同時に、model入力値の測定誤差の影響を考慮する
<br>
・その上で目標値の達成が困難な場合、modelling対象を含む設計に手戻りの可能性が生じる
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
RC並列回路
<br>
simplified
<br>
modelling
    </th>
    <td>
<span id="span-out-modelling-application1"></span>
RC並列回路のsimplified modellingについて記述する
<br>
<br>
1次遅れ系のRC並列回路要素（以降、RC-1次遅れ要素と省略する）のmodellingを一例に示す
<br>
・保存則はKirchhoff's laws
<br>
・時間を<a href="#span-out-fdm">有限差分法</a>で離散化
<br>
<br>
前提を列挙する
<br>
・電流Iと電圧Vは正の相関を前提とする
<br>
・Laplace領域における合成impedanceの伝達関数Z(s)は電流I(s)に対する電圧V(s)の比で表す
<br>
Z(s)=V(s)/I(s)
<br>
・RLC直列回路要素のZ(s)を一例に示す
<br>
Z(s)=R+L*s+1/(C*s)
<br>
・各回路要素の電流の変数名をI_要素とする
<br>
・各回路要素の電圧の変数名をV_要素とする
<br>
<br>
RC-1次遅れ要素のZ(s)を導出する
<br>
・Kirchhoff's Current Law(KCL)
<br>
I=I_R+I_C
<br>
・Kirchhoff's Voltage Law(KVL)
<br>
V_R-V_C=0
<br>
V=V_R=R*I_R
<br>
V=V_C=I_C/(C*s)
<br>
・KVLからI_RとI_Cの関係を得る
<br>
R*I_R-I_C/(C*s)=0
<br>
I_R=I_C/(R*C*s)
<br>
・得られたI_RとKCLからI_CとIの関係を得る
<br>
I=I_C*(1+R*C*s)/(R*C*s)
<br>
I_C=I*(R*C*s)/(1+R*C*s)
<br>
・得られたI_CとKVLからVとIの関係を得る
<br>
V=I*R/(1+R*C*s)
<br>
・以上より、RC-1次遅れ要素のZ(s)が得られる
<br>
V=I*R/(1+R*C*s) -> Z(s)=R/(1+R*C*s)
<br>
<br>
RC-1次遅れ要素の<a href="#span-out-evolution">時間発展</a>方程式を導出する
<br>
・得られたVとIの関係から
<br>
V+V*R*C*s=I*R
<br>
V*s=-V/(R*C)+I/C
<br>
・次の定数を定義する
<br>
a=1/(R*C)
<br>
b=1/C
<br>
・定数aの物理的な定義を示す
<br>
時定数1/a=R*C -> 周期=2pi*R*C
<br>
cut-off角周波数a=1/(R*C) -> cut-off周波数=1/周期=1/(2pi*R*C)
<br>
・以上より、RC-1次遅れ要素の<a href="#span-out-evolution">時間発展</a>方程式が得られる
<br>
V*s=-V/(R*C)+I/C -> V*s=-a*V+b*I
<br>
<br>
<a href="#span-out-evolution">時間発展</a>方程式を離散化して漸化式を導出する
<br>
・時間刻みをdtとして<a href="#span-out-evolution">時間微分</a>V*sを1次精度の<a href="#span-out-fdm-differential">有限差分</a>で離散化する場合
<br>
　・右辺を既知関数とするEuler前進差分の陽解法explicit Euler method
<br>
(newV-oldV)/dt=-a*oldV+b*I -> newV=(1-a*dt)*oldV+b*dt*I
<br>
　・右辺を未知関数とするEuler後退差分の陰解法implicit Euler method
<br>
(newV-oldV)/dt=-a*newV+b*I -> newV=(oldV+b*dt*I)/(1+a*dt)
<br>
　・<a href="#span-out-error">modelling誤差</a>はOrder(dt)
<br>
・以上より、離散化した<a href="#span-out-evolution">時間発展</a>方程式は1次の漸化式に帰結する
<br>
<br>
漸化式の数値的安定性の要件（安定条件）を示す
<br>
・a&gt;0の前提
<br>
・陽解法の場合、<span class="run">|1-a*dt|&le;1</span>から0&le;dt&le;2/a（0≦時間刻み≦時定数<span class="clear">*2</span>）
<br>
　<span class="clear">Ver.2.51.25</span>以降、<span class="run">Von Neumannの安定性解析結果</span>から時定数の係数倍<span class="clear">*2</span>を追記して訂正
<br>
・陰解法の場合、<span class="run">|1/(1+a*dt)|&le;1</span>からdt&le;-2/a||0&le;dt（0≦時間刻みの範囲で無条件安定）
<br>
<br>
各parameterのOrder推定方法を示す
<br>
・<a href="#span-out-simulation-EIS">交流impedance</a>実測結果のs→∞に漸近する高周波数のZ(s)=R+1/(C*s)からRを推定
<br>
・推定Rとcut-off周波数=1/(2pi*R*C)からCを推定
<br>
<br>
実施例は<a href="#span-out-simulation-EIS">EIS simulation</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
拡散方程式
<br>
simplified
<br>
modelling
    </th>
    <td>
<span id="span-out-modelling-application2"></span>
拡散方程式のsimplified modellingについて記述する
<br>
<br>
<span class="selection">porous電極</span><span class="jF">活物質内</span><span class="condition">ionの</span>1次元拡散方程式のmodellingを一例に示す
<br>
・物質量||濃度の保存則はFick's laws
<br>
・反応物質量の保存則はFaraday's laws
<br>
・<span class="condition">反応ionの価数</span>を追加考慮
<br>
・<span class="selection">活物質の体積分率</span>を追加考慮
<br>
・<span class="clear">Ver.2.51.25</span>以降、<span class="jF">活物質の形状因子</span>を追加考慮（<a href="#span-pre-paper1">参考論文[1]</a>）
<br>
・時間を<a href="#span-out-fdm">有限差分法</a>で離散化
<br>
・空間を<a href="#span-out-fvm">有限体積法</a>で離散化
<br>
<br>
前提を列挙する
<br>
・電流Iと電圧Vは正の相関を前提とする
<br>
・Faraday定数をF[C/mol]とする
<br>
・拡散の代表長さをdxとする
<br>
・拡散係数をDsとする
<br>
・<span class="selection">活物質の体積分率</span>を<span class="selection">es</span>とする
<br>
・<span class="selection">有効拡散</span>係数を<span class="selection">Ds_eff</span>とする（<span class="selection">tortuosity</span>によって例えば、Ds_eff=Ds*es^1.5）
<br>
・<span class="condition">反応ionの価数</span>を<span class="condition">n</span>とする
<br>
・反応面積（反応界面の総表面積）をSとする
<br>
・<span class="jF">活物質の形状因子</span>を<span class="jF">as</span>とする
<br>
・有効反応面積をS<span class="jF">*as</span>とする
<br>
・<span class="condition">ion</span>濃度変化量Δc=代表濃度-平均濃度を定義する
<br>
・限界<span class="condition">ion</span>濃度をcmaxとする
<br>
・比例係数をkとする<span class="condition">ion</span>濃度変化量Δcと電圧Vの関係式V=Δc/(cmax*k)を仮定する
<br>
　⇒　θ=c/cmaxにおける微分係数V/Δθの逆数をkとする
<br>
<br>
1次元拡散方程式の右辺を示す
<br>
・活物質内を想定して左右の面のfluxをaboutに仮定する
<br>
電解質側の右面flux=I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>)
<br>
活物質側の左面flux=<span class="selection">Ds_eff*</span>Δc/dx
<br>
・fluxのdivergence項=(右面flux-左面flux)/dx
<br>
右辺=-<span class="selection">Ds_eff*</span>Δc/dx^2+I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx)
<br>
<br>
1次元拡散方程式の<a href="#span-out-evolution">時間発展</a>方程式を示す
<br>
・Fick's second law
<br>
<span class="selection">es*</span>Δc'=-<span class="selection">Ds_eff*</span>Δc/dx^2+I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx)
<br>
・<span class="condition">ion</span>濃度変化に伴う電圧に変換する
<br>
<span class="selection">es*</span>cmax*k*V'=-<span class="selection">Ds_eff*</span>cmax*k*V/dx^2+I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx)
<br>
V'=-<span class="selection">Ds_eff*</span>V/(dx^2<span class="selection">*es</span>)+I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx*<span class="selection">es*</span>cmax*k)
<br>
・次の定数を定義する
<br>
a=<span class="selection">Ds_eff</span>/(dx^2<span class="selection">*es</span>)
<br>
b=1/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx*<span class="selection">es*</span>cmax*k)
<br>
・<a href="#span-out-modelling-application1">RC並列回路</a>のanalogyから定数aの物理的な定義を示す
<br>
<span class="selection">有効拡散</span>の時定数1/a=(dx^2<span class="selection">*es</span>)/<span class="selection">Ds_eff</span>
<br>
<span class="selection">有効拡散</span>のcut-off角周波数a=<span class="selection">Ds_eff</span>/(dx^2<span class="selection">*es</span>)
<br>
・以上より、電圧に変換した1次元拡散方程式の<a href="#span-out-evolution">時間発展</a>方程式が得られる
<br>
V'=-<span class="selection">Ds_eff*</span>V/(dx^2<span class="selection">*es</span>)+I/(<span class="condition">n*</span>F*S<span class="jF">*as</span>*dx*<span class="selection">es*</span>cmax*k) -> V'=-a*V+b*I
<br>
<br>
<a href="#span-out-evolution">時間発展</a>方程式を離散化して漸化式を導出する
<br>
・時間刻みをdtとして<a href="#span-out-evolution">時間微分</a>V'を1次精度の<a href="#span-out-fdm-differential">有限差分</a>で離散化する場合
<br>
　・右辺を既知関数とするEuler前進差分の陽解法explicit Euler method
<br>
(newV-oldV)/dt=-a*oldV+b*I -> newV=(1-a*dt)*oldV+b*dt*I
<br>
　・右辺を未知関数とするEuler後退差分の陰解法implicit Euler method
<br>
(newV-oldV)/dt=-a*newV+b*I -> newV=(oldV+b*dt*I)/(1+a*dt)
<br>
　・<a href="#span-out-error">modelling誤差</a>はOrder(dt)
<br>
・以上より、離散化した<a href="#span-out-evolution">時間発展</a>方程式は1次の漸化式に帰結する
<br>
<br>
漸化式の数値的安定性の要件（安定条件）を示す
<br>
・a&gt;0の前提
<br>
・陽解法の場合、<span class="run">|1-a*dt|&le;1</span>から0&le;dt&le;2/a（0≦時間刻み≦<span class="selection">有効拡散</span>の時定数<span class="clear">*2</span>）
<br>
　<span class="clear">Ver.2.51.25</span>以降、<span class="run">Von Neumannの安定性解析結果</span>から時定数の係数倍<span class="clear">*2</span>を追記して訂正
<br>
・陰解法の場合、<span class="run">|1/(1+a*dt)|&le;1</span>からdt&le;-2/a||0&le;dt（0≦時間刻みの範囲で無条件安定）
<br>
<br>
各parameterのOrder推定方法を示す
<br>
・低周波数側の<a href="#span-out-simulation-EIS">交流impedance</a>実測結果から<a href="#span-out-modelling-application1">RC並列回路</a>同様に推定
<br>
・または、充放電後の緩和過程の電圧変化からaを推定
<br>
・推定aと充放電中の電圧変化からbを推定
<br>
<br>
実施例は<a href="#span-out-simulation-EIS">EIS simulation</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
1D-cell
<br>
simplified
<br>
modelling
    </th>
    <td>
<span id="span-out-modelling-application3"></span>
1D-cellのsimplified modellingについて記述する
<br>
<br>
実施例は<a href="#span-out-simulation-EIS-1D-cell">1D-cell EIS simulation</a>||<a href="#span-out-simulation-IV-1D-cell">1D-cell IV simulation</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
simulation
    </th>
    <td>
<span id="span-out-simulation"></span>
数値計算を応用するsimulationの実施例を列挙する
<br>
・<a href="#span-out-simulation-EIS">EIS simulation</a>
<br>
・<a href="#span-out-simulation-EIS-1D-cell">1D-cell EIS simulation</a>
<br>
・<a href="#span-out-simulation-IV-1D-cell">1D-cell IV simulation</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
EIS
<br>
simulation
    </th>
    <td>
<span id="span-out-simulation-EIS"></span>
EIS simulationの実施例について記述する
<br>
<br>
Electrochemical Impedance Spectroscopy（以降、EISと省略する）
<br>
のsimulationの背景と目的を列挙する
<br>
・等価回路fittingによる電気化学cellのsimulationは交流impedance実測結果の再現性が低い
<br>
・測定機の後処理同等（<a href="#span-out-UI-graphing-post-processor-encode">noise</a>処理を除く）のalgorithmを実装することで再現性を改善する
<br>
・定性的な理解とともにparameter推定の定量性改善に繋がる可能性が考えられる
<br>
<br>
<a href="#span-eqn-plot2d_EIS">plot2d_EIS</a>に示すZ変換（impedance演算部）の想定algorithmを列挙する
<br>
・電流Iと電圧Vは正の相関を前提とする
<br>
・各実測波形の角周波数をomegaとして時間tに対する<span class="clear">基準波形</span>exp(<span class="clear">-</span>i*omega*t)を作る
<br>
・得られた<a href="#span-out-com">複素数</a>の基準波形を各実測波形に時間領域で乗算する
<br>
・さらに、得られた<a href="#span-out-com">複素数</a>の各波形を<a href="#span-out-fdm-integral">合成Simpson公式</a>で時間積分する（<a href="#span-out-eqns">式変数</a><a href="#span-eqn-plot2d_EIS">FT_IV</a>）
<br>
・最後に、得られた各<a href="#span-out-com">複素数</a>の比からZ=zV/zIに変換する（<a href="#span-out-eqns">式変数</a><a href="#span-eqn-plot2d_EIS">calc_Z</a>）
<br>
・仮に、<a href="#span-out-modelling-application1">RC並列回路</a>の<span class="condition">cut-off周波数</span>で
<br>
　Zが<a href="#span-out-com">複素数</a>平面の<span class="condition">第4象限</span>（半円の頂点で位相が負）に位置しない場合、<span class="clear">基準波形を見直す</span>
<br>
<br>
<span class="run">Ver.2.64.27</span>以降、想定algorithmの補足を列挙する
<br>
・<span class="clear">基準波形</span>を含む時間積分は周期関数の連続Fourier変換||Laplace変換に同義
<br>
・Laplace領域||波数領域の変数s=i*omegaを定義して各実測波形を連続Fourier変換する
<br>
I(s)=FT(I(t))
<br>
V(s)=FT(V(t))
<br>
Z(s)=V(s)/I(s)
<br>
・以上より、時間領域から波数領域のZ(s)に変換する
<br>
<br>
<span class="run">Ver.2.64.27</span>以降、<a href="#span-eqn-plot2d_EIS_DFT">plot2d_EIS_DFT</a>に示す
<br>
hard/softの制約を考慮する場合、<a href="#span-eqn-plot2d_EIS">plot2d_EIS</a>の変化点を列挙する
<br>
・時間tに対する電流波形I(t)と電圧波形V(t)のsampling時刻/sampling間隔が同一を前提とする
<br>
・各実測波形の連続Fourier変換を<a href="#span-out-transform-dft">離散Fourier変換</a>で代替する
<br>
I(s)=DFT(I(t))
<br>
V(s)=DFT(V(t))
<br>
Z(s)=V(s)/I(s)
<br>
・以上より、時間領域から波数領域のZ(s)に変換する（高精度の時間積分は不要）
<br>
<br>
<span class="run">Ver.2.64.27</span>以降、想定algorithmの<a href="#span-out-error">数値誤差</a>について補足を列挙する
<br>
・時間積分に換算してZ変換の<a href="#span-out-error">数値誤差</a>を示す
<br>
　連続Fourier変換の場合、<a href="#span-out-fdm-integral">合成Simpson公式</a>のOrder(dt^4)
<br>
　<a href="#span-out-transform-dft">離散Fourier変換</a>の場合、<a href="#span-out-fdm-integral">台形公式</a>より低次のOrder(dt)
<br>
・I(t)||V(t)の<a href="#span-out-error">modelling誤差</a>がOrder(dt)の場合、Z変換の<a href="#span-out-error">数値誤差</a>は同等以下で支配しない
<br>
・実測結果も同様に、影響は小さいと考えられるが、より厳密には
<br>
　Z変換のalgorithmを統一する||Z変換前の波形を比較する
<br>
<br>
<a href="#span-eqn-plot2d_EIS">plot2d_EIS</a>||<a href="#span-eqn-plot2d_EIS_DFT">plot2d_EIS_DFT</a>||<a href="#span-eqn-plot2d_IV">plot2d_IV</a>に示す
<br>
simulation対象cellの等価回路要素（直列接続）を列挙する
<br>
・構造由来のinductance: L
<br>
・導電path上の電子伝導とion伝導を合成する直流抵抗: R0
<br>
・<a href="#span-out-modelling-application1">RC並列回路</a>で表すion挿入/脱離||還元/酸化の反応抵抗: R1,C1 -> a1,b1
<br>
・ion濃度分布緩和過程の電位変化に伴う<a href="#span-out-modelling-application2">拡散抵抗</a>（Warburg's Zの代替）: a2,b2
<br>
＜補足・詳細simulationで要修正＞
<br>
・負極||電解質||正極の影響は合成して区別しない
<br>
・電解質/活物質界面の被膜抵抗は反応抵抗に合成して区別しない
<br>
・電荷移動律速過程におけるButler-Volmer式の非線形性は考慮しない
<br>
・拡散律速過程における拡散抵抗の非線形性は考慮しない
<br>
・限界電流密度は考慮しない
<br>
<br>
test caseを示す
<br>
・<a href="#span-eqn-plot2d_EIS">plot2d_EIS</a>測定条件
<br>
電流振幅dI=1e-3
<br>
sweep開始周波数f0=1e3
<br>
sweep終了周波数f1=0.01
<br>
sweep周波数分割数Nf=10
<br>
積分1周期分割数Nt=100
<br>
積分周回数Nint=1
<br>
・各parameterの設定値
<br>
L=1e-4,
<br>
R0=1,
<br>
R1=2,C1=0.1, -> 1/(2pi*R1*C1)=0.7957747154594768（<span class="condition">cut-off周波数</span>≒1）
<br>
a1=1/(R1*C1),b1=1/C1, -> 1/a1=0.2（<span class="selection">時定数</span>=0.2）
<br>
a2=0.01,b2=0.12, -> 1/a2=100（<span class="selection">有効拡散の時定数</span>=100）
<br>
・<a href="#span-out-evolution">時間発展</a>の解法の設定値（陰解法選択）
<br>
isImplicit=1,
<br>
・logarithmic-scale等分割の周波数に対するZのsimulation結果
<br>
(
<br>
999.9999999999998,infoLost[ri] 1.000054390110971<span class="clear">+</span>0.626708495177503i:
<br>
316.22776601683796,infoLost[ri] 1.000197769963539<span class="clear">+</span>0.1936010152622332i:
<br>
100.00000000000004,infoLost[ri] 1.0008791279248923<span class="clear">+</span>0.046741593442684845i:
<br>
31.62277660168379,infoLost[ri] 1.0051946423727691<span class="clear">-</span>0.030877367568292336i:
<br>
10.00000000000001,infoLost[ri] 1.0370746940376958<span class="clear">-</span>0.15139417727049678i:
<br>
3.162277660168381,infoLost[ri] 1.2428463848394768<span class="clear">-</span>0.4426585101482536i:
<br>
<span class="condition">1,infoLost[ri] 1.9692074050771464</span><span class="clear">-</span><span class="condition">0.8189304441759584i:</span>
<br>
0.3162277660168378,infoLost[ri] 2.7478680202043564<span class="clear">-</span>0.6543142174993192i:
<br>
0.10000000000000024,infoLost[ri] 2.978079231896037<span class="clear">-</span>0.42406164035890753i:
<br>
0.031622776601683854,infoLost[ri] 3.0951852485694045<span class="clear">-</span>0.675153482065019i:
<br>
0.010000000000000012,infoLost[ri] 3.711459875093761<span class="clear">-</span>1.811702692783572i
<br>
)
<br>
・Nyquist-plot(real(Z),-imag(Z))
<br>
(
<br>
infoLost[ri] 1.000054390110971,infoLost[ri] -0.626708495177503:
<br>
infoLost[ri] 1.000197769963539,infoLost[ri] -0.1936010152622332:
<br>
infoLost[ri] 1.0008791279248923,infoLost[ri] -0.046741593442684845:
<br>
infoLost[ri] 1.0051946423727691,infoLost[ri] 0.030877367568292336:
<br>
infoLost[ri] 1.0370746940376958,infoLost[ri] 0.15139417727049678:
<br>
infoLost[ri] 1.2428463848394768,infoLost[ri] 0.4426585101482536:
<br>
infoLost[ri] 1.9692074050771464,infoLost[ri] 0.8189304441759584:
<br>
infoLost[ri] 2.7478680202043564,infoLost[ri] 0.6543142174993192:
<br>
infoLost[ri] 2.978079231896037,infoLost[ri] 0.42406164035890753:
<br>
infoLost[ri] 3.0951852485694045,infoLost[ri] 0.675153482065019:
<br>
infoLost[ri] 3.711459875093761,infoLost[ri] 1.811702692783572
<br>
)
<br>
・Bode-plot(log10(f),|Z|)
<br>
(
<br>
3,infoLost[ri] 1.1802001190933158:
<br>
2.5,infoLost[ri] 1.018762451286169:
<br>
2,infoLost[ri] 1.0019699622609723:
<br>
1.5,infoLost[ri] 1.005668772948065:
<br>
1.0000000000000004,infoLost[ri] 1.0480668480229642:
<br>
0.5000000000000002,infoLost[ri] 1.3193231950190327:
<br>
0,infoLost[ri] 2.13270365419317:
<br>
-0.5000000000000002,infoLost[ri] 2.8246956918725874:
<br>
-0.9999999999999989,infoLost[ri] 3.008119709432186:
<br>
-1.4999999999999991,infoLost[ri] 3.1679652692708244:
<br>
-1.9999999999999993,infoLost[ri] 4.130036446748411
<br>
)
<br>
・Bode-plot(log10(f),deg_phi)
<br>
(
<br>
3,infoLost[ri] 32.07431944473854:
<br>
2.5,infoLost[ri] 10.954854996909933:
<br>
2,infoLost[ri] 2.6738010400823766:
<br>
1.5,infoLost[ri] -1.7594470164364941:
<br>
1.0000000000000004,infoLost[ri] -8.305482098595858:
<br>
0.5000000000000002,infoLost[ri] -19.604124709935633:
<br>
<span class="condition">0,infoLost[ri] -22.58086538727024:</span>
<br>
-0.5000000000000002,infoLost[ri] -13.393680249677557:
<br>
-0.9999999999999989,infoLost[ri] -8.104114612346955:
<br>
-1.4999999999999991,infoLost[ri] -12.305194523809629:
<br>
-1.9999999999999993,infoLost[ri] -26.018737805525532
<br>
)
<br>
<br>
続けて電流振幅のみ変更dI=1の影響
<br>
・線形modelを前提とするため、Zのsimulation結果はほぼ一致
<br>
(
<br>
999.9999999999998,infoLost[ri] 1.0000543901109709+0.626708495177503i:
<br>
316.22776601683796,infoLost[ri] 1.0001977699635385+0.19360101526223303i:
<br>
100.00000000000004,infoLost[ri] 1.000879127924892+0.04674159344268477i:
<br>
31.62277660168379,infoLost[ri] 1.005194642372769-0.030877367568292353i:
<br>
10.00000000000001,infoLost[ri] 1.0370746940376954-0.15139417727049667i:
<br>
3.162277660168381,infoLost[ri] 1.2428463848394775-0.44265851014825364i:
<br>
<span class="condition">1,infoLost[ri] 1.9692074050771455-0.818930444175958i:</span>
<br>
0.3162277660168378,infoLost[ri] 2.7478680202043564-0.6543142174993192i:
<br>
0.10000000000000024,infoLost[ri] 2.978079231896035-0.42406164035890764i:
<br>
0.031622776601683854,infoLost[ri] 3.095185248569406-0.6751534820650186i:
<br>
0.010000000000000012,infoLost[ri] 3.71145987509376-1.8117026927835727i
<br>
)
<br>
<br>
続けて1周期分割数のみ変更Nt=300の影響
<br>
・Zのsimulation結果は<a href="#span-out-error">modelling誤差</a>のOrder(dt)で定量的に大差なし
<br>
(
<br>
999.9999999999998,infoLost[ri] 1.000020659557588+0.6267079711134935i:
<br>
316.22776601683796,infoLost[ri] 1.0000911276222495+0.19359899557421248i:
<br>
100.00000000000004,infoLost[ri] 1.0005422375176036+0.04673158634642843i:
<br>
31.62277660168379,infoLost[ri] 1.0041360205082939-0.03094497386189218i:
<br>
10.00000000000001,infoLost[ri] 1.0338770846371845-0.15195130473296967i:
<br>
3.162277660168381,infoLost[ri] 1.2354229873663194-0.44693493528151573i:
<br>
<span class="condition">1,infoLost[ri] 1.9658931475663823-0.834774843093126i:</span>
<br>
0.3162277660168378,infoLost[ri] 2.754521803915976-0.6657796106753855i:
<br>
0.10000000000000024,infoLost[ri] 2.9786451872376074-0.42699666778887413i:
<br>
0.031622776601683854,infoLost[ri] 3.0844475430285048-0.6771795132687214i:
<br>
0.010000000000000012,infoLost[ri] 3.678381237481611-1.8236767191289074i
<br>
)
<br>
<br>
続けて積分周回数のみ変更Nint=3の影響
<br>
・Zのsimulation結果は定性的に大差なし
<br>
(
<br>
999.9999999999998,infoLost[ri] 1.0000543775353226+0.6267084951674945i:
<br>
316.22776601683796,infoLost[ri] 1.0001973780496354+0.1936010142760755i:
<br>
100.00000000000004,infoLost[ri] 1.000867290892417+0.04674149927015193i:
<br>
31.62277660168379,infoLost[ri] 1.004870193211877-0.03088552575238536i:
<br>
10.00000000000001,infoLost[ri] 1.0304047344117009-0.1519236330216015i:
<br>
3.162277660168381,infoLost[ri] 1.1783944036609526-0.4587506996017625i:
<br>
<span class="condition">1,infoLost[ri] 1.845520769797103-0.9149750525109858i:</span>
<br>
0.3162277660168378,infoLost[ri] 2.725785909977971-0.7058617623925021i:
<br>
0.10000000000000024,infoLost[ri] 2.976327232225026-0.4319501793746518i:
<br>
0.031622776601683854,infoLost[ri] 3.0824015886720364-0.6769040880523296i:
<br>
0.010000000000000012,infoLost[ri] 3.5317647358815623-1.8403531943834652i
<br>
)
<br>
<br>
続けて<a href="#span-out-evolution">時間発展</a>の解法のみ変更isImplicit=0（陽解法選択）の影響
<br>
・<span class="selection">陽解法の安定条件</span>
<br>
dt&le;min(0.2,100)<span class="selection">*2</span>
<br>
1/(f*Nt)&le;0.4
<br>
<span class="selection">f&ge;0.025</span>
<br>
・Zのsimulation結果は<span class="selection">陽解法の安定条件</span>の範囲内で定性的に大差なし
<br>
(
<br>
<span class="selection">999.9999999999998,infoLost[ri] 1.0000543929898555+0.626708415628734i:</span>
<br>
<span class="selection">316.22776601683796,infoLost[ri] 1.0001978068781259+0.19360021990102563i:</span>
<br>
<span class="selection">100.00000000000004,infoLost[ri] 1.0008797482133391+0.04673364653178407i:</span>
<br>
<span class="selection">31.62277660168379,infoLost[ri] 1.0052082296658387-0.03095637279042429i:</span>
<br>
<span class="selection">10.00000000000001,infoLost[ri] 1.0373952733381435-0.15214941818882316i:</span>
<br>
<span class="selection">3.162277660168381,infoLost[ri] 1.2486473969330358-0.4481778175693221i:</span>
<br>
<span class="condition">1,infoLost[ri] 2.012036843642123-0.8250361448914947i:</span>
<br>
<span class="selection">0.3162277660168378,infoLost[ri] 2.8088203160184415-0.5898729668672302i:</span>
<br>
<span class="selection">0.10000000000000024,infoLost[ri] 3.003399673907799-0.3117472516446023i:</span>
<br>
<span class="selection">0.031622776601683854,infoLost[ri] 3.1017196891639354-0.5529342786020476i:</span>
<br>
0.010000000000000012,infoLost[ri] -6.24810011909696e+55-7.398061071461481e+55i
<br>
)
<br>
<br>
続けて連続Fourier変換を<a href="#span-out-transform-dft">離散Fourier変換</a>で代替の影響（<span class="run">Ver.2.64.27</span>追記）
<br>
・<a href="#span-eqn-plot2d_EIS_DFT">plot2d_EIS_DFT</a>に示すZのsimulation結果は定性的に大差なし
<br>
(
<br>
999.9999999999998,infoLost[ri] 1.0000543892797595+0.6392747864438679i:
<br>
316.22776601683796,infoLost[ri] 1.0001977616975484+0.19757406150509768i:
<br>
100.00000000000004,infoLost[ri] 1.0008790467041697+0.04799047769435572i:
<br>
31.62277660168379,infoLost[ri] 1.0051938738253914-0.030553331468587727i:
<br>
10.00000000000001,infoLost[ri] 1.0370682220140526-0.15188583273656356i:
<br>
3.162277660168381,infoLost[ri] 1.2428077197277516-0.4463003704640858i:
<br>
<span class="condition">1,infoLost[ri] 1.9691091944331642-0.8282224753004641i:</span>
<br>
0.3162277660168378,infoLost[ri] 2.747797860771646-0.6608797016283408i:
<br>
0.10000000000000024,infoLost[ri] 2.9780526592821848-0.42653152705817254i:
<br>
0.031622776601683854,infoLost[ri] 3.095161552636316-0.6774520967840967i:
<br>
0.010000000000000012,infoLost[ri] 3.71133683621205-1.8234973547405815i
<br>
)
<br>
<br>
電気化学cellの交流impedance測定における留意事項を列挙する（参考）
<br>
・Open Circuit Voltage測定中に測定対象は測定機の影響（主に暗電流）を受けて変化しない
<br>
・測定電流||電圧の入力と測定対象の応答がButler-Volmer式の線形領域の範囲内に収まる
<br>
・測定機と測定対象の接続線impedance（主にinductance）を分離できる
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
1D-cell
<br>
EIS
<br>
simulation
    </th>
    <td>
<span id="span-out-simulation-EIS-1D-cell"></span>
1D-cell EIS simulationの実施例について記述する
<br>
<br>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
1D-cell
<br>
IV
<br>
simulation
    </th>
    <td>
<span id="span-out-simulation-IV-1D-cell"></span>
1D-cell IV simulationの実施例について記述する
<br>
<br>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
時間発展
<br>
の解法
    </th>
    <td>
<span id="span-out-evolution"></span>
時間発展（時間積分）の解法について記述する
<br>
<br>
球の空気抵抗Cd_sphereを考慮する2次元の運動方程式を一例に示す
<br>
・vector演算を<a href="#span-out-com">複素数</a>演算で代替
<br>
・t=0の複素数zの初期値
<br>
　・初期位置z_x0=0
<br>
　・初速z_v0=20+20i
<br>
・時間刻みdtの微小区間を積分する<a href="#span-out-eqns">式変数</a>stepを定義
<br>
・時間tの区間を積分する<a href="#span-out-eqns">式変数</a>evolutionを定義
<br>
・step毎に位置z_xと速度z_vの連立方程式fの近似解を反復法で求解
<br>
・時間微分を1次精度の<a href="#span-out-fdm-differential">有限差分</a>で離散化する場合
<br>
　・右辺を既知関数とするEuler前進差分の陽解法explicit Euler method
<br>
f=&lt;{(z_x-z_x0)/dt=z_v0,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v0};
<br>
　・右辺を未知関数とするEuler後退差分の陰解法implicit Euler method
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
　・<a href="#span-out-error">modelling誤差</a>はOrder(dt)
<br>
・速度の時間微分が0（抵抗と重力が平衡）となる終端速度terminal velocity
<br>
0=m*z_a-Cd_sphere*z_v_terminal
<br>
z_v_terminal=(m/Cd_sphere)*z_a
<br>
・implicit Euler methodによる1次精度の<a href="#span-out-error-numerical">数値誤差</a>O(dt)を含む近似解を以下に示す
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
/*step=&lt;last{_rn(=&lt;run,,3),z_x0=z_x,z_v0=z_v};*/
<br>
step=&lt;last{_rn(=&lt;run,,3),{$z_x0,$z_v0}=x};
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
・t=0の位置z_x0, 速度z_v0
<br>
t=0; evolution;
<br>
z_x0 -> 0
<br>
z_v0 -> 20+20i
<br>
・t=1の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 11.111111111111112+6.7555555555555555i
<br>
z_v0 -> infoLost[r ] 8.88888888888889+3.444444444444444i
<br>
・t=2の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 16.049382716049386+4.31358024691358i
<br>
z_v0 -> infoLost[ri] 3.9506172839506175-3.9135802469135803i
<br>
・t=3の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 18.244170096021953-2.216186556927298i
<br>
z_v0 -> infoLost[ri] 1.755829903978052-7.183813443072703i
<br>
・t=4の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.21963115378754-10.562749580856577i
<br>
z_v0 -> infoLost[ri] 0.7803688462124675-8.637250419143424i
<br>
・t=5の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.653169401683353-19.716777591491812i
<br>
z_v0 -> infoLost[ri] 0.3468305983166522-9.28322240850819i
<br>
・t=6の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.845853067414826-29.22967892955192i
<br>
z_v0 -> infoLost[ri] 0.15414693258517875-9.570321070448085i
<br>
・t=7の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.931490252184368-38.902079524245295i
<br>
z_v0 -> infoLost[ri] 0.068509747815635-9.697920475754705i
<br>
・t=10の位置z_x0, 速度z_v0
<br>
t=3; evolution;
<br>
z_x0 -> infoLost[ri] 19.99398542680357-68.20896171406268i
<br>
z_v0 -> infoLost[ri] 0.006014573196434349-9.791038285937313i
<br>
・terminal velocityに収束
<br>
z_v_terminal=(m/Cd_sphere)*z_a; z_v_terminal -> -9.8i
<br>
<br>
近似解の収束判定条件を設定する場合、stepの一例を示す
<br>
・上記の線形方程式の場合、反復3回で十分収束するため、固定値を設定
<br>
orderT=1;
<br>
Nmax=10;
<br>
epsf=max(eps*1e3,pow(dt,orderT));
<br>
step_pre=&lt;{normf=max_value};
<br>
step_iteration=&lt;_rn(=&lt;{switch(normf>epsf,=&lt;{normf=run})},,Nmax);
<br>
step_post=&lt;{$z_x0,$z_v0}=x;
<br>
step=&lt;last{step_pre,step_iteration,step_post};
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.993985426803565-68.20896171406268i:
<br>
0.006014573196434349-9.791038285937313i
<br>
)
<br>
・t=20
<br>
t=10; evolution; x ->
<br>
(
<br>
infoLost[ i] 19.99999819124547-166.20000269504428i:
<br>
infoLost[ i] 0.0000018087545367633257-9.79999730495574i
<br>
)
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、<a href="#span-out-FNmh-newtonian">Newton高階行列関数</a>で収束判定条件を設定する場合
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
orderT=1;
<br>
Nmax=10;
<br>
epsN=max(eps*1e3,pow(dt,orderT));
<br>
step_post=&lt;{$z_x0,$z_v0}=x;
<br>
step=&lt;last{step_iteration,step_post};
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
・絶対誤差指定の場合
<br>
step_iteration=&lt;mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial,,Nmax,epsN);
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.993985426803565-68.20896171406268i+O(1e+1+1e+1i):
<br>
0.006014573196434349-9.791038285937313i+O(5e+0+6e+0i)
<br>
)
<br>
・t=20
<br>
t=10; evolution; x ->
<br>
(
<br>
infoLost[ i] 19.99999819124547-166.20000269504428i+O(1e+1+1e+1i):
<br>
infoLost[ i] 0.0000018087545367633257-9.79999730495574i+O(5e+0+6e+0i)
<br>
)
<br>
・相対誤差指定の場合
<br>
{$z_x,$z_v}=x_initial;
<br>
step_iteration=&lt;mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial,,Nmax,epsN*norm(x));
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.99398542072955-68.2089617113703i+O(9e+0+8e+0i):
<br>
0.006014573196568362-9.791038285939853i+O(4e+0+7e+0i)
<br>
)
<br>
・t=20
<br>
t=10; evolution; x ->
<br>
(
<br>
19.999998167764087-166.20000267865885i+O(9e+0+8e+0i):
<br>
0.000001808754536971318-9.799997304955744i+O(4e+0+7e+0i)
<br>
)
<br>
・第7引数で相対誤差指定の場合
<br>
step_iteration=&lt;mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial,,Nmax,epsN,1);
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.993985420600577-68.20896171053013i+O(1e+1+1e+1i):
<br>
0.006014573196594959-9.79103828593924i+O(5e+0+6e+0i)
<br>
)
<br>
・t=20
<br>
t=10; evolution; x ->
<br>
(
<br>
19.999998167635148-166.20000267781805i+O(1e+1+1e+1i):
<br>
0.0000018087545369793175-9.799997304955744i+O(5e+0+6e+0i)
<br>
)
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、<a href="#span-out-matching">行列要素pattern matching</a>のnestingに対応
<br>
・次のstepを許容するが、別々に記述した方が間違いが少ない
<br>
storage cleared
<br>
step=&lt;last{mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial,,Nmax,epsN),{$z_x0,$z_v0}=x};
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
orderT=1;
<br>
Nmax=10;
<br>
epsN=max(eps*1e3,pow(dt,orderT));
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.993985426803565-68.20896171406268i+O(1e+1+1e+1i):
<br>
0.006014573196434349-9.791038285937313i+O(5e+0+6e+0i)
<br>
)
<br>
・t=20
<br>
t=10; evolution; x ->
<br>
(
<br>
infoLost[ i] 19.99999819124547-166.20000269504428i+O(1e+1+1e+1i):
<br>
infoLost[ i] 0.0000018087545367633257-9.79999730495574i+O(5e+0+6e+0i)
<br>
)
<br>
<br>
<a href="#span-out-FNmh-OX">ODE高階行列関数</a>を使用する場合、stepを陽的に解くため、収束演算不要
<br>
・実軸の時間積分の場合、<a href="#span-out-error-numerical">目安の解析誤差</a>は実数のみ表示される（仕様）
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v};
<br>
step=&lt;{x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,0,dt)};
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
{$z_x,$z_v}=x_initial;
<br>
・t=0
<br>
t=0; evolution; x ->
<br>
(
<br>
0:
<br>
20+20i
<br>
)
<br>
・t=1
<br>
t=1; evolution; x ->
<br>
(
<br>
12.636583116319443+9.028508843315972i+O(6e-2):
<br>
7.363416883680557+1.171491156684028i+O(6e-2)
<br>
)
<br>
・t=2
<br>
t=1; evolution; x ->
<br>
(
<br>
17.289004589856408+6.160616838886046i+O(6e-2):
<br>
2.710995410143594-5.760616838886047i+O(6e-2)
<br>
)
<br>
・t=3
<br>
t=1; evolution; x ->
<br>
(
<br>
19.001890531268412-1.0871831084100707i+O(6e-2):
<br>
0.9981094687315916-8.312816891589929i+O(6e-2)
<br>
)
<br>
・t=4
<br>
t=1; evolution; x ->
<br>
(
<br>
19.63252519430902-9.947537460479563i+O(6e-2):
<br>
0.36747480569098157-9.252462539520439i+O(6e-2)
<br>
)
<br>
・t=5
<br>
t=1; evolution; x ->
<br>
(
<br>
19.86470649057239-19.40158732904714i+O(6e-2):
<br>
0.1352935094276103-9.598412670952861i+O(6e-2)
<br>
)
<br>
・t=6
<br>
t=1; evolution; x ->
<br>
(
<br>
19.950188874421418-29.074218577112084i+O(6e-2):
<br>
0.049811125578583-9.725781422887913i+O(6e-2)
<br>
)
<br>
・t=7
<br>
t=1; evolution; x ->
<br>
(
<br>
19.981660995845978-38.827325116189485i+O(6e-2):
<br>
0.018339004154023522-9.772674883810506i+O(6e-2)
<br>
)
<br>
・t=10
<br>
t=3; evolution; x ->
<br>
(
<br>
19.999084783315336-68.20136367286014i+O(6e-2):
<br>
0.0009152166846619435-9.798636327139855i+O(6e-2)
<br>
)
<br>
・2次精度選択の場合（参考）
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.998345638774897-68.20246499822541i+O(3e-1):
<br>
0.0016543612251060553-9.797535001774593i+O(3e-1)
<br>
)
<br>
<br>
<span class="run">Ver.2.29.15</span>以降、<a href="#span-out-FNmh-OX">ODE高階行列関数</a>第6引数で反復回数を指定する場合
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v};
<br>
stepN=&lt;last{N=round(t/dt),x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,0,dt,N)};
<br>
evolution=&lt;stepN;
<br>
・t=0
<br>
t=0; evolution; x ->
<br>
(
<br>
0:
<br>
20+20i
<br>
)
<br>
・t=5
<br>
t=5; evolution; x ->
<br>
(
<br>
19.86470649057239-19.40158732904714i+O(6e-2):
<br>
0.1352935094276103-9.598412670952861i+O(6e-2)
<br>
)
<br>
・t=10
<br>
t=5; evolution; x ->
<br>
(
<br>
19.999084783315336-68.20136367286014i+O(6e-2):
<br>
0.0009152166846619435-9.798636327139855i+O(6e-2)
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-linear"></span>
連立線形方程式の解法について記述する
<br>
<br>
連立方程式の解法には直接法と反復法の2種類が存在し、特徴を列挙する
<br>
・直接法は解を厳密に解くため、線形方程式のみ適用可
<br>
・反復法は解の修正を繰り返して近似的に解くため、非線形方程式に拡張可
<br>
<br>
full-rank2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
<br>
直接法
<br>
・pivot選択の前処理付きGaussの消去法を用いる
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
x=Gauss(A,b); x -> (-3.9999999999999982:4.499999999999999)
<br>
x=Gauss((1,2:3,4),{5,6}); x -> (-3.9999999999999982:4.499999999999999)
<br>
・解のdouble-check
<br>
A(x) -> (5:6.000000000000002)
<br>
・<a href="#span-out-array">行列操作</a>を駆使して演算内容を以下に示す
<br>
・pivot選択
<br>
A=(1,2:3,4); A=(A[1]:A[0]); A -> (3,4:1,2)
<br>
b={5,6}; b=(b[1]:b[0]); b -> (6:5)
<br>
・前進消去
<br>
k=A[1][0]/A[0][0]; k -> 0.3333333333333333
<br>
・行vectorの左から無次元係数kを積
<br>
A[1]=A[1]-k(A[0]); A -> (3,4:0,0.6666666666666667)
<br>
b[1]=b[1]-k(b[0]); b -> (6:3)
<br>
・後退代入
<br>
x={,}; x -> (0:0)
<br>
x[1]=b[1]/A[1][1]; x -> (0:4.499999999999999)
<br>
x[0]=(b[0]-A[0]x)/A[0][0]; x -> (-3.9999999999999982:4.499999999999999)
<br>
・<a href="#span-out-eqns">式変数</a>を使用して上記algorithmを一般化する
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1),
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp});
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w};
<br>
pivotting=&lt;{ir_comp=ir+1,ir_pivot=ir,compare,switch(ir&lt;&gt;ir_pivot,=&lt;proc),ir=ir+1,=&lt;A}=&gt;;
<br>
ir=0;
<br>
pivotting -> (3,4:1,2)
<br>
pivotting -> [MyErr]Invalid reference of array
<br>
forward=&lt;{ir=ir+1,k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic]),=&lt;A}=&gt;;
<br>
ic=0; ir=ic;
<br>
forward -> (3,4:0,0.6666666666666667)
<br>
forward -> [MyErr]Invalid reference of array
<br>
ic=ic+1; ir=ic;
<br>
forward -> [MyErr]Invalid reference of array
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir],ir=ir-1,=&lt;x}=&gt;;
<br>
ir -> 1
<br>
backward -> (0:4.499999999999999)
<br>
backward -> (-3.9999999999999982:4.499999999999999)
<br>
backward -> [MyErr]Invalid reference of array
<br>
・実際には重複する演算や自明の演算は行わないが、ここでは簡潔に記述する
<br>
厳密な記述は<a href="#span-eqn-solvex_Gauss">strict-mode式変数list-solvex_Gauss</a>参照
<br>
・さらに、<a href="#span-out-FNh-SX">総和高階関数</a>を使用して反復処理を記述する
<br>
・dummy変数を使用するだけで総和は無次元の0を返す
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1),
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp});
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w};
<br>
pivotting=&lt;last{ir_pivot=ir,compare,switch(ir&lt;&gt;ir_pivot,=&lt;proc)};
<br>
_sir(=&lt;{_sir_comp(=&lt;pivotting,ir+1,sizeA-1)},0,sizeA-2);
<br>
A -> (3,4:1,2)
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A -> (3,4:0,0.6666666666666667)
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
_sir(=&lt;backward,sizeA-1,0);
<br>
x -> (-3.9999999999999982:4.499999999999999)
<br>
・最後に、一連のalgorithmを一般化した<a href="#span-out-eqns">式変数</a>solvexを定義する
<br>
・pivot選択ありの場合
<br>
storage cleared
<br>
solvex_pivotting=&lt;{
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp}),
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w},
<br>
pivotting=&lt;last{ir_pivot=ir,compare,switch(ir&lt;&gt;ir_pivot,=&lt;proc)},
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])},
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]},
<br>
sizeA=size(A),
<br>
x=zeros(sizeA,1),
<br>
_sir(=&lt;{_sir_comp(=&lt;pivotting,ir+1,sizeA-1)},0,sizeA-2),
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0),
<br>
=&lt;x}=&gt;;
<br>
・pivot選択なしの場合
<br>
storage cleared
<br>
solvex_no_pivotting=&lt;{
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])},
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]},
<br>
sizeA=size(A),
<br>
x=zeros(sizeA,1),
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0),
<br>
=&lt;x}=&gt;;
<br>
・続けてtest caseを示す
<br>
・pivot選択ありの場合
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
solvex_pivotting -> (-3.9999999999999982:4.499999999999999)
<br>
・pivot選択なしの場合（参考）
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
solvex_no_pivotting -> (-4:4.5)
<br>
<br>
反復法
<br>
・連立方程式と未知変数初期値（以降、初期値と省略する）を定義する
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
x0=0;
<br>
x1=0;
<br>
x=&lt;{x0,x1}; x_initial=&lt;{x0,x1};
<br>
・連立方程式を展開しない場合
<br>
f=&lt;{A(x)=b}; || f=&lt;{=b-A(x)}; || f=&lt;{b-A(x)};
<br>
・連立方程式を展開する場合
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
・いずれの結果も以下に同じ
<br>
・続けて以降の処理を反復する
<br>
J=Jacobi(=&lt;f,=&lt;x,=&lt;x_initial);
<br>
dx=Gauss(J,-f);
<br>
x_next=x+dx;
<br>
x0=x_next[0];
<br>
x1=x_next[1];
<br>
normf=max(norm(f),norm(-dx));
<br>
・反復3回目のnormと近似解を示す
<br>
normf -> infoLost[ri] 2.2204460494935903e-15
<br>
x0 -> infoLost[ri] -3.999999999999999-3.362471994400586e-26i
<br>
x1 -> infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
・normが<a href="#span-out-epsilon">Machine epsilon</a>に収束すれば収束判定条件を満たす
<br>
・その場合、近似解は厳密解にほぼ一致する
<br>
・線形方程式の場合、即座に解付近に飛ぶため、収束が速い
<br>
<br>
上記の線形・非線形の連立方程式を一般化する解法について記述する
<br>
・近似解の列vector{x}の各要素を表す添字をjとする
<br>
・方程式の列vector{f}の各要素を表す添字をiとする
<br>
・これより方程式の全微分dfを次のtensorで表記する
<br>
{df[i]}=(df[i]/dx[j]){dx[j]}
<br>
・左辺の全微分を単純に仮定すると（Jacobi行列に高精度を求めない理由）
<br>
{df[i]}={0-f[i]}
<br>
・Ax=bの連立線形方程式に一般化されたNewton法が導出される
<br>
・ここで、単項の符号は<a href="#span-out-FNm">Scalar倍</a>||zeros行列との差||和で定義される
<br>
(df[i]/dx[j]){dx[j]}={-f[i]}
<br>
A=(df[i]/dx[j])
<br>
x={dx[j]}
<br>
b={-f[i]}
<br>
・Jacobi行列Aがfull-rankであれば求解の必要十分条件を満たす
<br>
・求解して得られたdx（解の修正vector）を用いて近似解を修正する
<br>
<br>
上記の反復1回の処理をまとめた<a href="#span-out-FNmh-newtonian">Newton高階行列関数</a>について記述する
<br>
・<a href="#span-out-FNm">Scalar倍</a>の符号位置を変えて次の連立線形方程式を直接法で解く
<br>
A=(df[i]/dx[j])
<br>
x={-dx[j]}
<br>
b={f[i]}
<br>
・さらに、得られた符号付の解の修正vectorをmdxとして
<br>
・近似解のvectorを一度に修正する（local変数を上書きする）
<br>
x=x-mdx
<br>
<br>
以上より、反復1回の処理を簡潔にまとめる
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{0,0};
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
・実行用の<a href="#span-out-eqns">式変数</a>runを定義してnormのみ表示する
<br>
<br>
反復を実行
<br>
run -> 6.020797289251035
<br>
run -> 2.0548659974995737e-10
<br>
・反復3回目のnormと近似解は先述の通り一致する
<br>
run -> infoLost[ri] 2.2204460494935903e-15
<br>
x ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
)
<br>
<br>
<a href="#span-out-FNh-RX">再帰高階関数</a>を使用して反復を実行
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{0,0};
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.2204460494935903e-15
<br>
x ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
)
<br>
<br>
rank落ち3元⇒実質2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
・Aの2行目を2倍して3行目を引くと1行目になる
<br>
・この場合、3階から2階へのrank落ちと呼ぶ
<br>
・rank落ちの場合、逆行列が不定で多くの場合、解が発散するが、
<br>
・本例では右辺bも成立するため、解が偶然見つかる
<br>
<br>
直接法
<br>
・解はalgorithmに従って一意に求まる
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=Gauss(A,b); x -> (-25.333333333333332:41.666666666666664:-16)
<br>
A(x) -> (10i:10.999999999999986i:12i)
<br>
・algorithmを以下に示す
<br>
・pivot選択は<a href="#span-out-array">行列操作</a>で示す
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i); A=(A[2]:A[1]:A[0]);
<br>
b={10i,11i,12i}; b=(b[2]:b[1]:b[0]);
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1);
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A ->
<br>
(
<br>
7i,8i,9i:
<br>
0,0.4285714285714288i,0.8571428571428577i:
<br>
0,-1.1102230246251565e-16i,-2.220446049250313e-16i
<br>
)
<br>
・前進消去後、rank落ちの対角要素は限りなく0に近づく
<br>
・よって多くの場合、次の後退代入で解が発散する
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
_sir(=&lt;backward,sizeA-1,0);
<br>
x -> (-25.333333333333332:41.666666666666664:-16)
<br>
・先述の<a href="#span-out-eqns">式変数</a>solvexを使用
<br>
・pivot選択ありの場合
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
solvex_pivotting -> (-25.333333333333332:41.666666666666664:-16)
<br>
・pivot選択なしの場合（参考）
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
solvex_no_pivotting -> [MyErr]FN isNaN
<br>
・前進消去後、rank落ちの対角要素が0になる
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1);
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A -> (i,2i,3i:0,-3i,-6i:0,0,0)
<br>
・よって次の後退代入で解が発散する
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
ir=sizeA-1; A[ir][ir] -> 0
<br>
backward -> [MyErr]FN isNaN
<br>
<br>
反復法
<br>
・解が不定のため、偶然得られる近似解は初期値によって大きく異なる
<br>
・初期値がzeros-vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;{0,0,0};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.000002904400992198821
<br>
x ->
<br>
(
<br>
338886.6528089325-469606.73307464283i:
<br>
-677782.3056178652+939213.4661492857i:
<br>
338895.986142266-469606.7330746428i
<br>
)
<br>
A(x) -> (-2.3283064365386963e-10+10.000000000116415i:11i:12i)
<br>
・初期値が<a href="#span-out-com">虚数単位</a>vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;{i,i,i};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.000011389894276669376
<br>
x ->
<br>
(
<br>
-6.91661370055543-4.416691871261055i:
<br>
4.833227401110859+8.83338374252211i:
<br>
2.4167196327779044-4.416691871261055i
<br>
)
<br>
A(x) -> (10.000000000000002i:11.000000000000005i:12.000000000000007i)
<br>
・初期値が直接法による厳密解の場合
<br>
・rank落ちの場合、近似解が厳密解に近づくとは限らない
<br>
・Jacobi行列の<a href="#span-out-error-numerical">数値誤差</a>が初期値の厳密解に上乗せして残る
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;(-25.333333333333332:41.666666666666664:-16);
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.00013856472352298855
<br>
x ->
<br>
(
<br>
-25.33341533331434-0.00008200052251608464i:
<br>
41.66683066662869+0.0001640010450321693i:
<br>
-16.000081999981045-0.00008200052251608478i
<br>
)
<br>
A(x) ->
<br>
(
<br>
3.2526065174565133e-19+9.999999999999915i:
<br>
6.505213034913027e-19+10.999999999999844i:
<br>
9.75781955236954e-19+11.999999999999773i
<br>
)
<br>
<br>
続けてrank落ち3元⇒実質2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
・本例では右辺bが成立しないため、解が発散する
<br>
<br>
直接法
<br>
・解が17桁を超えて発散する
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
x=Gauss(A,b);
<br>
x ->
<br>
(
<br>
infoLost[r ] 54043195528445890+54043195528445910i:
<br>
-108086391056891790-108086391056891840i:
<br>
54043195528445900+54043195528445930i
<br>
)
<br>
A(x) -> (infoLost[r ] -32+32i:infoLost[r ] 64i:infoLost[r ] -64)
<br>
<br>
反復法
<br>
・初期値に依らず、解が発散する
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
x=&lt;{x0,x1,x2};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
run -> 234013055737.99323
<br>
run -> 44.17305431734149
<br>
run -> [MyErr]FN isNaN
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
逆行列
<br>
の解法
    </th>
    <td>
<span id="span-out-inverse"></span>
逆行列の反復解法について記述する
<br>
<br>
任意の正方行列Aの逆行列Ainvを次の関係式から反復法で求解する
<br>
Ainv*A=単位行列identity(size(A))
<br>
<br>
full-rank2階の場合
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
Ainv=&lt;(x0,x1:x2,x3);
<br>
x=&lt;{x0,x1,x2,x3};
<br>
・連立方程式を展開しない場合
<br>
f=&lt;{Ainv*A=identity2}; || f=&lt;{=identity2-Ainv*A}; || f=&lt;{identity2-Ainv*A};
<br>
・連立方程式を展開する場合
<br>
f=&lt;{x0+3x1=1,2x0+4x1=0,x2+3x3=0,2x2+4x3=1};
<br>
・いずれの結果も以下に同じ
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 4.965068306494841e-16
<br>
Ainv ->
<br>
(
<br>
infoLost[ri] -2-1.405479820560668e-34i,
<br>
infoLost[ri] 1+7.02739910280334e-35i:
<br>
infoLost[ i] 1.5000000000000002+2.2201233082568935e-28i,
<br>
infoLost[ i] -0.5000000000000001+5.05296129055519e-28i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ri] 1+7.02739910280334e-35i,
<br>
infoLost[ri] 0:
<br>
infoLost[ i] -2.220446049250313e-16+1.7379007179922464e-27i,
<br>
infoLost[ i] 1+2.4652091778734548e-27i
<br>
)
<br>
<br>
<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>を使用
<br>
・逆行列Ainvと未知変数ベクトルxを一般化して記述する
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8) || _eAinv(=&lt;{x},3,3) -> 0
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8} || _ex(=&lt;{x},3*3,1) -> 0
<br>
・逆行列を解く<a href="#span-out-eqns">式変数</a>solveAinvを定義する
<br>
solveAinv=&lt;{
<br>
sizeA=size(A),
<br>
_eAinv(=&lt;{x},sizeA,sizeA),
<br>
_ex(=&lt;{x},sizeA*sizeA,1),
<br>
f=&lt;{Ainv*A=identity(sizeA)},
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx))),
<br>
_rn(=&lt;run,,3),
<br>
=&lt;Ainv}=&gt;;
<br>
<br>
full-rank3階の場合
<br>
storage cleared
<br>
A=(i,2,3i:4,5i,6:7i,8,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 3.4546432349907805e-16
<br>
Ainv ->
<br>
・<a href="#span-out-eqns">式変数</a>solveAinvを使用
<br>
A=(i,2,3i:4,5i,6:7i,8,9i); solveAinv ->
<br>
(
<br>
infoLost[ri] -1.8979941071411976e-27+0.7750000000000002i,
<br>
infoLost[ri] 0.05-4.672139890674269e-28i,
<br>
infoLost[ri] 4.304317789445746e-28-0.22500000000000006i:
<br>
infoLost[ri] 0.05000000000000003+8.567561244782949e-29i,
<br>
infoLost[ri] 3.393936952792186e-29-0.1i,
<br>
infoLost[ri] 0.05+8.5354798231355e-30i:
<br>
infoLost[ri] 2.8820733759262382e-36-0.5583333333333333i,
<br>
infoLost[ri] 0.05+4.64802404929633e-38i,
<br>
infoLost[ri] -9.847979430502188e-37+0.10833333333333334i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ri] 1.0000000000000002-7.538276107988833e-28i,
<br>
infoLost[ri] 1.983535962611336e-27,
<br>
infoLost[ri] -4.623380245326983e-27i:
<br>
infoLost[ri] -9.666493098090539e-30+5.551115123125783e-17i,
<br>
infoLost[ri] 1+4.093319111203523e-28i,
<br>
infoLost[ri] -1.302099385841768e-28:
<br>
infoLost[ri] -3.82559126345344e-36i,
<br>
infoLost[ri] -2.3466379950140902e-36,
<br>
infoLost[ri] 1+6.192008328452557e-38i
<br>
)
<br>
<br>
full-rank4階の場合
<br>
storage cleared
<br>
A=(i+1,2-i,3i,4:5i,6-i,7,8i:9-5i,10i,-11+3i,12-5i:-13,14i,-15,16i);
<br>
Ainv=&lt;(x0,x1,x2,x3:x4,x5,x6,x7:x8,x9,x10,x11:x12,x13,x14,x15);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15};
<br>
f=&lt;{Ainv*A=identity4};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.9893669801409083e-16
<br>
Ainv ->
<br>
・<a href="#span-out-eqns">式変数</a>solveAinvを使用
<br>
A=(i+1,2-i,3i,4:5i,6-i,7,8i:9-5i,10i,-11+3i,12-5i:-13,14i,-15,16i); solveAinv ->
<br>
(
<br>
0.06841552622694629+0.2755281676127789i,
<br>
infoLost[r ] 0.017370056945596502+0.04070708231511685i,
<br>
0.03704852337184109+0.014871122300002907i,
<br>
infoLost[r ] -0.0771427485472948+0.029183958646809872i:
<br>
infoLost[r ] -0.2463189713572816+0.22391026429285282i,
<br>
0.03674146878053252-0.07376715131162677i,
<br>
infoLost[ i] 0.011750959713282166-0.06258676545881785i,
<br>
infoLost[r ] -0.023736051458965405-0.035441311604425964i:
<br>
0.042729078026869684-0.37565683291263197i,
<br>
infoLost[ri] 0.10071161649924316+0.02655781643708819i,
<br>
0.018188177584406696+0.012939541975857932i,
<br>
0.039537548991770054+0.015088101343933952i:
<br>
infoLost[ i] 0.08721745526741176-0.29156760696583045i,
<br>
infoLost[ i] 0.025823672107836676-0.04398405433866421i,
<br>
0.013931517721997284+0.007610078051463436i,
<br>
infoLost[ri] 0.05862610643706584-0.005876821331234674i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[r ] 1+5.551115123125783e-17i,
<br>
infoLost[r ] 5.551115123125783e-17-2.220446049250313e-16i,
<br>
infoLost[r ] 2.220446049250313e-16+5.551115123125783e-17i,
<br>
infoLost[r ] 1.1102230246251565e-16+2.220446049250313e-16i:
<br>
infoLost[ri] -5.551115123125783e-17-5.551115123125783e-17i,
<br>
infoLost[ri] 1+1.1102230246251565e-16i,
<br>
infoLost[ri] -1.1102230246251565e-16+1.1102230246251565e-16i,
<br>
infoLost[ri] -1.1102230246251565e-16+5.551115123125783e-17i:
<br>
infoLost[ri] -1.1102230246251565e-16+5.551115123125783e-17i,
<br>
infoLost[ri] -2.7755575615628914e-17+1.1102230246251565e-16i,
<br>
infoLost[ri] 0.9999999999999998,
<br>
infoLost[ri] 0:
<br>
infoLost[ri] -4.163336342344337e-17i,
<br>
infoLost[ri] -1.1102230246251565e-16i,
<br>
infoLost[ri] 2.220446049250313e-16-1.3877787807814457e-17i,
<br>
infoLost[ri] 1-1.1102230246251565e-16i
<br>
)
<br>
<br>
rank落ち3階⇒実質2階の場合
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
・rank落ちの場合、逆行列が一意に定まらず、不定となる
<br>
・また、行列式は限りなく0に近づく
<br>
・よって多くの場合、逆行列を求める過程で発散する
<br>
・初期値がzeros-vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
f=&lt;{
<br>
x0(i)+x1(4i)+x2(7i)=1,x0(2i)+x1(5i)+x2(8i)=0,x0(3i)+x1(6i)+x2(9i)=0,
<br>
x3(i)+x4(4i)+x5(7i)=0,x3(2i)+x4(5i)+x5(8i)=1,x3(3i)+x4(6i)+x5(9i)=0,
<br>
x6(i)+x7(4i)+x8(7i)=0,x6(2i)+x7(5i)+x8(8i)=0,x6(3i)+x7(6i)+x8(9i)=1
<br>
};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
run -> infoLost[ i] 2787964185176708
<br>
run -> [MyErr]FN isNaN
<br>
・初期値を変えてもnormが収束することはない
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
h=(-i);
<br>
x_initial=&lt;{h,h,h,h,h,h,h,h,h};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
run -> infoLost[ i] 23884062379.765785
<br>
run -> infoLost[ i] 3.9299189118519258
<br>
run -> infoLost[ i] 3.5355470563991256
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ i] 1.00262451171875-0.20006942749023438i,
<br>
infoLost[ i] 0.22774887084960938-0.0094451904296875i,
<br>
infoLost[ i] -0.547119140625+0.18117904663085938i:
<br>
infoLost[ i] -0.042938232421875-0.18405914306640625i,
<br>
infoLost[ i] 0.2579803466796875+0.04792022705078125i,
<br>
infoLost[ i] 0.55889892578125+0.2799072265625i:
<br>
infoLost[ i] 0.149261474609375+0.017391204833984375i,
<br>
infoLost[ i] 0.5675315856933594+0.01317596435546875i,
<br>
infoLost[ i] 0.9858055114746094+0.008953094482421875i
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
非線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-non-linear"></span>
連立非線形方程式の反復解法について記述する
<br>
<br>
<a href="#span-out-com">虚数単位</a>を求めるfull-rank1元2次の方程式を一例に示す
<br>
x0^2+1=0
<br>
・解を2個示す
<br>
x0=i; x0^2+1=0 -> -1.2246467991473532e-16i
<br>
x0=-i; x0^2+1=0 -> 1.2246467991473532e-16i
<br>
・非線形方程式を定義する
<br>
storage cleared
<br>
x=&lt;{x0};
<br>
f=&lt;{x0^2+1=0};
<br>
<br>
初期値を1+2iとした反復6回目の近似解を示す
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;{1+2i}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> 4.848187063331881e-11
<br>
x -> 6.918085522901255e-17+0.9999999999999997i
<br>
<br>
初期値を1-2iとした反復6回目の近似解を示す
<br>
・上記演算に続けてClear実行しない場合、初期値を直接更新して実行
<br>
x0=1-2i;
<br>
_rn(=&lt;run,,6) -> 4.2544881989018353e-11
<br>
x -> -5.067058578678027e-17-1.0000000000000002i
<br>
・方程式||関数の次数に応じて収束までの反復回数が増える
<br>
<br>
<a href="#span-out-ope">実数演算</a>の場合、解が存在しないため、収束しない
<br>
・2次の方程式の場合、右辺に移項した関数の極値周辺を右往左往する
<br>
storage cleared
<br>
x=&lt;{x0};
<br>
f=&lt;{real(x0)^2+1=0}; || f=&lt;{-(real(x0)^2+1)};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;{1}),max(norm(f),norm(mdx)));
<br>
run -> 1.414206491330789
<br>
run -> 2500010689.1876636
<br>
run -> 625005364.923743
<br>
run -> 156251267.10125032
<br>
run -> 39062798.523787886
<br>
run -> 9765710.483364047
<br>
run -> 2441427.7048029117
<br>
run -> 610357.137491086
<br>
run -> 152589.53659088546
<br>
run -> 38147.63324071567
<br>
<br>
以上の結果をまとめる
<br>
・解が複数存在する場合、得られる近似解は初期値に依存する
<br>
・解が存在しない場合、解が収束しないか解が無限大に発散する
<br>
・高次の方程式||関数の場合、解が存在しても初期値によっては発散する
<br>
<br>
次に<a href="#span-out-FN">関数</a>を使用したfull-rank2元の連立非線形方程式を一例に示す
<br>
・連立非線形方程式と初期値を定義する
<br>
・反復6回目の近似解を示す
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{1+i,1-i};
<br>
f=&lt;{x0^i-2x1=3i,3x0+exp(x1)=5i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ i] 2.2368035825474494e-16
<br>
x ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
<br>
<br>
同じく引数の列vectorに<a href="#span-out-BT">丸括弧()</a>を使用する場合
<br>
・連立非線形方程式と初期値を定義する
<br>
・反復6回目の近似解を示す
<br>
storage cleared
<br>
x=&lt;(x0:x1); x_initial=&lt;(1+i:1-i);
<br>
f=&lt;(x0^i-2x1=3i:3x0+exp(x1)=5i);
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ i] 2.2368035825474494e-16
<br>
x ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
<br>
<br>
同じく引数の列vectorを直接<a href="#span-out-call-by-equation">式渡し</a>する場合
<br>
・mdxのnormを返す<a href="#span-out-eqns">式変数</a>runを定義して反復6回目の近似解を示す
<br>
storage cleared
<br>
run=&lt;last(
<br>
mdx=Newton(=&lt;(x0^i-2x1=3i:3x0+exp(x1)=5i),=&lt;(x0:x1),=&lt;(1+i:1-i)),
<br>
norm(mdx));
<br>
_rn(=&lt;run,,6) -> 2.2368035825474494e-16
<br>
{x0,x1} ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
信号変換
<br>
の解法
    </th>
    <td>
<span id="span-out-transform"></span>
信号変換の解法を列挙する
<br>
・<a href="#span-out-transform-fft">高速Fourier変換の解法</a>
<br>
・<a href="#span-out-transform-dft">離散Fourier変換の解法</a>
<br>
・<a href="#span-out-transform-dwt">離散Wavelet変換の解法</a>
<br>
・<a href="#span-out-transform-dwt-col">離散Wavelet変換の解法（列代入）</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高速
<br>
Fourier変換
<br>
の解法
    </th>
    <td>
<span id="span-out-transform-fft"></span>
高速Fourier変換Fast Fourier Transform(FFT)の解法について記述する
<br>
<br>
前提を列挙する
<br>
・信号変換前の領域を実空間（時間領域を含む）と記述する
<br>
・信号変換後の領域を波数領域と記述する
<br>
・信号変換前後のsampling離散点を標本点と記述する
<br>
・複素共役をoverlineで記述する
<br>
<br>
Split-Radix-2 FFTを一例に示す（LaTeX形式）
<br>
・<a href="../81_mathjax/index.html">MathJax表示Checker※CDN通信あり</a>
<br>
<br>
1次元FFT@Split-Radix-2
<br>
実空間
<br>
\(x=0,1,...,N_p-1\)
<br>
における偏角
<br>
\(\theta_{x,p}=x2\pi/N_p\)
<br>
とする標本点
<br>
\(f(x)\)
<br>
に対する1次元FFT@Split-Radix-2
<br>
\(N_p=2^p\)
<br>
\(p=0\)
<br>
\(F^{N_p=1}_x(u)=f(0)\)
<br>
\(p\gt0\)
<br>
\(F_x^{N_p=2^p}(u)\)
<br>
\(=\sum_{x=0}^{N_p-1}f(x)\mathrm{e}^{-\mathrm{i}u\theta_{x,p}}\)
<br>
\(=\sum_{x=0}^{N_{p-1}-1}\{f(x)\mathrm{e}^{-\mathrm{i}u\theta_{x,p}}\)
<br>
\(+f(x+N_{p-1})\mathrm{e}^{-\mathrm{i}u\theta_{x,p}}\mathrm{e}^{-\mathrm{i}u\pi}\}\)
<br>
\(=\sum_{x=0}^{N_{p-1}-1}\{f(x)\mathrm{e}^{-\mathrm{i}u\theta_{x,p-1}/2}\)
<br>
\(+f(x+N_{p-1})\mathrm{e}^{-\mathrm{i}u\theta_{x,p-1}/2}\mathrm{e}^{-\mathrm{i}u\pi}\}\)
<br>
\(=F_x^{N_{p-1}}(u/2)+F_{x+N_{p-1}}^{N_{p-1}}(u/2)\mathrm{e}^{-\mathrm{i}u\pi}\)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
離散
<br>
Fourier変換
<br>
の解法
    </th>
    <td>
<span id="span-out-transform-dft"></span>
離散Fourier変換Discrete Fourier Transform(DFT)の解法について記述する
<br>
<br>
前提を列挙する
<br>
・1次元の標本点数をNとして順変換DFTと逆変換IDFTの正規化係数(Nf,Ni)の制約条件を示す
<br>
Nf*Ni=1/N
<br>
<br>
(Nf,Ni)=(1,1/N)のDFT/IDFTを一例に示す（LaTeX形式）
<br>
・<a href="../81_mathjax/index.html">MathJax表示Checker※CDN通信あり</a>
<br>
<br>
1次元DFT
<br>
実空間
<br>
\(x=0,1,...,N-1\)
<br>
における偏角
<br>
\(\theta_x=x2\pi/N\)
<br>
とする標本点
<br>
\(f(x)\)
<br>
に対する1次元DFT
<br>
\(F(u)\)
<br>
\(=\sum_{x=0}^{N-1}f(x)\mathrm{e}^{-\mathrm{i}u\theta_x}\)
<br>
\(=F_x^N(u)\)
<br>
<br>
1次元IDFT
<br>
波数領域
<br>
\(u=0,1,...,N-1\)
<br>
における偏角
<br>
\(\theta_u=u2\pi/N\)
<br>
とする標本点
<br>
\(F(u)\)
<br>
に対する1次元IDFT
<br>
\(f(x)\)
<br>
\(=\frac{1}{N}\sum_{u=0}^{N-1}F(u)\mathrm{e}^{\mathrm{i}x\theta_u}\)
<br>
\(=\frac{1}{N}\overline{\sum_{u=0}^{N-1}\overline{F(u)}\mathrm{e}^{-\mathrm{i}x\theta_u}}\)
<br>
\(=f_u^N(x)\)
<br>
<br>
2次元DFT
<br>
実空間
<br>
\(x=0,1,...,N-1\)
<br>
\(y=0,1,...,M-1\)
<br>
における偏角
<br>
\(\theta_x=x2\pi/N\)
<br>
\(\theta_y=y2\pi/M\)
<br>
とする標本点
<br>
\(f(x,y)\)
<br>
に対する2次元DFT
<br>
\(F(u,v)\)
<br>
\(=\sum_{y=0}^{M-1}\sum_{x=0}^{N-1}
<br>
f(x,y)\mathrm{e}^{-\mathrm{i}(u\theta_x+v\theta_y)}\)
<br>
\(=\sum_{y=0}^{M-1}\sum_{x=0}^{N-1}
<br>
f(x,y)\mathrm{e}^{-\mathrm{i}u\theta_x}\mathrm{e}^{-\mathrm{i}v\theta_y}\)
<br>
\(=\sum_{y=0}^{M-1}F_x^N(u,y)\mathrm{e}^{-\mathrm{i}v\theta_y}\)
<br>
\(=F_{xy}^{NM}(u,v)\)
<br>
<br>
2次元IDFT
<br>
波数領域
<br>
\(u=0,1,...,N-1\)
<br>
\(v=0,1,...,M-1\)
<br>
における偏角
<br>
\(\theta_u=u2\pi/N\)
<br>
\(\theta_v=v2\pi/M\)
<br>
とする標本点
<br>
\(F(u,v)\)
<br>
に対する2次元IDFT
<br>
・<span class="clear">Ver.2.69.27</span>以降、一部訂正
<br>
\(f(x,y)\)
<br>
\(=\frac{1}{NM}\sum_{v=0}^{M-1}\sum_{u=0}^{N-1}
<br>
F(u,v)\mathrm{e}^{\mathrm{i}(x\theta_u+y\theta_v)}\)
<br>
\(=\frac{1}{NM}\sum_{v=0}^{M-1}\sum_{u=0}^{N-1}
<br>
F(u,v)\mathrm{e}^{\mathrm{i}x\theta_u}\mathrm{e}^{\mathrm{i}y\theta_v}\)
<br>
\(=\frac{1}{NM}\sum_{v=0}^{M-1}\sum_{u=0}^{N-1}
<br>
\overline{F(u,v)}\mathrm{e}^{-\mathrm{i}x\theta_u}\mathrm{e}^{\mathrm{i}y\theta_v}\)
<br>
\(=<span class="clear">\frac{1}{M}</span>\sum_{v=0}^{M-1}
<br>
\overline{f_u^N(x,v)}\mathrm{e}^{\mathrm{i}y\theta_v}\)
<br>
\(=<span class="clear">\frac{1}{M}</span>\overline{\sum_{v=0}^{M-1}
<br>
\overline{f_u^N(x,v)}\mathrm{e}^{-\mathrm{i}y\theta_v}}\)
<br>
\(=f_{uv}^{NM}(x,y)\)
<br>
<br>
test caseを示す（<span class="clear">Ver.2.69.27</span>追記）
<br>
・1次元の標本点
<br>
f={1,2,3,4};
<br>
f->
<br>
(
<br>
1:
<br>
2:
<br>
3:
<br>
4
<br>
)
<br>
・1次元DFT(x)->(u)
<br>
f={1,2,3,4};
<br>
<span class="clear">N=sizer(f);</span>
<br>
Nf=1;
<br>
Ni=1/N;
<br>
F=zeros(N,1);
<br>
F(u)=&lt;{_sx(=&lt;f[x]*e^(-i*u*x*2*pi/N),0,N-1)*Nf};
<br>
_su(=&lt;F[u]=F(u)=&gt;,0,N-1);
<br>
F ->
<br>
(
<br>
10:
<br>
-2.0000000000000004+1.9999999999999996i:
<br>
-2-9.797174393178826e-16i:
<br>
-1.9999999999999982-2.000000000000001i
<br>
)
<br>
・1次元IDFT(u)->(x)
<br>
f(x)=&lt;{_su(=&lt;F[u]*e^(i*x*u*2*pi/N),0,N-1)*Ni};
<br>
_sx(=&lt;f[x]=f(x)=&gt;,0,N-1);
<br>
f ->
<br>
(
<br>
1.0000000000000004-5.551115123125783e-16i:
<br>
2-2.7755575615628914e-16i:
<br>
2.9999999999999996-1.1102230246251565e-16i:
<br>
4+2.7755575615628914e-16i
<br>
)
<br>
・2次元の標本点
<br>
f={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
f ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
<br>
・2次元DFT(x,y)->(u,y)->(u,v)
<br>
f={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
<span class="clear">N=sizer(f);</span>
<br>
M=sizec(f);
<br>
Nf=1;
<br>
Ni=1/N;
<br>
Mf=1;
<br>
Mi=1/M;
<br>
F=zeros(N,M);
<br>
F(u,v)=&lt;{_sy(=&lt;{_sx(=&lt;f[x][y]*e^(-i*u*x*2*pi/N),0,N-1)*Nf}*e^(-i*v*y*2*pi/M),0,M-1)*Mf};
<br>
_sv(=&lt;_su(=&lt;F[u][v]=F(u,v)=&gt;,0,N-1),0,M-1);
<br>
F ->
<br>
(
<br>
136,
<br>
-32.00000000000001+31.999999999999996i,
<br>
-32-1.4205902870109296e-14i,
<br>
-31.999999999999975-32.000000000000014i:
<br>
infoLost[r ] -8.000000000000007+7.999999999999995i,
<br>
infoLost[r ] 3.1086244689504383e-15-8.881784197001252e-16i,
<br>
infoLost[r ] 2.6645352591003757e-15+8.881784197001252e-16i,
<br>
infoLost[r ] 1.1102230246251565e-15+4.218847493575595e-15i:
<br>
-8-9.797174393178824e-15i,
<br>
2.0658177477654226e-15+2.220446049250313e-15i,
<br>
2.4492935982947053e-15i,
<br>
-2.8006058272538343e-15+2.886579864025407e-15i:
<br>
-7.999999999999982-8.000000000000012i,
<br>
-4.440892098500626e-16+6.8833827526759706e-15i,
<br>
-4.440892098500626e-15+4.440892098500626e-15i,
<br>
-6.8833827526759706e-15-6.661338147750939e-16i
<br>
)
<br>
・2次元IDFT(x,y)->(u,y)->(u,v)->(x,v)->(x,y)
<br>
f(x,y)=&lt;{_sv(=&lt;{_su(=&lt;F[u][v]*e^(i*x*u*2*pi/N),0,N-1)*Ni}*e^(i*y*v*2*pi/M),0,M-1)*Mi};
<br>
_sy(=&lt;_sx(=&lt;f[x][y]=f(x,y)=&gt;,0,N-1),0,M-1);
<br>
f ->
<br>
(
<br>
infoLost[ri] 1.0000000000000009-2.220446049250313e-15i,
<br>
infoLost[ri] 5-2.6645352591003757e-15i,
<br>
infoLost[ri] 9-2.886579864025407e-15i,
<br>
infoLost[ri] 13.000000000000002-2.220446049250313e-15i:
<br>
infoLost[ri] 2.000000000000001-2.220446049250313e-15i,
<br>
infoLost[ri] 5.999999999999999-1.5543122344752192e-15i,
<br>
infoLost[ri] 9.999999999999996-1.1102230246251565e-15i,
<br>
infoLost[ri] 14-1.1102230246251565e-15i:
<br>
infoLost[ri] 3-2.4424906541753444e-15i,
<br>
infoLost[ri] 6.999999999999997-4.440892098500626e-16i,
<br>
infoLost[ri] 10.999999999999996+4.440892098500626e-16i,
<br>
infoLost[ri] 14.999999999999998+1.5543122344752192e-15i:
<br>
infoLost[ri] 4-1.9984014443252818e-15i,
<br>
infoLost[ri] 7.999999999999999+4.440892098500626e-16i,
<br>
infoLost[ri] 11.999999999999998+1.5543122344752192e-15i,
<br>
infoLost[ri] 16+3.9968028886505635e-15i
<br>
)
<br>
・2次元DFT(x,y)->(x,v)->(u,v)
<br>
F(v,u)=&lt;{_sx(=&lt;{_sy(=&lt;f[x][y]*e^(-i*v*y*2*pi/M),0,M-1)*Mf}*e^(-i*u*x*2*pi/N),0,N-1)*Nf};
<br>
_su(=&lt;_sv(=&lt;F[u][v]=F(v,u)=&gt;,0,M-1),0,N-1);
<br>
F ->
<br>
(
<br>
136,
<br>
-32.00000000000001+31.999999999999993i,
<br>
-32-1.4205902870109296e-14i,
<br>
-31.99999999999997-32.000000000000014i:
<br>
infoLost[r ] -8.000000000000004+7.999999999999993i,
<br>
5.329070518200751e-15,
<br>
1.8357322374478535e-15+1.7763568394002505e-15i,
<br>
1.7763568394002505e-15+3.552713678800501e-15i:
<br>
-8-9.797174393178824e-15i,
<br>
1.7763568394002505e-15+1.7763568394002505e-15i,
<br>
2.449293598294707e-15i,
<br>
-1.7763568394002505e-15+3.552713678800501e-15i:
<br>
-7.999999999999985-8.000000000000014i,
<br>
8.881784197001252e-16+5.329070518200751e-15i,
<br>
-2.9985277160012513e-15+2.6645352591003757e-15i,
<br>
-3.552713678800501e-15-8.881784197001252e-16i
<br>
)
<br>
・2次元IDFT(x,y)->(x,v)->(u,v)->(u,y)->(x,y)
<br>
f(y,x)=&lt;{_su(=&lt;{_sv(=&lt;F[u][v]*e^(i*y*v*2*pi/M),0,M-1)*Mi}*e^(i*x*u*2*pi/N),0,N-1)*Ni};
<br>
_sx(=&lt;_sy(=&lt;f[x][y]=f(y,x)=&gt;,0,M-1),0,N-1);
<br>
f ->
<br>
(
<br>
infoLost[ri] 1.0000000000000029-2.886579864025407e-15i,
<br>
infoLost[ri] 5.000000000000001-2.7755575615628914e-15i,
<br>
infoLost[ri] 9-2.3314683517128287e-15i,
<br>
infoLost[ri] 13.000000000000002-2.55351295663786e-15i:
<br>
infoLost[ri] 2.0000000000000013-2.1649348980190553e-15i,
<br>
infoLost[ri] 5.999999999999999-1.3877787807814457e-15i,
<br>
infoLost[ri] 9.999999999999996-6.661338147750939e-16i,
<br>
infoLost[ri] 13.999999999999998-3.3306690738754696e-16i:
<br>
infoLost[ri] 3.000000000000001-1.9984014443252818e-15i,
<br>
infoLost[ri] 6.999999999999999-7.771561172376096e-16i,
<br>
infoLost[ri] 10.999999999999998+5.551115123125783e-16i,
<br>
infoLost[ri] 14.999999999999998+1.7208456881689926e-15i:
<br>
infoLost[ri] 4.000000000000002-2.3869795029440866e-15i,
<br>
infoLost[ri] 8-3.3306690738754696e-16i,
<br>
infoLost[ri] 11.999999999999998+1.6653345369377348e-15i,
<br>
infoLost[ri] 16+3.1086244689504383e-15i
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
離散
<br>
Wavelet変換
<br>
の解法
    </th>
    <td>
<span id="span-out-transform-dwt"></span>
離散Wavelet変換Discrete Wavelet Transform(DWT)の解法について記述する
<br>
<br>
前提を列挙する
<br>
・1次元の標本点数をNとして順変換DWTと逆変換IDWTの制約条件を示す
<br>
N=2^p
<br>
・量子化bit数=p
<br>
・信号変換の解像度を可逆的にscalingするtwo-scale関係が成立する
<br>
<br>
多重解像度解析の最も単純なHaar's DWT/IDWTを一例に示す
<br>
<br>
1次元DWT(x)->(u)
<br>
・標本点
<br>
<span class="condition">1,2,3,4,5,6,7,8</span>
<br>
・two-scale関係式
<br>
scaling(t)=scaling(2t)+scaling(2t+1)
<br>
wavelet(t)=scaling(2t)-scaling(2t+1)
<br>
・左右にscaling情報とwavelet情報を分離して再帰的にscaling情報を左側に寄せる
<br>
<span class="condition">1+2,3+4,5+6,7+8</span>,1-2,3-4,5-6,7-8
<br>
<span class="condition">1+2+3+4,5+6+7+8</span>,1+2-(3+4),5+6-(7+8),1-2,3-4,5-6,7-8
<br>
<span class="condition">1+2+3+4+5+6+7+8</span>,1+2+3+4-(5+6+7+8),1+2-(3+4),5+6-(7+8),1-2,3-4,5-6,7-8
<br>
・整理して示す（scaling情報の解像度の降順）
<br>
<span class="condition">1,2,3,4,5,6,7,8</span>
<br>
<span class="condition">3,7,11,15</span>,-1,-1,-1,-1
<br>
<span class="condition">10,26</span>,-4,-4,-1,-1,-1,-1
<br>
<span class="condition">36</span>,-16,-4,-4,-1,-1,-1,-1
<br>
<br>
1次元IDWT(u)->(x)
<br>
・標本点
<br>
<span class="condition">36</span>,-16,-4,-4,-1,-1,-1,-1
<br>
・two-scale関係式
<br>
scaling(2t)=(scaling(t)+wavelet(t))/2
<br>
scaling(2t+1)=(scaling(t)-wavelet(t))/2
<br>
・<span class="selection">行vector</span>の場合
<br>
scaling(2t)=<span class="selection">0.5*</span>(scaling(t)+wavelet(t))
<br>
scaling(2t+1)=<span class="selection">0.5*</span>(scaling(t)-wavelet(t))
<br>
・<span class="selection">列vector</span>の場合
<br>
scaling(2t)=(scaling(t)+wavelet(t))<span class="selection">*0.5</span>
<br>
scaling(2t+1)=(scaling(t)-wavelet(t))<span class="selection">*0.5</span>
<br>
・scaling情報とwavelet情報から再帰的に元のscaling情報を復元する
<br>
<span class="condition">(36+(-16))/2,(36-(-16))/2</span>,-4,-4,-1,-1,-1,-1
<br>
<span class="condition">(10+(-4))/2,(10-(-4))/2,(26+(-4))/2,(26-(-4))/2</span>,-1,-1,-1,-1
<br>
<span class="condition">(3+(-1))/2,(3-(-1))/2,(7+(-1))/2,(7-(-1))/2,(11+(-1))/2,(11-(-1))/2,(15+(-1))/2,(15-(-1))/2</span>
<br>
・整理して示す（scaling情報の解像度の昇順）
<br>
<span class="condition">36</span>,-16,-4,-4,-1,-1,-1,-1
<br>
<span class="condition">10,26</span>,-4,-4,-1,-1,-1,-1
<br>
<span class="condition">3,7,11,15</span>,-1,-1,-1,-1
<br>
<span class="condition">1,2,3,4,5,6,7,8</span>
<br>
<br>
2次元DWT/IDWT(x,y)⇔(u,y)⇔(u,v)
<br>
<span class="condition">
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
</span>
<br>
⇔
<br>
<span class="condition">10</span>,-4,-1,-1:
<br>
<span class="condition">26</span>,-4,-1,-1:
<br>
<span class="condition">42</span>,-4,-1,-1:
<br>
<span class="condition">58</span>,-4,-1,-1
<br>
⇔
<br>
<span class="condition">136</span>,-16,-4,-4:
<br>
-64,0,0,0:
<br>
-16,0,0,0:
<br>
-16,0,0,0
<br>
<br>
2次元DWT/IDWT(x,y)⇔(x,v)⇔(u,v)
<br>
<span class="condition">
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
</span>
<br>
⇔
<br>
<span class="condition">28,32,36,40</span>:
<br>
-16,-16,-16,-16:
<br>
-4,-4,-4,-4:
<br>
-4,-4,-4,-4
<br>
⇔
<br>
<span class="condition">136</span>,-16,-4,-4:
<br>
-64,0,0,0:
<br>
-16,0,0,0:
<br>
-16,0,0,0
<br>
<br>
test caseを示す
<br>
・1次元の標本点
<br>
w={1,2,3,4,5,6,7,8};
<br>
w->
<br>
(
<br>
1:
<br>
2:
<br>
3:
<br>
4:
<br>
5:
<br>
6:
<br>
7:
<br>
8
<br>
)
<br>
・1次元DWT(x)->(u)
<br>
w={1,2,3,4,5,6,7,8};
<br>
<span class="clear">N=sizer(w);</span>
<br>
W=zeros(N,1);
<br>
<span class="clear">p=round(log_ex(N,2));</span>
<br>
W(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
_rn(=&lt;last{W(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;,w=W},Np=1&lt;&lt;p,p);
<br>
W ->
<br>
(
<br>
36:
<br>
-16:
<br>
-4:
<br>
-4:
<br>
-1:
<br>
-1:
<br>
-1:
<br>
-1
<br>
)
<br>
・1次元IDWT(u)->(x)
<br>
w(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1);
<br>
_rn(=&lt;last{w(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;,W=w},Np=1,p);
<br>
w ->
<br>
(
<br>
1:
<br>
2:
<br>
3:
<br>
4:
<br>
5:
<br>
6:
<br>
7:
<br>
8
<br>
)
<br>
・2次元の標本点
<br>
w={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
<br>
・2次元DWT(x,y)->(u,y)->(u,v)※N&gt;1
<br>
w={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
<span class="clear">N=sizer(w);</span>
<br>
M=sizec(w);
<br>
W=zeros(N,M);
<br>
<span class="clear">p=round(log_ex(N,2));</span>
<br>
q=round(log_ex(M,2));
<br>
W(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
_rn(=&lt;last{W(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;,w=W},Np=1&lt;&lt;p,p);
<br>
W=trans(W);
<br>
_rn(=&lt;last{w=W,W(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;},Nq=1&lt;&lt;q,q);
<br>
W=trans(W);
<br>
W ->
<br>
(
<br>
136,-64,-16,-16:
<br>
-16,0,0,0:
<br>
-4,0,0,0:
<br>
-4,0,0,0
<br>
)
<br>
・2次元IDWT(x,y)->(u,y)->(u,v)->(x,v)->(x,y)
<br>
w(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1);
<br>
w=W;
<br>
_rn(=&lt;last{w(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;,W=w},Np=1,p);
<br>
w=trans(w);
<br>
_rn(=&lt;last{W=w,w(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;},Nq=1,q);
<br>
w=trans(w);
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
<br>
・2次元DWT(x,y)->(x,v)->(u,v)※M&gt;1
<br>
W(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
w=trans(w);
<br>
W=trans(W);
<br>
_rn(=&lt;last{W(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;,w=W},Nq=1&lt;&lt;q,q);
<br>
W=trans(W);
<br>
_rn(=&lt;last{w=W,W(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;},Np=1&lt;&lt;p,p);
<br>
W ->
<br>
(
<br>
136,-64,-16,-16:
<br>
-16,0,0,0:
<br>
-4,0,0,0:
<br>
-4,0,0,0
<br>
)
<br>
・2次元IDWT(x,y)->(x,v)->(u,v)->(u,y)->(x,y)
<br>
w(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1);
<br>
w=W;
<br>
W=trans(W);
<br>
w=trans(w);
<br>
_rn(=&lt;last{w(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;,W=w},Nq=1,q);
<br>
w=trans(w);
<br>
_rn(=&lt;last{W=w,w(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;},Np=1,p);
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
離散
<br>
Wavelet変換
<br>
の解法
<br>
（列代入）
    </th>
    <td>
<span id="span-out-transform-dwt-col"></span>
離散Wavelet変換の解法（列代入）について記述する
<br>
<br>
<span class="run">Ver.2.76.29</span>以降、<a href="#span-out-mat">行列</a>の<a href="#span-out-BT-square-col">列参照</a>と<a href="#span-out-substitution-mat-col">列代入</a>を駆使して<a href="#span-out-transform-dwt">2次元DWT/IDWT</a>のalgorithmを整理する
<br>
・2次元の標本点
<br>
w={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
<br>
・2次元DWT(x,y)->(u,y)->(u,v)※N&gt;1
<br>
w={
<br>
1,2,3,4:
<br>
5,6,7,8:
<br>
9,10,11,12:
<br>
13,14,15,16
<br>
};
<br>
<span class="clear">N=sizer(w);</span>
<br>
M=sizec(w);
<br>
W=zeros(N,M);
<br>
<span class="clear">p=round(log_ex(N,2));</span>
<br>
q=round(log_ex(M,2));
<br>
W_row(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
W_col(w,N)=&lt;_st(=&lt;last{
<br>
a=w[<span class="condition">-1</span>][2*t],b=w[<span class="condition">-1</span>][2*t+1],W[<span class="condition">-1</span>][t]=a+b,W[<span class="condition">-1</span>][t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
_rn(=&lt;last{W_row(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;,w=W},Np=1&lt;&lt;p,p);
<br>
_rn(=&lt;last{w=W,W_col(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;},Nq=1&lt;&lt;q,q);
<br>
W ->
<br>
(
<br>
136,-64,-16,-16:
<br>
-16,0,0,0:
<br>
-4,0,0,0:
<br>
-4,0,0,0
<br>
)
<br>
・2次元IDWT(x,y)->(u,y)->(u,v)->(x,v)->(x,y)
<br>
w_row(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1);
<br>
w_col(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[<span class="condition">-1</span>][t],b=W[<span class="condition">-1</span>][t+N2],w[<span class="condition">-1</span>][2*t]=(a+b)<span class="selection">*0.5</span>,w[<span class="condition">-1</span>][2*t+1]=(a-b)<span class="selection">*0.5</span>
<br>
},0,N2-1);
<br>
w=W;
<br>
_rn(=&lt;last{w_row(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;,W=w},Np=1,p);
<br>
_rn(=&lt;last{W=w,w_col(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;},Nq=1,q);
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
<br>
・2次元DWT(x,y)->(x,v)->(u,v)※M&gt;1
<br>
W_row(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
W_col(w,N)=&lt;_st(=&lt;last{
<br>
a=w[<span class="condition">-1</span>][2*t],b=w[<span class="condition">-1</span>][2*t+1],W[<span class="condition">-1</span>][t]=a+b,W[<span class="condition">-1</span>][t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1);
<br>
_rn(=&lt;last{W_col(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;,w=W},Nq=1&lt;&lt;q,q);
<br>
_rn(=&lt;last{w=W,W_row(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;},Np=1&lt;&lt;p,p);
<br>
W ->
<br>
(
<br>
136,-64,-16,-16:
<br>
-16,0,0,0:
<br>
-4,0,0,0:
<br>
-4,0,0,0
<br>
)
<br>
・2次元IDWT(x,y)->(x,v)->(u,v)->(u,y)->(x,y)
<br>
w_row(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1);
<br>
w_col(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[<span class="condition">-1</span>][t],b=W[<span class="condition">-1</span>][t+N2],w[<span class="condition">-1</span>][2*t]=(a+b)<span class="selection">*0.5</span>,w[<span class="condition">-1</span>][2*t+1]=(a-b)<span class="selection">*0.5</span>
<br>
},0,N2-1);
<br>
w=W;
<br>
_rn(=&lt;last{w_col(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;,W=w},Nq=1,q);
<br>
_rn(=&lt;last{W=w,w_row(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;},Np=1,p);
<br>
w ->
<br>
(
<br>
1,5,9,13:
<br>
2,6,10,14:
<br>
3,7,11,15:
<br>
4,8,12,16
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
級数展開
<br>
の解法
    </th>
    <td>
<span id="span-out-series"></span>
級数展開の解法を列挙する
<br>
・<a href="#span-out-series-Taylor">Taylor級数・Maclaurin級数の解法</a>
<br>
・<a href="#span-out-series-Fourier">Fourier級数の解法</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Taylor・
<br>
Maclaurin
<br>
級数の解法
    </th>
    <td>
<span id="span-out-series-Taylor"></span>
Taylor級数・Maclaurin級数の解法について記述する
<br>
・<a href="#span-out-error-numerical">Computer Algebra System</a>未実装で得られる解は<a href="#span-out-error-numerical">数値解</a>
<br>
・<a href="#span-out-FNh-DX">微分高階関数</a>の精度に依存
<br>
・3階微分以降、既定の2次精度では精度不足
<br>
<br>
Taylor級数・Maclaurin級数
<br>
・0の0乗の定義
<br>
0^0 || 0**0 || pow(0,0) -> 1
<br>
・f(x)のx=a周辺のN次打切りTaylor級数TaylorN
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
・f(x)のx=0周辺のN次打切りMaclaurin級数MaclaurinN
<br>
MaclaurinN=&lt;_sn(=&lt;{_dx(=&lt;f,n,0)x^n/n!},0,N);
<br>
・f(x)=exp(x)の場合
<br>
f=&lt;exp(x);
<br>
x=2; f -> 7.38905609893065
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
MaclaurinN=&lt;_sn(=&lt;{_dx(=&lt;f,n,0)x^n/n!},0,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=3; TaylorN || MaclaurinN -> 6.3333380025161095+O(4e-2)
<br>
N=5; TaylorN || MaclaurinN -> 7.266696174805806+O(2e+1)
<br>
N=7; TaylorN || MaclaurinN -> 7.381056210596976+O(2e+2)
<br>
・<a href="#span-out-com">複素数</a>演算の場合
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=3; TaylorN -> 6.333333332137665+0.00000933215700063301i+O(2e-2+2e-2i)
<br>
N=5; TaylorN -> 7.266666317607307+0.000058921777380024245i+O(4e+0+4e+0i)
<br>
N=7; TaylorN -> 7.38095752867692+0.00014973248523188646i+O(2e+1+2e+1i)
<br>
<br>
収束性
<br>
・Taylor級数のN次の項TN
<br>
TN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},N,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=0; TN -> 1
<br>
N=1; TN -> 2.000000000000264+3.199902245182912e-15i+O(2e-12+2e-12i)
<br>
N=2; TN -> 2.0000000000047273-3.0553419555181785e-12i+O(7e-10+3e-11i)
<br>
N=3; TN -> 1.3333333321326732+0.000009332160052775064i+O(2e-2+2e-2i)
<br>
N=4; TN -> 0.6666667002412976+0.000018888944812360706i+O(7e-1+1e-2i)
<br>
N=5; TN -> 0.26666628522834573+0.00003070067556703053i+O(4e+0+4e+0i)
<br>
N=6; TN -> 0.0888888278111036+0.000037059768491892605i+O(2e+1+3e-1i)
<br>
N=7; TN -> 0.025402383258507955+0.00005375093935996962i+O(2e+1+2e+1i)
<br>
N=8; TN -> 0.006352708017224355+0.00004619914542548148i+O(2e+1+4e-1i)
<br>
N=9; TN -> 0.0014113419838348632+0.000038423321810908794i+O(5e+0+5e+0i)
<br>
N=10; TN -> 0.000280289701751799+0.00003279136299319164i+O(1e+0+2e-2i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Fourier
<br>
級数の解法
    </th>
    <td>
<span id="span-out-series-Fourier"></span>
Fourier級数の解法について記述する
<br>
・<a href="#span-out-error-numerical">Computer Algebra System</a>未実装で得られる解は<a href="#span-out-error-numerical">数値解</a>
<br>
・<a href="#span-out-FNh-IX">積分高階関数</a>の精度に依存
<br>
・既定で4次精度の積分範囲100分割
<br>
<br>
Fourier級数
<br>
・周期関数f(x)のN次打切りFourier級数FourierN
<br>
FourierN=&lt;_sn(=&lt;{cn*e^(i(n)x)},-N,N);
<br>
cn=&lt;_it(=&lt;{ft*e^(-i(n)t)},-pi,pi)/(2pi);
<br>
・f(x)=e^(i(2.5)x)の場合
<br>
fx=&lt;e^(i(2.5)x);
<br>
ft=&lt;e^(i(2.5)t);
<br>
x=2;
<br>
fx -> 0.28366218546322625-0.9589242746631385i
<br>
N=1; FourierN
<br>
-> infoLost[ri] 0.2534807789507349-0.1102612365002427i+O(2e-6+2e-6i)
<br>
N=3; FourierN
<br>
-> infoLost[ri] 0.3468103654284403-0.7325756973228494i+O(2e-6+2e-6i)
<br>
N=5; FourierN
<br>
-> infoLost[ri] 0.29934712994045387-1.0833440107828247i+O(2e-6+2e-6i)
<br>
・三角波
<br>
ft=&lt;asin(sin(t));
<br>
・矩形波
<br>
ft=&lt;sign(asin(sin(t))); || ft=&lt;sign(sin(t));
<br>
・のこぎり波
<br>
ft=&lt;atan(tan(t));
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
極限の解法
    </th>
    <td>
<span id="span-out-limit"></span>
極限の解法について記述する
<br>
・<a href="#span-out-error-numerical">Computer Algebra System</a>未実装で得られる解は限定的なcaseの<a href="#span-out-error-numerical">数値解</a>
<br>
・L'Hôpitalの定理を使用する場合、<a href="#span-out-FNh-DX">微分高階関数</a>の精度に依存
<br>
<br>
<a href="#span-out-com">複素数</a>演算の場合、次の極限演算不可
<br>
1/0 -> [MyErr]FN isNaN
<br>
・0割の演算未定義のため、次の反則が発生
<br>
0*Infinity -> [MyErr]FN isNaN
<br>
<br>
complex unchecked時、<a href="#span-out-ope">実数演算</a>の場合
<br>
1/0 -> Infinity
<br>
MIN_VALUE -> 5e-324
<br>
1/(-MIN_VALUE) -> -Infinity
<br>
1/(+MIN_VALUE) -> Infinity
<br>
1/Infinity || 1/Inf || 1/pInf -> 0
<br>
-Infinity+1 || nInf+1 -> infoLost[r ] -Infinity
<br>
Infinity-Infinity -> [MyErr]BRsa isNaN
<br>
<br>
極限値演算のtest caseを列挙する
<br>
x=MIN_VALUE; x -> 5e-324
<br>
sin(x)/x  <span class="selection">// OK</span> -> 1
<br>
sin(-x)/(-x)  <span class="selection">// OK</span> -> 1
<br>
ln(1+x)/x  <span class="selection">// NG</span> -> infoLost[r ] 0
<br>
・L'Hôpitalの定理
<br>
・<a href="#span-out-com">複素数</a>演算の場合
<br>
_dx(=&lt;{ln(1+x)})/_dx(=&lt;{x})  <span class="selection">// OK</span>
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(3e-24i)
<br>
_dx(=&lt;{ln(1-x)})/_dx(=&lt;{-x})  <span class="selection">// OK</span>
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(2e-16+3e-24i)
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{-x},2)  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{(-x)^2},2)  <span class="selection">// OK</span>
<br>
-> -0.500000000135999+3.0923761182676057e-12i+O(3e-10+1e-11i)
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
_dx(=&lt;{ln(1+x)})/_dx(=&lt;{x})  <span class="selection">// OK</span> -> 0.9999999999991271
<br>
_dx(=&lt;{ln(1-x)})/_dx(=&lt;{-x})  <span class="selection">// OK</span> -> 0.9999999999991271
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{-x},2)  <span class="selection">// NG</span> -> -Infinity+O(Infinity)
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{(-x)^2},2)  <span class="selection">// OK</span> -> -0.4999999999659258+O(3e-10)
<br>
・無限大の極限は自明の演算以外は演算不可
<br>
y=pInf -> y=Infinity
<br>
(1/y)/y  <span class="selection">// OK</span> -> 0
<br>
y*y  <span class="selection">// OK</span> -> Infinity
<br>
y/(y*y)  <span class="selection">// NG</span> -> [MyErr]FN isNaN
<br>
_dy(=&lt;{y})/_dy(=&lt;{y*y})  <span class="selection">// NG</span> -> [MyErr]BRsa isNaN
<br>
_dy(=&lt;{1/(y*y)})/_dy(=&lt;{1/y})  <span class="selection">// NG</span> -> [MyErr]FN isNaN
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊仕様
    </th>
    <td>
<span id="span-out-special"></span>
最後に一般的でない可能性のある仕様について記述する
<br>
<br>
<a href="#span-out-type-ope">前置単項演算子</a>の符号の扱いについて記述する
<br>
・単項の符号は同種の<a href="#span-out-type-ope">中置2項演算子</a>と区別せず、<a href="#span-out-associativity">2項演算子のassociativity</a>に従って演算する
<br>
・この時、符号の左側には0が存在すると仮定する
<br>
<a href="#span-out-option1">LA既定</a>時　+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
<a href="#span-out-option1">RA選択</a>時　+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
・<a href="#span-out-mat">行列</a>も同様に、単項の符号は<a href="#span-out-FNm">Scalar倍</a>||zeros行列との差||和として扱う
<br>
-(1,2:3,4) || (-1,:,-1)(1,2:3,4) || (,:,)-(1,2:3,4) -> (-1,-2:-3,-4)
<br>
+(1,2:3,4) || (+1,:,+1)(1,2:3,4) || (,:,)+(1,2:3,4) -> (1,2:3,4)
<br>
・よって実用しないが、符号が連続する場合、<a href="#span-out-option1">RA選択</a>時のみ演算可
<br>
<a href="#span-out-option1">LA既定</a>時　--(1,i) || (-)-(1,i) -> [MyErr]Invalid binary operation
<br>
<a href="#span-out-option1">RA選択</a>時　--(1,i) || (,)-((,)-(1,i)) || (-1)((-1)(1,i)) -> (1,i)
<br>
<a href="#span-out-option1">LA既定</a>時　---(1,i) || ((-)-)-(1,i) -> [MyErr]Invalid binary operation
<br>
<a href="#span-out-option1">RA選択</a>時　---(1,i) || (,)-((,)-((,)-(1,i))) || (-1)((-1)((-1)(1,i))) -> (-1,-i)
<br>
<br>
次にequal記号=の扱いについて記述する
<br>
・代入と判別されないequal記号=は、右辺移項の<a href="#span-out-type-ope">中置2項演算子</a>として扱う
<br>
・<a href="#span-out-associativity">2項演算子のassociativity</a>に依存するが、単体使用を前提とする
<br>
-3=5 || (0-3)=5 || =5+3 -> 8
<br>
(1,2:3,4)=(,:,) || =(,:,)-(1,2:3,4) -> (-1,-2:-3,-4)
<br>
(1,2:3,4)=(,) || =(,)-(1,2:3,4) -> [MyErr]Invalid matrix operation
<br>
・単項の場合、符号同様に左辺には0||zeros行列が存在すると仮定する
<br>
=8 || 0=8 || =8-0 -> 8
<br>
=(1,2:3,4) || (,:,)=(1,2:3,4) || =(1,2:3,4)-(,:,) -> (1,2:3,4)
<br>
・本仕様は<a href="#span-out-eqns">式変数</a>への方程式の<a href="#span-out-substitution-equation">式代入</a>で以下の構文を許容する
<br>
f=&lt;{x0^2+1=0} || f=&lt;{=-(x0^2+1)} || f=&lt;{-(x0^2+1)}
<br>
f=&lt;{A(x)=b} || f=&lt;{=b-A(x)} || f=&lt;{b-A(x)}
<br>
f=&lt;{Ainv*A=identity2} || f=&lt;{=identity2-Ainv*A} || f=&lt;{identity2-Ainv*A}
<br>
<br>
<a href="#span-out-mat">行列</a>を扱う上での演算都合上の仕様について記述する
<br>
・代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は0が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をcomma,||colon:で区切った場合、0を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
clear; (1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、<a href="#span-out-mat">行列</a>を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
clear; x=(1,2),x || 0,(1,2) -> (0,1,2)
<br>
clear; max(x=(-1,-2),min(x)) || max(0,-2) -> 0
<br>
vector={1,2,3}:trans(vector)vector -> (0:14)
<br>
・<a href="#span-out-matching">行列要素pattern matching</a>による代入も同様
<br>
(($a,$b)=(1,2)) -> 0
<br>
・<a href="#span-out-substitution-equation">式変数への式代入</a>も同様
<br>
(x=&lt;(a,b,c,d,e)) -> 0
<br>
・<a href="#span-out-vars">変数</a>への<a href="#span-out-eqns-call">式読出し</a>は読出し値が残る
<br>
clear; y=&lt;3x-1,x=3,y=&gt;,y=&gt;y0,y0 -> (0,0,8,8,8)
<br>
<br>
<a href="#span-out-eqns">式変数</a>について記述する
<br>
・<a href="#span-out-eqns">式変数</a>、<a href="#span-out-eqns-call">式読出し</a>、<a href="#span-out-call-by-equation">式渡し</a>、<a href="#span-out-substitution-equation">式代入</a>、<a href="#span-out-scope-inherited-call">scope継承call</a>の仕様は呼び名含めて一般的でない
<br>
・連立方程式をscript入力から解くために独自に定義している
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
application
    </th>
    <td>
<span id="span-out-application"></span>
applicationについて記述する
<br>
<br>
Painter's pattern||SVG-path||gradation||filter
<br>
<br>
Circuit Simulator's arbitrary non-linear||impedance element
<br>
・Arrhenius equationのnon-dimensionalized<a href="#span-out-eqns">式変数</a>fの一例
<br>
　回路要素電流Iに対する未知電圧Vを解く場合
<br>
f=&lt;last{I=1,E=0,k=1,I=exp(k*(V-E))-exp(-k*(V-E))}
<br>
　回路要素電圧Vに対する未知電流Iを解く場合
<br>
f=&lt;last{V=1,E=0,k=1,I=exp(k*(V-E))-exp(-k*(V-E))}
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
最終output
    </th>
    <td>
<span id="span-out-application-output"></span>
数値計算を応用する最終outputについて記述する
<br>
<br>
Electrochemical cells 2D-simulation with heat and fluid flow
<br>
・Circuit Simulator with impedance spectroscopy
<br>
・Heat and Fluid Flow Simulator
<br>
・Electrochemical Cell Simulator
<br>
・Electrochemical Impedance Spectroscopy(EIS) Simulator
<br>
<br>
電気化学cellの定性的な理解を目的として以上の解析技術を実装予定
<br>
・一般的に、外部の火花発生や内部の短絡riskに対してhard/soft両面の対策が必要とされる
<br>
・例えば、充電電流||充電電力を上げて急速充電の時間を過度に短縮した場合、過充電同様、
<br>
　負極に挿入不能で行き場を失う過剰なionが副反応（金属析出等）に消費されるため、
<br>
　経年劣化（活性ion等の不可逆なloss）とともにmicro-scaleの内部短絡riskが生じる
<br>
・通常の充放電時も同様に、副反応の平衡電位に応じて起こり得るが、
<br>
　性能とのtrade-offで経年劣化に見込むこと（不活性な被膜に変質する成長の範囲内）で、
<br>
　ある程度は許容するものと考えられる
<br>
・その上で、ionの拡散/反応速度はArrhenius equationに従ってexponentialに変化するため、
<br>
　cell間内部温度のばらつきは無視できない可能性が高い
<br>
・とくに低温では、被膜を含む反応抵抗の増加によって副反応の平衡電位に到達しやすく、
<br>
　実用想定のcycle試験等、許容範囲の見極めが重要になると考えられる
<br>
・その他、電極面積に応じて反応不均一（構造由来||液枯れ等）が生じた場合、
<br>
　以上の傾向を増長する懸念があり、これらを対策する<a href="#span-pre-pat1">参考特許文献[1]</a>が考え方の参考になる
<hr>
・固体電解質については、液系由来の問題（副反応を除く）は解消されるが、
<br>
　cycle試験中の電解質||電極の膨張収縮による導電path切れが問題となっている印象を受ける
<br>
・ただし、bulk型の減圧密閉/拘束圧縮後の空隙の状態とその変化による影響に加えて、
<br>
　電解質||電極の種類によるporous全体の塑性変形（熱可塑性を含む）の影響等、詳細は不明
<br>
・仮に、物理的な導電path切れの場合、浮遊分の活性ionと反応界面を同時に失うため、
<br>
　満充電容量の低下と見かけの抵抗上昇に繋がる
<br>
・一方、電気的な導電path上の固体電解質/活物質界面の接触不良（binderを含む）の場合、
<br>
　実質の界面抵抗上昇に繋がり、さらに剥離進行||亀裂進展で物理的な導電path切れに繋がる
<br>
・他方、電気的な導電path上の固体電解質/活物質界面における被膜成長の場合、液系同様、
<br>
　副反応量に応じた満充電容量の低下と実質の界面抵抗上昇に繋がる
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
残課題
    </th>
    <td>
<span id="span-out-remain"></span>
残課題について優先順に記述する
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-args">式変数のarguments</a>を追加
<br>
[Resolved-status]<del>
<a href="#span-out-eqns">式変数</a>のargumentsの実装（影響範囲大で未確定）
<br>
・<a href="#span-out-scope-vars">変数のscope</a>に加えて<a href="#span-out-eqns">式変数</a>に引数を渡せないと不十分
<br>
・future after
<br>
add(a,b)=&lt;a+b; add(1,3)=&gt; -> 4
<br>
solvex_Gauss(A,b)=&lt;[...,=&lt;x=&gt;]=&gt;; x=solvex_Gauss(A,b)=&gt;;
<br>
Newton_simplified(=&lt;f,=&lt;x,Nmax)=&lt;[mdx=Newton(=&lt;f,=&lt;x,,Nmax,1e-16,1),=&lt;x=&gt;]=&gt;;
<br>
x=Newton_simplified(=&lt;{x0+x1=2,x0*x1=5},=&lt;{x0,x1},6)=&gt;;
<br>
・<a href="#span-out-eqns-call">式読出し</a>記号=&gt;の省略可否を検討
</del>
<br>
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-re-use">scope付式変数の再利用</a>に対応
<br>
<span class="run">Ver.2.31.17</span>以降、変数のscopeを追加
<br>
・<a href="#span-out-scope-vars">変数のscope</a>外部仕様参照
<br>
・<a href="#span-in-scope-vars">変数のscope</a>内部仕様参照
<br>
[Resolved-status]<del>
<a href="#span-out-scope-vars">変数のscope</a>の実装（影響範囲大で未確定）
<br>
・now before
<br>
clear; [a=2,[a=1,a],a] -> (0,0,1,1)
<br>
clear; [a=2,=&lt;[a=1,=&lt;a]=&gt;+a]=&gt; -> 2
<br>
・future after
<br>
clear; [a=2,[a=1,a],a] -> (0,0,1,2)
<br>
clear; [a=2,=&lt;[a=1,=&lt;a]=&gt;+a]=&gt; -> 3
<br>
・過去の後方互換性をほぼ完全に維持する場合、<a href="#span-out-BT-square">角括弧[]</a>のみ<a href="#span-out-scope-vars">変数のscope</a>を追加
<br>
　実装前後で演算結果が変わるtest caseはないはず
<br>
・後方互換性を完全に維持する場合、URL parameter's useScopeを追加
<br>
　useScope=falseの場合、scopeを一切使用しない
<br>
　useScope=trueの場合、すべての<a href="#span-out-BT">括弧</a>にscopeを使用する
<br>
・store/restore時、<a href="#span-out-bracket">階層</a>毎にscope objectが必要
<br>
　<a href="#span-out-bracket">parse</a>段階で実行文j、<a href="#span-out-bracket">階層</a>nのscopes2d arrayを作成
<br>
　n=0にlocal <a href="#span-out-storage">storage</a> object元のreferenceを統合・共通化
<br>
・restore時、parents-scope objectの再帰的なreference手段が必要
<br>
　Circular Reference回避のため、scopes2d arrayの要素id=[j,n]でreferenceを代替
<br>
　各<a href="#span-out-bracket">階層</a>のref object同列にids2d arrayを追加
<br>
・tree置換時、未知変数存在の場合、child-scope objectのreference継承が必要
<br>
・[a=1,=&lt;a]tree置換後、<a href="#span-out-eqns-call">式読出し</a>時、<a href="#span-out-vars">変数</a>aのsearch-precedence（短絡評価）
<br>
child-scope object || self-scope object || parents-scope object || local <a href="#span-out-storage">storage</a> object
<br>
・search-precedenceに従う<a href="#span-out-FNc">最上位関数</a>hasv/haseを追加
<br>
・local <a href="#span-out-storage">storage</a>のみを扱う<a href="#span-out-command">命令文</a>への影響
<br>
　local <a href="#span-out-storage">storage</a> objectをscopes2d arrayに統合するため、影響あり
<br>
　clear/store/restoreについてlocal <a href="#span-out-storage">storage</a> object元のreferenceを切らないように修正
</del>
<br>
<br>
<span class="run">Ver.2.19.6</span>以降、
<a href="#span-out-substitution-equation">関数の参照渡しの仕様を廃止</a>
して解決
<br>
[Resolved-status]<del>
<a href="#span-out-FN">関数</a>の参照を返値に指定した場合、予期せぬerror終了
<br>
(,trans) || (trans)=&gt; -> Unexpected error
<br>
・<a href="#span-out-SR">区切り文字</a>の演算時に型checkが必要
<br>
・現状、<a href="#span-out-FNh">高階関数</a>で代替可（関数の参照渡しの必要性が少ない）
<br>
・関数名を短縮する参照渡しを廃止すれば解決
</del>
<br>
<br>
<span class="run">Ver.2.25.12</span>以降、
<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
<br>
[Resolved-status]<del>
plot2d-commandの実装
<br>
・予め演算した結果をplotする場合の仕様が必要
<br>
・<a href="#span-out-command">命令文</a>より最上位で単独のcommand仕様が必要
</del>
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-in">内部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
source抜粋
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
単位tree構造
    </th>
    <td>
<span id="span-in-tree"></span>
演算単位となる単位tree構造を以下に示す
<br>
<br>
<a href="#span-out-ope">演算仕様</a>を列挙する
<br>
・i行j列の<a href="#span-out-mat">行列</a>要素は2次元配列arr[i][j]を参照する
<br>
・<a href="#span-out-ope">無次元</a>の演算の場合、2次元配列の<a href="#span-out-FNm-last">最終要素</a>を参照する
<br>
<span class="run">Ver.2.73.29</span>以降、定義できない<a href="#span-out-mat">行列</a>演算の<a href="#span-out-ope-extended">拡張機能</a>を追加
<br>
<span class="run">Ver.2.74.29</span>以降、<a href="#span-out-ope-extended">拡張行列演算</a>における<a href="#span-out-option4">comma演算子</a>の使用を選択可
<br>
・<a href="#span-out-FN">関数の引数vector</a>の場合、2次元配列の各行arr[i]を参照する
<br>
・<a href="#span-out-type-ope">演算子のoperand</a>の場合、2次元配列の各要素arr[i][j]を参照する
<br>
<pre><code>
            j-th sentence
  trees2d: [j][i]{tag || num}
  trees1d,     i-th token
    trees: [i]{}
  trees0d,
     tree: {}
      tag: {"name": {val: val}}
      num: {mat:    {arr: arr}}
      1+i: arr [0] [0] {com: {r: 1, i: 1}}
   matrix:     row col {complex number   }
(i,2:3,4): arr [0] [0] {com: {r: 0, i: 1}}
               [0] [1] {com: {r: 2, i: 0}}
               [1] [0] {com: {r: 3, i: 0}}
               [1] [1] {com: {r: 4, i: 0}}
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数のscope
    </th>
    <td>
<span id="span-in-scope-vars"></span>
scopes2d arrayのstructureを以下に示す
<br>
<br>
これに基づく<a href="#span-out-scope-vars">変数のscope</a>仕様について記述する
<br>
・n=0にlocal <a href="#span-out-storage">storage</a> object元のreferenceを統合・共通化（<a href="#span-out-command">命令文</a>を含む）
<br>
・Circular Reference回避のため、scopes2d arrayの要素id=[j,n]でreferenceを代替
<br>
・以降、このreferenceをidsと呼ぶ
<br>
・<a href="#span-out-bracket">parse</a>段階で<a href="#span-out-bracket">階層とscopeの関係</a>に基づくstatic scopes2d arrayを作成
<br>
・同時に対応するidsを<a href="#span-in-tree">単位tree構造</a>のtag.val同列に保存
<br>
・tag.val同列は当初なかったが、<a href="#span-out-BT-square">行列要素参照の角括弧[]</a>用にmat.arrとともに追加
<br>
<pre><code>
             j-th sentence
  scopes2d: [j][n]{scope}
  scopes1d,     n-th scope
    scopes: [n]{}
     scope: {vars:{}, eqns:{}}
</code></pre>
<br>
前提を列挙する
<br>
・<a href="#span-out-eqns">式変数</a>は宣言時の<a href="#span-out-bracket">階層</a>に依存する
<br>
・宣言時の<a href="#span-out-bracket">階層</a>のreferenceをself-idsと定義する
<br>
・parenetsの<a href="#span-out-bracket">階層</a>のreferenceをまとめてparents-idsと定義する
<br>
・childrenの<a href="#span-out-bracket">階層</a>のreferenceをまとめてchildren-idsと定義する
<br>
・宣言時の<a href="#span-out-bracket">階層</a>の深さ以上をself-parents-idsと定義する
<br>
・宣言時の<a href="#span-out-bracket">階層</a>の深さ以下をself-children-idsと定義する
<br>
<br>
<a href="#span-out-scope-vars">変数のscope</a>の明示的なids継承が発生するcaseを列挙する
<br>
・<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>の<a href="#span-out-eqns">式変数</a>への<a href="#span-out-substitution-equation">式代入</a>時、self-children-idsを継承
<br>
clear; [a=2,=&lt;[b=1,a=&lt;first[[b,],b,],=&lt;a=&gt;]=&gt;+a]=&gt; -> 3
<br>
・上記a=&lt;first[[b,],b,]<a href="#span-out-substitution-equation">式代入</a>時、self-children-idsを継承
<br>
・上記=&lt;a=&gt;<a href="#span-out-call-by-equation">式渡し</a>時、self-children-idsを継承
<br>
・<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>時、call先のself-parents-idsを継承
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-re-use">scope付式変数の再利用</a>に対応
<br>
・global <a href="#span-out-storage">storage</a>　⇒　local <a href="#span-out-storage">storage</a>で<a href="#span-out-eqns">式変数</a>の復帰時、self-children idsを更新
<br>
<span class="run">Ver.2.32.17</span>以降、<a href="#span-out-eqns-args">式変数のarguments</a>を追加
<br>
・<a href="#span-out-eqns">式変数</a>のcall時、<a href="#span-out-eqns-args">式変数のarguments</a>に定義元のself-parents-idsを継承
<br>
<br>
<a href="#span-out-eqns-args">式変数のarguments</a>について記述する
<br>
・定義元の<a href="#span-out-eqns">式変数</a>のcall毎に動的にscopeは作らない
<br>
・<a href="#span-out-bracket">parse</a>段階で割当てた定義元の<a href="#span-out-eqns">式変数</a>のstatic scopes2d arrayを共有する
<br>
・argumentsのみ、call前後でbuffer経由store/restoreで模擬的にscopeが独立する
<br>
　<a href="#span-out-FNh">高階関数</a>のdummy変数同様（参考）
<br>
<br>
<a href="#span-out-scope-inherited-call">式変数のscope継承call</a>について記述する
<br>
・<a href="#span-out-bracket">直列scope内</a>の<a href="#span-out-eqns">式変数</a>のみcall可
<br>
・callする<a href="#span-out-eqns">式変数</a>のself-parents-idsとcall先のself-parents-idsの重複するidsを
<br>
・callする<a href="#span-out-eqns">式変数</a>のself-children-idsからpopで取り出した後、継承する
<br>
・よってidsはn=0の0階層から取り出すFIFO-queueとする
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
内部option
    </th>
    <td>
<span id="span-in-options"></span>
console-CLI実行で必要な内部optionの設定項目について記述する
<br>
<br>
全objectはglobal scopeから見えないMy_entryで始まる
<br>
<br>
My_entry.parserに渡すdata objectを次に示す
<br>
var data = {trees:null, options:{}, vars:{}, eqns:{}};
<br>
<br>
内部optionに相当するdata.optionsのpropertyを以下に列挙する
<br>
・<span class="clear">Ver.2.76.30</span>以降、makeLogの<a href="#span-out-config">裏設定</a>が反映されない不具合を修正
<br>
・<span class="clear">Ver.2.76.30</span>以降、expDigitの仕様追記（<a href="#span-out-config">裏設定</a>は無効）
<br>
<br>
・makeLog: 演算終了後にlog出力用の文字列を作成するflag
<br>
　makeLog=true設定で整形なしのlogを作成
<br>
　makeLog=2設定で行列を整形表示するlogを作成
<br>
　console-CLI実行でlogを作る場合、flagを立てる
<br>
　一例を次に示す（以降のflagも同様）
<pre><code>
var data = new My_entry.DATA().data();
data.in = "2*3";
new My_entry.parser().run(data);
data.out -> [Array(1)]  // <a href="#span-in-tree">単位tree構造</a>
data.log -> undefined
data.options.makeLog = true;
new My_entry.parser().run(data);
data.log -> "6"
data.logh -> "2*3\n6"
data.logo -> "makeLog=true"
</code></pre>
<br>
・<a href="#span-out-ope">useComplex</a>: 複素数を使用するflag
<br>
<br>
・<a href="#span-out-ope">useMatrix</a>: 行列を使用するflag
<br>
<br>
以降、省略で既定値
<br>
<br>
・<a href="#span-out-config">useStrict</a>: strict-modeを使用するflag
<br>
<br>
・<a href="#span-out-scope-vars">useScope</a>: 変数のscopeを使用するflag
<br>
<br>
・isRightAssociativityBR: <a href="#span-out-associativity">2項演算子のassociativity</a>を<a href="#span-out-option1">RA選択</a>に変更するflag
<br>
<br>
・isDIVprior2OMUL: <a href="#span-out-BRmo">記号省略乗算</a>より除算を優先するflag
<br>
<br>
・expDigit: 演算結果を表示する指数表記の桁数（<span class="clear"><a href="#span-out-config">裏設定</a>は無効</span>）
<br>
<br>
・<a href="#span-out-config">checkError</a>: <a href="#span-out-error">情報落ち</a>の発生や微分・積分の<a href="#span-out-error-numerical">数値誤差</a>を評価するflag
<br>
<br>
・<a href="#span-out-config">precedence</a>: comma,区切りで演算子の<a href="#span-in-prec">tag名</a>を列挙した文字列
<br>
<br>
・<a href="#span-out-FNm">matSizeMax</a>: <a href="#span-out-FNm">行列size</a>指定の行||列のlengthの上限値
<br>
<br>
・<a href="#span-out-FNmh-newtonian">isRelative_epsN</a>: epsNを相対誤差に変換するflag
<br>
<br>
・<a href="#span-out-FNmh-newtonian">epsN</a>: Newton法の絶対誤差の収束判定実数値
<br>
<br>
・<a href="#span-out-FNmh-jacobian">dxJ</a>: Jacobi行列演算時の1階偏微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNh-DX">dxD</a>: 有限差分による1階微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNh-DX">orderD</a>: 有限差分による微分の精度次数
<br>
<br>
・<a href="#span-out-FNmh-OX">dxT</a>: 有限差分による1階常微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNmh-OX">orderT</a>: 有限差分による常微分の精度次数
<br>
<br>
・<a href="#span-out-FNh-IX">NI</a>: 有限差分による積分範囲の分割数
<br>
<br>
・<a href="#span-out-FNh-IX">orderI</a>: 有限差分による積分の精度次数
<br>
<br>
以降、console-CLI実行は無効
<br>
<br>
・useWorker: Workerを使用するflag
<br>
<br>
・oldPlot2d: <span class="run">Ver.2.33.17</span>以前のplot2d 0.seriesを使用するflag
<br>
<br>
browser-GUI実行の場合、URLのGET入力で既定値を上書き可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
独自eval
    </th>
    <td>
<span id="span-in-myeval"></span>
console-CLI実行用の独自evalについて記述する
<br>
<br>
独自evalは次のstatic methodでconsoleからcallする
<br>
・演算内容の文字列を引数に渡すと演算結果の文字列が返る
<br>
My_entry.eval("2*3") -> "6"
<br>
<br>
<a href="#span-in-options">内部option</a>は以下の既定値
<pre><code>
data.options.useComplex = true;
data.options.useMatrix = true;
data.options.makeLog = true;
</code></pre>
<br>
test caseを列挙する
<pre><code>
My_entry.eval("clear; x=i; x*x;"); -> "local storage cleared;x=i;-1"
My_entry.eval("(1,2:3,4)(1,2:3,4)"); -> "(7,10:15,22)"
My_entry.eval("_sn(=&lt;{n+1},0,2)"); -> "6"
My_entry.eval("1-"); -> "[MyErr]Invalid binary operation"
My_entry.eval(0xf); -> "15"
My_entry.eval(3i); -> Uncaught SyntaxError: Invalid or unexpected token
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数・関数・
<br>
区切り文字・
<br>
演算子の
<br>
precedence
    </th>
    <td>
<span id="span-in-prec"></span>
<a href="#span-out-vars">変数</a>・<a href="#span-out-FN">関数</a>・<a href="#span-out-SR">区切り文字</a>・<a href="#span-out-prec-ope">演算子のprecedence</a>について記述する
<br>
<br>
配列要素の定義順で<a href="#span-out-prec">演算のprecedence</a>を動的に変更可能とする
<br>
<br>
operation.js抜粋
<pre><code>
  precedence: [
                 // comments and white-spaces are removed by parser
    [
      [
        /* following delimiter */
                 // SeparatoR semi-colon; are removed by parser
        "SRr",   // SeparatoR colon:
        "SRt"    // SeparatoR comma,
      ],
      [
        /* following store */
        "SEe"    // StorE obvious equation including bracket =&lt;
      ],
      [
        /* following function */
        "FNc"    // FunctioN for command prior to bracket
      ],
      [
        /* following delimiter */
        "BT2",   // BrackeT {
        "BT1",   // BrackeT (
        "BT0"    // BrackeT [
      ],
      [
        /* following restore */
        "REe",   // RestorE obvious equation =&gt; || ==&gt;
        "REv"    // RestorE variable first, equation second
      ],
      [
        /* following function */
        "FNmh",  // FunctioN for matrix high-order
        "FNm",   // FunctioN for matrix
        "FNh",   // FunctioN high-order
        "FN",    // FunctioN 0~4-arguments
        "FNn"    // FunctioN n-arguments
      ]
    ],
    [
      [
        /* following operator */
        "URi",   // post-Unary operatoR imaginary unit i
        "URf"    // factorial mark ! || !!... operand is only natural number
      ],
      [
        "BRp",   // Binary operatoR ** || ^ -> pow(left, right)
        "BRr"    // Binary operatoR %       -> mod(left, right)
      ],
      [
        "BRmo"   // omitted multiplication sign
      ],
      [
        "BRdm"   // Binary operatoR / || *
      ],
      [
        "BRsa"   // Binary operatoR - || + including Pre-Unary operator - || +
      ],
      [
        "PUbn",  // Pre-Unary operator bit not ~
        "BRbs",  // Binary operatoR bit  shift &lt;&lt; || &gt;&gt; || &gt;&gt;&gt;
        "BRba",  // Binary operatoR bit    and &amp;
        "BRbx",  // Binary operatoR bit    xor @
        "BRbo"   // Binary operatoR bit     or |
      ],
      [
        "BRcn",  // Binary operatoR comparison &lt; || &lt;= || &gt;= || &gt;
        "BRrl",  // Binary operatoR relational == || &lt;&gt;
        "BRlA",  // Binary operatoR logical AND &amp;&amp;
        "BRlO"   // Binary operatoR logical  OR ||
      ]
    ],
    [
      [
        "BRe"    // Binary operatoR = including Pre-Unary operator =
      ],
      [
        /* following store */
        "SEv"    // StorE variable
      ]
    ]
  ],
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定義済みの
<br>
関数・予約語
    </th>
    <td>
<span id="span-in-FN"></span>
定義済みの<a href="#span-out-FN">関数</a>・<a href="#span-out-RW">予約語</a>について記述する
<br>
<br>
予約語は大文字・小文字・全角・半角を区別しない
<br>
<br>
parser.js抜粋
<pre><code>
      // reserved word
      // variable
      case "ans":
        tree = DATA.tree_tag("REv", token_lower);
        break;
      // command
      case "clear":
      case "store":
      case "restore":
      case "stop":
        throw "Invalid "+token+" called";
        break;
      // "FNc"
      // storage
      case "hasvar":
      case "haseqn":
      case "delvar":
      case "deleqn":
      case "addvar":
      case "addeqn":
      // scopes+storage
      case "hasv":
      case "hase":
        tree = DATA.tree_tag("FNc", token_lower);
        break;
      // "FNhn"
      case "switch":
        tree = DATA.tree_tag("FNh", {key: token_lower});
        break;
      // "FN2"
      // only real number
      // relational
      case "eq":
      case "ne":
      // comparison
      case "lt":
      case "le":
      case "gt":
      case "ge":
      // complex number
      // relational
      case "ceq":
      case "cne":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FNmh"
      case "jacobi":
      case "jacobian":
        tree = DATA.tree_tag("FNmh", "jacobian");
        break;
      case "newton":
      case "newtonian":
        tree = DATA.tree_tag("FNmh", "newtonian");
        break;
      // "FNm"
      // "FNm0"
      case "vector2r":
      case "vector3r":
      case "vector4r":
      case "vector2c":
      case "vector3c":
      case "vector4c":
      case "zeros2":
      case "zeros3":
      case "zeros4":
      case "ones2":
      case "ones3":
      case "ones4":
      case "identity2":
      case "identity3":
      case "identity4":
        tree = DATA.tree_mat(math_mat[token_lower]());
        break;
      // "FNm1"
      case "vectorr":
      case "vectorc":
      case "identity":
      case "first":
      case "last":
      case "rotationx":
      case "rotationy":
      case "rotationz":
      case "sizer":
      case "normalizer":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      case "size":
      case "sizec":
        tree = DATA.tree_tag("FNm", "sizec");
        break;
      case "normalize":
      case "normalizec":
        tree = DATA.tree_tag("FNm", "normalizec");
        break;
      case "trans":
      case "transpose":
        tree = DATA.tree_tag("FNm", "transpose");
        break;
      case "htrans":
      case "htranspose":
      case "hermitian":
        tree = DATA.tree_tag("FNm", "hermitian");
        break;
      case "norm":
      case "euclidean":
        tree = DATA.tree_tag("FNm", "euclidean");
        break;
      // "FNm2"
      case "scalars":
      case "zeros":
      case "ones":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      case "gauss":
      case "gaussian":
        tree = DATA.tree_tag("FNm", "gaussian");
        break;
      // "CT"
      // JavaScript defined
      case "epsilon":
      case "min_safe_integer":
      case "max_safe_integer":
        tree = DATA.tree_num(self.entry.math.config[token_upper], 0);
        break;
      case "min_value":
      case "max_value":
      case "positive_infinity":
      case "negative_infinity":
        tree = DATA.tree_num(Number[token_upper], 0);
        break;
      // My defined
      case "eps":
        tree = DATA.tree_num(self.entry.math.config["EPSILON"], 0);
        break;
      case  "inf":
      case  "infinity":
      case "pinf":
      case "pinfinity":
        tree = DATA.tree_num(Number.POSITIVE_INFINITY, 0);
        break;
      case "ninf":
      case "ninfinity":
        tree = DATA.tree_num(Number.NEGATIVE_INFINITY, 0);
        break;
      case  "infi":
      case  "infinityi":
      case "pinfinityi":
      case "pinfi":
        tree = DATA.tree_num(0, Number.POSITIVE_INFINITY);
        break;
      case "ninfinityi":
      case "ninfi":
        tree = DATA.tree_num(0, Number.NEGATIVE_INFINITY);
        break;
      // JavaScript defined
      case "ln2":
      case "ln10":
      case "log2e":
      case "log10e":
      case "sqrt1_2":
      case "sqrt2":
      // Both defined
      case "e":
      case "pi":  // pi || PI() in Excel
        tree = DATA.tree_num(Math[token_upper], 0);
        break;
      // "FN0"
      // JavaScript defined
      case "random":
      // Excel defined
      case "rand":
        tree = DATA.tree_tag("FN", "random");
        break;
      // "FN1"
      case "ln":
        tree = DATA.tree_tag("FN", "log");
        break;
      case "int":
        tree = DATA.tree_tag("FN", "floor");
        break;
      // JavaScript defined
      case "ceil":
      case "floor":
      case "round":
      case "log":
      // Excel defined
      case "sinh":
      case "cosh":
      case "tanh":
      case "asinh":
      case "acosh":
      case "atanh":
      case "sign":
      case "fact":
      case "degrees":
      case "radians":
      // Both defined
      case "abs":
      case "sqrt":
      case "exp":
      case "sin":
      case "cos":
      case "tan":
      case "asin":
      case "acos":
      case "atan":
      case "log10":
      // My defined
      case "sin_deg":
      case "cos_deg":
      case "tan_deg":
      case "deg_asin":
      case "deg_acos":
      case "deg_atan":
      case "deg2rad":
      case "rad2deg":
      case "ecomp":
      case "ecomplex":
      case "real":
      case "imag":
      case "imaginary":
      case "conj":
      case "conjugate":
      case "arg":
      case "argument":
      case "deg_arg":
      case "deg_argument":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN1or2"
      // Excel defined
      case "log_ex":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN2"
      case "power":
        tree = DATA.tree_tag("FN", "pow");
        break;
      // JavaScript defined
      case "pow":
      case "atan2":
      case "imul":
      // Excel defined
      case "combin":
      case "combination":
      // My defined
      case "permut":
      case "permutation":
      case "deg_atan2":
      case "atan2_ex":  // Excel spec
      case "deg_atan2_ex":
      case "comp":
      case "complex":
      case "pcomp":
      case "pcomplex":
      case "kdelta":
      case "mod":
      case "fmod":
      // "FN3or4"
      // My defined
      case "star":
      case "poly":
      case "polygon":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FNn" n&lt;256 in Excel
      // Excel defined
      case "lcm":
      case "gcd":
      // Both defined
      // only real number
      case "min":
      case "max":
      // My defined
      // |complex number|
      case "cmin":
      case "cmax":
        tree = DATA.tree_tag("FNn", token_lower);
        break;
      default:
        /* Ver.2.24.12 -> */
        if(self.entry.operation.config.isEscaped(token)){
          self.check_varName(token.substr(1), re);
        }
        /* -> Ver.2.24.12 */
        tree = DATA.tree_tag("REv", token);
        break;
</code></pre>
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-eqn"><a href="#span-out-config-strict">strict-mode</a>式変数list</span></caption>
<thead>
  <tr>
    <th>
式変数名
    </th>
    <th>
algorithm
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
template
    </th>
    <td>
<span id="span-eqn-template"></span>
clear;
<br>
template(x,y,=&lt;symbol_eqn_,=&lt;eqn_)=&lt;[
<br>
out=&lt;[=&lt;(symbol_eqn_=&gt;,eqn_=&gt;)]=&gt;,
<br>
scope2storage=&lt;last{0},
<div class="condition">
init=&lt;last{0},
</div>
<div class="run">
run=&lt;last{0},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[x=1,y=2,f=3,f=&lt;[last(x=-2*x,x),y],=&lt;template(x,=&lt;last(f)/*var||eqn*/,=&lt;f,=&lt;[x,y])=&gt;]=&gt;;
<br>
/*following eqn(f) without scope called twice*/
<br>
[x=1,y=2,f=3,f=&lt;(last(x=-2*x,x),y),=&lt;template(x,=&lt;last(f=&gt;),=&lt;f,=&lt;(x,y))=&gt;]=&gt;;
<br>
[x=1,y=2,f=3,f=&lt;(last(x=-2*x,x),y),=&lt;template(x,=&lt;last(f=&gt;),=&lt;f,=&lt;[x,y])=&gt;]=&gt;;
<br>
/*following eqn(f) with static scope called twice*/
<br>
[x=1,y=2,f=3,f=&lt;[last(x=-2*x,x),y],=&lt;template(x,=&lt;last(f=&gt;),=&lt;f,=&lt;(x,y))=&gt;]=&gt;;
<br>
[x=1,y=2,f=3,f=&lt;[last(x=-2*x,x),y],=&lt;template(x,=&lt;last(f=&gt;),=&lt;f,=&lt;[x,y])=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
average
    </th>
    <td>
<span id="span-eqn-average"></span>
<a href="#span-out-UI-graphing-filter-average">averageぼかし</a>参照
<br>
clear;
<br>
[isSquare=0,N=3,N2=int(N/2),filter=vectorc(N*N),
<br>
calc_w(s2)=&lt;switch(isSquare==0,switch(s2&gt;N2**2,0:1,1):1,1),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
average
<br>
_asym
    </th>
    <td>
<span id="span-eqn-average-asym"></span>
<a href="#span-out-UI-graphing-filter-average-asym">非対称averageぼかし</a>参照
<br>
clear;
<br>
[isSquare=0,N=13,N2=int(N/2),filter=vectorc(N*N),
<br>
x=1,y=2,k=3,rad=pi/4,
<br>
<a href="#span-eqn-rotationxyz_LHS">rotz_LHS(psi)</a>=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;,
<br>
Rz=rotz_LHS(rad)=&gt;,
<br>
isOutOfArea(x)=&lt;switch(
<br>
isSquare==0,x[0]**2+(x[1]*k)**2&gt;N2**2:
<br>
1,(x[0]**2&gt;N2**2)|((x[1]*k)**2&gt;N2**2)
<br>
),
<br>
calc_w(ir,ic)=&lt;switch(isOutOfArea(=&lt;Rz*{ic-x,ir-y,1})=&gt;,0:1,1),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir,ic)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Gaussian
    </th>
    <td>
<span id="span-eqn-Gaussian"></span>
<a href="#span-out-UI-graphing-filter-Gaussian">Gaussぼかし</a>参照
<br>
clear;
<br>
[isStrict=0,N=3,N2=int(N/2),filter=vectorc(N*N),Nbit=N-1,wmax=2**Nbit,
<br>
calc_w(s2)=&lt;switch(isStrict==0,round(wmax*exp(-0.5*s2)):1,exp(-0.5*s2)),
<br>
_sir(=&lt;{_sic(=&lt;filter[(ir+N2)*N+(ic+N2)]=calc_w(ir**2+ic**2)=&gt;,-N2,N2)},-N2,N2),
<br>
=&lt;trans(filter)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
_circle
    </th>
    <td>
<span id="span-eqn-plot2d_circle"></span>
<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
<br>
clear;
<br>
plot2d_circle(t0,t1,N,M)=&lt;[
<br>
out=&lt;(xt,yt),
<br>
scope2storage=&lt;last{addVar(xt),addVar(yt)},
<div class="condition">
init=&lt;last{
<br>
tn=&lt;t0+(t1-t0)*n/N,
<br>
xt=zeros(N+1,M+1),yt=zeros(N+1,M+1)
<br>
},
</div>
<div class="run">
run=&lt;last{
<br>
stepnm=&lt;last{xt[n][m]=cos(tn=&gt;tn)*m,yt[n][m]=sin(tn)*m},
<br>
casesM=&lt;_sm(=&lt;stepnm,0,M),
<br>
evolutionN=&lt;_sn(=&lt;casesM,0,N),
<br>
evolutionN=&gt;
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
plot2d_circle(0,2*pi,10,3)=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
_evolution
    </th>
    <td>
<span id="span-eqn-plot2d_evolution"></span>
<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
<br>
clear;
<br>
plot2d_evolution(t0,t1,dt,z_x0,z_v0,m,Cd_sphere)=&lt;[
<br>
out=&lt;(xt,yt),
<br>
scope2storage=&lt;last{addVar(xt),addVar(yt)},
<div class="condition">
init=&lt;last{
<br>
g=-9.8,z_a=0+g*i,
<br>
x=&lt;{z_x,z_v},
<br>
x_initial=&lt;{z_x0,z_v0},
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v},
<br>
N=round((t1-t0)/dt),M=0,
<br>
xt=zeros(N+1,M+1),yt=zeros(N+1,M+1)
<br>
},
</div>
<div class="run">
run=&lt;last{
<br>
dtn=&lt;switch(n&lt;=0,0:1,dt),
<br>
step=&lt;x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,0,dtn=&gt;),
<br>
stepnm=&lt;last{step=&gt;,xt[n][mdummy]=real(z_x),yt[n][mdummy]=imag(z_x)},
<br>
casesM=&lt;_smdummy(=&lt;stepnm,0,M)/*m-reserved*/,
<br>
evolutionN=&lt;_sn(=&lt;casesM,0,N),
<br>
evolutionN=&gt;
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
plot2d_evolution(0,5,0.5,0,20+20i,1,1)=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
SND/P(x)/
<br>
erf(x)/erfc(x)
    </th>
    <td>
<span id="span-eqn-SND_Px_erfx_erfcx"></span>
<a href="#span-out-FNspecial">特殊関数入力仕様</a>参照
<br>
clear;
<br>
SND(t)=&lt;exp(-t^2/2)/sqrt(2*pi);
<br>
Px(x)=&lt;_it(=&lt;SND(t)=&gt;,0,x)*2;
<br>
erfx(x)=&lt;_it(=&lt;SND(t)=&gt;,0,x*sqrt2)*2;
<br>
erfcx(x)=&lt;1-erfx(x)=&gt;;
<br>
[x=3,SND(x)=&gt;,Px(x)=&gt;,erfx(x)=&gt;,erfcx(x)=&gt;];
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
matrix
<br>
_product
    </th>
    <td>
<span id="span-eqn-matrix_product"></span>
<a href="#span-out-mat-product">行列積の解法</a>参照
<br>
clear;
<br>
LpR(L,R)=&lt;[product=&lt;last{LR[ir][ic]=ttL[ir]*trans((trans(ttR))[ic])},
<br>
ttL=trans(trans(L)),
<br>
ttR=trans(trans(R)),
<br>
LR=zeros(sizer(ttL),sizec(ttR)),
<br>
_sir(=&lt;_sic(=&lt;product,0,sizec(ttR)-1),0,sizer(ttL)-1),
<br>
=&lt;LR]=&gt;;
<br>
[L=(1,2:3:4,5:6),R=(1,2:3,4,5),=&lt;LpR(=&lt;L,=&lt;R)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
rotationx/y/z
    </th>
    <td>
<span id="span-eqn-rotationxyz"></span>
<a href="#span-out-FNmspecial">特殊行列関数入力仕様</a>参照
<br>
clear;
<br>
rotx(phi)=&lt;[rt=real(phi),=&lt;(1,,:,cos(rt),-sin(rt):,sin(rt),cos(rt))]=&gt;;
<br>
roty(theta)=&lt;[rt=real(theta),=&lt;(cos(rt),,sin(rt):,1,:-sin(rt),,cos(rt))]=&gt;;
<br>
rotz(psi)=&lt;[rt=real(psi),=&lt;(cos(rt),-sin(rt),:sin(rt),cos(rt),:,,1)]=&gt;;
<br>
[t=pi/4,=&lt;[rotx(t)=&gt;,roty(t)=&gt;,rotz(t)=&gt;]]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
rotationx/y/z
<br>
_LHS
    </th>
    <td>
<span id="span-eqn-rotationxyz_LHS"></span>
<a href="#span-out-FNmspecial">特殊行列関数入力仕様</a>参照
<br>
clear;
<br>
rotx_LHS(phi)=&lt;[rt=real(phi),=&lt;(1,,:,cos(rt),sin(rt):,-sin(rt),cos(rt))]=&gt;;
<br>
roty_LHS(theta)=&lt;[rt=real(theta),=&lt;(cos(rt),,-sin(rt):,1,:sin(rt),,cos(rt))]=&gt;;
<br>
rotz_LHS(psi)=&lt;[rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)]=&gt;;
<br>
[t=pi/4,=&lt;[rotx_LHS(t)=&gt;,roty_LHS(t)=&gt;,rotz_LHS(t)=&gt;]]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solvex
<br>
_Gauss
    </th>
    <td>
<span id="span-eqn-solvex_Gauss"></span>
<a href="#span-out-linear">連立線形方程式の解法</a>参照
<br>
clear;
<br>
solvex_Gauss(A,b)=&lt;[
<br>
out=&lt;x,
<div class="condition">
init=&lt;last{sizeA=size(A),x=zeros(sizeA,1)},
</div>
<div class="run">
run=&lt;last{
<br>
compare=&lt;last{absA_comp=abs(A[ir_comp][ir]),
<br>
switch(absA_pivot&lt;absA_comp,=&lt;last{ir_pivot=ir_comp,absA_pivot=absA_comp})},
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w},
<br>
pivotting=&lt;last{ir_pivot=ir,absA_pivot=abs(A[ir][ir]),
<br>
_sir_comp(=&lt;compare,ir+1,sizeA-1),switch(ir&lt;&gt;ir_pivot,=&lt;proc)},
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k*A[ic],b[ir]=b[ir]-k*b[ic]},
<br>
backward=&lt;last{r=b[ir],_sic(=&lt;r=r-A[ir][ic]*x[ic],ir+1,sizeA-1),x[ir]=r/A[ir][ir]},
<br>
_sir(=&lt;pivotting,0,sizeA-2),
<br>
_sic(=&lt;_sir(=&lt;forward,ic+1,sizeA-1),0,sizeA-2),
<br>
x[sizeA-1]=b[sizeA-1]/A[sizeA-1][sizeA-1],_sir(=&lt;backward,sizeA-2,0)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[rand_Ab=&lt;last{N=5,A=zeros(N,N),b=vectorc(N),gen_rand=&lt;rand()+rand()*i,
<br>
_sir(=&lt;last{_sic(=&lt;A[ir][ic]=gen_rand=&gt;,0,N-1),b[ir]=gen_rand=&gt;},0,N-1)},
<br>
rand_Ab=&gt;,=&lt;/*optimized*/Gauss(A,b)-solvex_Gauss(=&lt;A,=&lt;b)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solvex
<br>
_pivotting
    </th>
    <td>
<span id="span-eqn-solvex_pivotting"></span>
<a href="#span-out-linear">連立線形方程式の解法</a>参照
<br>
clear;
<br>
solvex_pivotting(A,b)=&lt;[
<br>
out=&lt;x,
<div class="condition">
init=&lt;last{sizeA=size(A),x=zeros(sizeA,1)},
</div>
<div class="run">
run=&lt;last{
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;ir_pivot=ir_comp),
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w},
<br>
pivotting=&lt;last{ir_pivot=ir,compare=&gt;,switch(ir&lt;&gt;ir_pivot,=&lt;proc)},
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k*A[ic],b[ir]=b[ir]-k*b[ic]},
<br>
backward=&lt;x[ir]=(b[ir]-A[ir]*x)/A[ir][ir],
<br>
_sir(=&lt;_sir_comp(=&lt;pivotting,ir+1,sizeA-1),0,sizeA-2),
<br>
_sic(=&lt;_sir(=&lt;forward,ic+1,sizeA-1),0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[A=(i,2,3i:4,5i,6:7i,8,9i),b={1,2i,4},=&lt;solvex_pivotting(=&lt;A,=&lt;b)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solvex
<br>
_no_pivotting
    </th>
    <td>
<span id="span-eqn-solvex_no_pivotting"></span>
<a href="#span-out-linear">連立線形方程式の解法</a>参照
<br>
clear;
<br>
solvex_no_pivotting(A,b)=&lt;[
<br>
out=&lt;x,
<div class="condition">
init=&lt;last{sizeA=size(A),x=zeros(sizeA,1)},
</div>
<div class="run">
run=&lt;last{
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k*A[ic],b[ir]=b[ir]-k*b[ic]},
<br>
backward=&lt;x[ir]=(b[ir]-A[ir]*x)/A[ir][ir],
<br>
_sic(=&lt;_sir(=&lt;forward,ic+1,sizeA-1),0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[A=(i,2,3i:4,5i,6:7i,8,9i),b={1,2i,4},=&lt;solvex_no_pivotting(=&lt;A,=&lt;b)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solvex
<br>
_iteration
    </th>
    <td>
<span id="span-eqn-solvex_iteration"></span>
<a href="#span-out-linear">連立線形方程式の解法</a>参照
<br>
clear;
<br>
solvex_iteration(A,b)=&lt;[
<br>
out=&lt;x=&gt;,
<div class="condition">
init=&lt;last{sizeA=size(A),_ex(=&lt;x,sizeA,1)},
</div>
<div class="run">
run=&lt;last{
<br>
f=&lt;A*(x=&gt;)=b,
<br>
mdx=Newton(=&lt;f,=&lt;x,,Nmax=20,Nmax,1e-10,1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[A=(i,2,3i:4,5i,6:7i,8,9i),b={1,2i,4},=&lt;solvex_iteration(=&lt;A,=&lt;b)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solveAinv
    </th>
    <td>
<span id="span-eqn-solveAinv"></span>
<a href="#span-out-inverse">逆行列の解法</a>参照
<br>
clear;
<br>
solveAinv(A)=&lt;[
<br>
out=&lt;Ainv=&gt;,
<div class="condition">
init=&lt;last{sizeA=size(A),_eAinv(=&lt;x,sizeA,sizeA),_ex(=&lt;x,sizeA*sizeA,1)},
</div>
<div class="run">
run=&lt;last{
<br>
f=&lt;(Ainv=&gt;)*A=identity(sizeA),
<br>
mdx=Newton(=&lt;f,=&lt;x,,Nmax=20,Nmax,1e-10,1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[A=(i,2,3i:4,5i,6:7i,8,9i),=&lt;solveAinv(=&lt;A)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
solvex
<br>
_non_linear
    </th>
    <td>
<span id="span-eqn-solvex_non_linear"></span>
<a href="#span-out-non-linear">連立非線形方程式の解法</a>参照
<br>
clear;
<br>
solvex_non_linear(=&lt;f_,=&lt;x_initial_)=&lt;[
<br>
out=&lt;x=&gt;,
<div class="condition">
init=&lt;last{_ex(=&lt;x,sizer(x_initial_=&gt;),1)},
</div>
<div class="run">
run=&lt;last{
<br>
mdx=Newton(=&lt;f_,=&lt;x,=&lt;x_initial_,Nmax=20,Nmax,1e-10,1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[f=&lt;{x0^i-2*x1=3i,3*x0+exp(x1)=5i},=&lt;solvex_non_linear(=&lt;f,=&lt;{1+i,1-i})=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
implicit
<br>
Euler_method
    </th>
    <td>
<span id="span-eqn-implicit-Euler_method"></span>
<a href="#span-out-evolution">時間発展の解法</a>参照
<br>
Euler_method(t,dt,z_x00,z_v00,m,Cd_sphere,isImplicit)=&lt;[
<br>
out=&lt;{t_total,x=&gt;},
<br>
scope2storage=&lt;last{addVar(z_x0),addVar(z_v0),addVar(t_total)},
<div class="condition">
init=&lt;last{
<br>
switch(hasVar(t_total)==0,=&lt;last{t_total=0,z_x0=z_x00,z_v0=z_v00}),
<br>
g=-9.8,z_a=0+g*i,
<br>
x=&lt;{z_x,z_v},
<br>
x_initial=&lt;{z_x0,z_v0},
<br>
switch(
<br>
isImplicit,
<br>
=&lt;f=&lt;{(z_x-z_x0)/dt=z_v,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v}:
<br>
1/*else-explicit*/,
<br>
=&lt;f=&lt;{(z_x-z_x0)/dt=z_v0,m*((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v0}
<br>
),
<br>
orderT=1,
<br>
epsN=max(eps*1e3,pow(dt,orderT)),
<br>
isRelative_epsN=1,
<br>
relative_epsN=(epsN,isRelative_epsN)/*(epsN,flag)*/
<br>
},
</div>
<div class="run">
run=&lt;last{
<br>
args_Newton=(=&lt;f,=&lt;x,=&lt;x_initial,Nmax=20,Nmax,relative_epsN)/*(args)*/,
<br>
step_iteration=&lt;mdx=Newton(args_Newton),
<br>
step_post=&lt;{$z_x0,$z_v0}=x=&gt;,
<br>
step=&lt;last{step_iteration=&gt;,step_post=&gt;},
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N),
<br>
evolution=&gt;,
<br>
t_total=t_total+N*dt
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[cond_error=(hasVar(t_total)==0)&amp;hasVar(z_x0),
<br>
proc=&lt;[args=(1,0.5,0,20+20i,1,1),=&lt;Euler_method(args,1)=&gt;]=&gt;/*nesting-return*/,
<br>
=&lt;switch(cond_error==0,=&lt;proc:1,-999/*error-code*/)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
explicit
<br>
Euler_method
    </th>
    <td>
<span id="span-eqn-explicit-Euler_method"></span>
<a href="#span-out-evolution">時間発展の解法</a>参照
<br>
[cond_error=(hasVar(t_total)==0)&amp;hasVar(z_x0),
<br>
proc=&lt;[args=(1,0.5,0,20+20i,1,1),=&lt;Euler_method(args,0)=&gt;]=&gt;/*nesting-return*/,
<br>
=&lt;switch(cond_error==0,=&lt;proc:1,-999/*error-code*/)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
explicit
<br>
ODE_RK4
    </th>
    <td>
<span id="span-eqn-explicit-ODE_RK4"></span>
<a href="#span-out-evolution">時間発展の解法</a>参照
<br>
ODE_RK4(t,dt,z_x00,z_v00,m,Cd_sphere)=&lt;[
<br>
out=&lt;{tdummy,x=&gt;},
<br>
scope2storage=&lt;last{addVar(z_x),addVar(z_v),addVar(tdummy)},
<div class="condition">
init=&lt;last{
<br>
switch(hasVar(tdummy)==0,=&lt;last{z_x0=z_x00,z_v0=z_v00}),
<br>
g=-9.8,z_a=0+g*i,
<br>
x=&lt;{z_x,z_v},
<br>
x_initial=&lt;{z_x0,z_v0},
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v}
<br>
},
</div>
<div class="run">
run=&lt;last{
<br>
stepN=&lt;last{N=round(t/dt),x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,0,dt,N)},
<br>
evolution=&lt;stepN=&gt;,
<br>
evolution=&gt;
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[cond_error=(hasVar(tdummy)==0)&amp;hasVar(z_x),
<br>
proc=&lt;[args=(1,0.5,0,20+20i,1,1),=&lt;ODE_RK4(args)=&gt;]=&gt;/*nesting-return*/,
<br>
=&lt;switch(cond_error==0,=&lt;proc:1,-999/*error-code*/)]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DFT1d
    </th>
    <td>
<span id="span-eqn-DFT1d"></span>
<a href="#span-out-transform-dft">離散Fourier変換の解法</a>参照
<br>
clear;
<br>
DFT1d(f)=&lt;[
<br>
out=&lt;f,
<div class="condition">
init=&lt;last{N=sizer(f),Nf=1,Ni=1/N,F=zeros(N,1)},
</div>
<div class="run">
run=&lt;last{
<br>
F(u)=&lt;{_sx(=&lt;f[x]*e^(-i*u*x*2*pi/N),0,N-1)*Nf},
<br>
_su(=&lt;F[u]=F(u)=&gt;,0,N-1),
<br>
f(x)=&lt;{_su(=&lt;F[u]*e^(i*x*u*2*pi/N),0,N-1)*Ni},
<br>
_sx(=&lt;f[x]=f(x)=&gt;,0,N-1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[f={1,2,3,4},f=f*scalars(sizec(f),1+i),
<br>
=&lt;DFT1d(=&lt;f)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DFT2d_xy
    </th>
    <td>
<span id="span-eqn-DFT2d_xy"></span>
<a href="#span-out-transform-dft">離散Fourier変換の解法</a>参照
<br>
clear;
<br>
DFT2d_xy(f)=&lt;[
<br>
out=&lt;f,
<div class="condition">
init=&lt;last{N=sizer(f),M=sizec(f),Nf=1,Ni=1/N,Mf=1,Mi=1/M,F=zeros(N,M)},
</div>
<div class="run">
run=&lt;last{
<br>
F(u,v)=&lt;{_sy(=&lt;{_sx(=&lt;f[x][y]*e^(-i*u*x*2*pi/N),0,N-1)*Nf}*e^(-i*v*y*2*pi/M),0,M-1)*Mf},
<br>
_sv(=&lt;_su(=&lt;F[u][v]=F(u,v)=&gt;,0,N-1),0,M-1),
<br>
f(x,y)=&lt;{_sv(=&lt;{_su(=&lt;F[u][v]*e^(i*x*u*2*pi/N),0,N-1)*Ni}*e^(i*y*v*2*pi/M),0,M-1)*Mi},
<br>
_sy(=&lt;_sx(=&lt;f[x][y]=f(x,y)=&gt;,0,N-1),0,M-1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[f={1,2,3,4:5,6,7,8},f=f*scalars(sizec(f),1+i),
<br>
=&lt;DFT2d_xy(=&lt;f)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DFT2d_yx
    </th>
    <td>
<span id="span-eqn-DFT2d_yx"></span>
<a href="#span-out-transform-dft">離散Fourier変換の解法</a>参照
<br>
clear;
<br>
DFT2d_yx(f)=&lt;[
<br>
out=&lt;f,
<div class="condition">
init=&lt;last{N=sizer(f),M=sizec(f),Nf=1,Ni=1/N,Mf=1,Mi=1/M,F=zeros(N,M)},
</div>
<div class="run">
run=&lt;last{
<br>
F(v,u)=&lt;{_sx(=&lt;{_sy(=&lt;f[x][y]*e^(-i*v*y*2*pi/M),0,M-1)*Mf}*e^(-i*u*x*2*pi/N),0,N-1)*Nf},
<br>
_su(=&lt;_sv(=&lt;F[u][v]=F(v,u)=&gt;,0,M-1),0,N-1),
<br>
f(y,x)=&lt;{_su(=&lt;{_sv(=&lt;F[u][v]*e^(i*y*v*2*pi/M),0,M-1)*Mi}*e^(i*x*u*2*pi/N),0,N-1)*Ni},
<br>
_sx(=&lt;_sy(=&lt;f[x][y]=f(y,x)=&gt;,0,M-1),0,N-1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[f={1,2,3,4:5,6,7,8},f=f*scalars(sizec(f),1+i),
<br>
=&lt;DFT2d_yx(=&lt;f)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DWT1d
    </th>
    <td>
<span id="span-eqn-DWT1d"></span>
<a href="#span-out-transform-dwt">離散Wavelet変換の解法</a>参照
<br>
clear;
<br>
DWT1d(w)=&lt;[
<br>
out=&lt;w,
<div class="condition">
init=&lt;last{N=sizer(w),W=zeros(N,1),p=round(log_ex(N,2))},
</div>
<div class="run">
run=&lt;last{
<br>
W(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1),
<br>
_rn(=&lt;last{W(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;,w=W},Np=1&lt;&lt;p,p),
<br>
buffer=W,
<br>
w(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1),
<br>
_rn(=&lt;last{w(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;,W=w},Np=1,p),
<br>
W=buffer
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[w={1,2,3,4},w=w*scalars(sizec(w),1+i),
<br>
=&lt;DWT1d(=&lt;w)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DWT2d_xy
    </th>
    <td>
<span id="span-eqn-DWT2d_xy"></span>
<a href="#span-out-transform-dwt-col">離散Wavelet変換の解法（列代入）</a>参照
<br>
clear;
<br>
DWT2d_xy(w)=&lt;[
<br>
out=&lt;w,
<div class="condition">
init=&lt;last{N=sizer(w)/*N&gt;1*/,M=sizec(w),W=zeros(N,M),
<br>
p=round(log_ex(N,2)),q=round(log_ex(M,2))},
</div>
<div class="run">
run=&lt;last{
<br>
W_row(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1),
<br>
W_col(w,N)=&lt;_st(=&lt;last{
<br>
a=w[<span class="condition">-1</span>][2*t],b=w[<span class="condition">-1</span>][2*t+1],W[<span class="condition">-1</span>][t]=a+b,W[<span class="condition">-1</span>][t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1),
<br>
_rn(=&lt;last{W_row(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;,w=W},Np=1&lt;&lt;p,p),
<br>
_rn(=&lt;last{w=W,W_col(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;},Nq=1&lt;&lt;q,q),
<br>
buffer=W,
<br>
w_row(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1),
<br>
w_col(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[<span class="condition">-1</span>][t],b=W[<span class="condition">-1</span>][t+N2],w[<span class="condition">-1</span>][2*t]=(a+b)<span class="selection">*0.5</span>,w[<span class="condition">-1</span>][2*t+1]=(a-b)<span class="selection">*0.5</span>
<br>
},0,N2-1),
<br>
w=W,
<br>
_rn(=&lt;last{w_row(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;,W=w},Np=1,p),
<br>
_rn(=&lt;last{W=w,w_col(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;},Nq=1,q),
<br>
W=buffer
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[w={1,2,3,4:5,6,7,8},w=w*scalars(sizec(w),1+i),
<br>
=&lt;DWT2d_xy(=&lt;w)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
DWT2d_yx
    </th>
    <td>
<span id="span-eqn-DWT2d_yx"></span>
<a href="#span-out-transform-dwt-col">離散Wavelet変換の解法（列代入）</a>参照
<br>
clear;
<br>
DWT2d_yx(w)=&lt;[
<br>
out=&lt;w,
<div class="condition">
init=&lt;last{N=sizer(w),M=sizec(w)/*M&gt;1*/,W=zeros(N,M),
<br>
p=round(log_ex(N,2)),q=round(log_ex(M,2))},
</div>
<div class="run">
run=&lt;last{
<br>
W_row(w,N)=&lt;_st(=&lt;last{
<br>
a=w[2*t],b=w[2*t+1],W[t]=a+b,W[t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1),
<br>
W_col(w,N)=&lt;_st(=&lt;last{
<br>
a=w[<span class="condition">-1</span>][2*t],b=w[<span class="condition">-1</span>][2*t+1],W[<span class="condition">-1</span>][t]=a+b,W[<span class="condition">-1</span>][t+N2]=a-b
<br>
},N2=N&gt;&gt;1,N2-1),
<br>
_rn(=&lt;last{W_col(=&lt;w,first{Nq,Nq=Nq&gt;&gt;1})=&gt;,w=W},Nq=1&lt;&lt;q,q),
<br>
_rn(=&lt;last{w=W,W_row(=&lt;w,first{Np,Np=Np&gt;&gt;1})=&gt;},Np=1&lt;&lt;p,p),
<br>
buffer=W,
<br>
w_row(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[t],b=W[t+N2],w[2*t]=<span class="selection">0.5*</span>(a+b),w[2*t+1]=<span class="selection">0.5*</span>(a-b)
<br>
},0,N2-1),
<br>
w_col(W,N2)=&lt;_st(=&lt;last{
<br>
a=W[<span class="condition">-1</span>][t],b=W[<span class="condition">-1</span>][t+N2],w[<span class="condition">-1</span>][2*t]=(a+b)<span class="selection">*0.5</span>,w[<span class="condition">-1</span>][2*t+1]=(a-b)<span class="selection">*0.5</span>
<br>
},0,N2-1),
<br>
w=W,
<br>
_rn(=&lt;last{w_col(=&lt;W,first{Nq,Nq=Nq&lt;&lt;1})=&gt;,W=w},Nq=1,q),
<br>
_rn(=&lt;last{W=w,w_row(=&lt;W,first{Np,Np=Np&lt;&lt;1})=&gt;},Np=1,p),
<br>
W=buffer
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
[w={1,2,3,4:5,6,7,8},w=w*scalars(sizec(w),1+i),
<br>
=&lt;DWT2d_yx(=&lt;w)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
MaclaurinN
    </th>
    <td>
<span id="span-eqn-MaclaurinN"></span>
<a href="#span-out-series-Taylor">Taylor級数・Maclaurin級数の解法</a>参照
<br>
clear;
<br>
MaclaurinN(=&lt;f_,x,N)=&lt;_sn(=&lt;_dx(=&lt;f_,n,0)*x^n/n!,0,N);
<br>
last[f=&lt;exp(x),MaclaurinN(=&lt;f,2,5)=&gt;];
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
TaylorN
    </th>
    <td>
<span id="span-eqn-TaylorN"></span>
<a href="#span-out-series-Taylor">Taylor級数・Maclaurin級数の解法</a>参照
<br>
clear;
<br>
TaylorN(=&lt;f_,a,x,N)=&lt;_sn(=&lt;_dx(=&lt;f_,n,a)*(x-a)^n/n!,0,N);
<br>
last[f=&lt;exp(x),TaylorN(=&lt;f,0,2,5)=&gt;];
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
FourierN
    </th>
    <td>
<span id="span-eqn-FourierN"></span>
<a href="#span-out-series-Fourier">Fourier級数の解法</a>参照
<br>
clear;
<br>
FourierN(=&lt;ft_,x,N)=&lt;last[
<br>
cn(n)=&lt;_it(=&lt;(ft_=&gt;)*e^(-i*(n)*t),-pi,pi)/(2*pi),
<br>
_sn(=&lt;(cn(n)=&gt;)*e^(i*(n)*x),-N,N)
<br>
];
<br>
last[ft=&lt;e^(i*(2.5)*t),FourierN(=&lt;ft,2,5)=&gt;];
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
_EIS
    </th>
    <td>
<span id="span-eqn-plot2d_EIS"></span>
<a href="#span-out-simulation-EIS">EIS simulation</a>参照
<br>
clear;
<br>
<br>
make_IV(dI,f,Nt,Nint,isImplicit)=&lt;last{
<br>
L=1e-4,
<br>
R0=1,
<br>
R1=2,C1=0.1,
<br>
a1=1/(R1*C1),b1=1/C1,
<br>
a2=0.01,b2=0.12,
<br>
omega=2*pi*f,
<br>
dt=1/(f*Nt),
<br>
N=Nt*Nint,
<br>
tI=zeros(N+1,1),tV=zeros(N+1,1),
<br>
oldV1=0,
<br>
oldV2=0,
<br>
_sn(=&lt;last{
<br>
t=n*dt,
<br>
It=dI*sin(omega*t),
<br>
dIt=dI*cos(omega*t)*omega,
<br>
newV1=switch(isImplicit,(oldV1+b1*dt*It)/(1+a1*dt):1,(1-a1*dt)*oldV1+b1*dt*It),
<br>
newV2=switch(isImplicit,(oldV2+b2*dt*It)/(1+a2*dt):1,(1-a2*dt)*oldV2+b2*dt*It),
<br>
oldV1=newV1,
<br>
oldV2=newV2,
<br>
Vt=L*dIt+R0*It+newV1+newV2,
<br>
tI[n]=It,
<br>
tV[n]=Vt
<br>
},0,N)
<br>
};
<br>
<br>
FT_IV(IV,f,dt)=&lt;[
<br>
out=&lt;zIV,
<div class="condition">
init=&lt;last{N=sizer(IV)},
</div>
<div class="run">
run=&lt;last{
<br>
omega=2*pi*f,
<br>
calc_w(n)=&lt;switch((n==0)|(n==N-1),1:n%2==0,2:1,4),
<br>
calc_v(n,t,val)=&lt;calc_w(n)=&gt;*val*exp(-i*omega*t),
<br>
zIV=_sn(=&lt;calc_v(n,n*dt,IV[n])=&gt;,0,N-1)*dt/3
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
calc_Z(zI,zV)=&lt;[
<br>
out=&lt;Z,
<div class="condition">
init=&lt;last{0},
</div>
<div class="run">
run=&lt;last{
<br>
Z=zV/zI
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
sweep_f(dI,f0,f1,Nf,Nt,Nint,isImplicit)=&lt;[
<br>
out=&lt;fZ,
<div class="condition">
init=&lt;last{fZ=zeros(Nf+1,2)},
</div>
<div class="run">
run=&lt;last{
<br>
calc_f(n)=&lt;exp(log(f0)+(log(f1)-log(f0))*n/Nf),
<br>
_sn(=&lt;last{
<br>
f=calc_f(n)=&gt;,
<br>
make_IV(dI,f,Nt,Nint,isImplicit)==&gt;,
<br>
fZ[n]=(f,calc_Z(FT_IV(=&lt;tI,f,dt)=&gt;,FT_IV(=&lt;tV,f,dt)=&gt;)=&gt;)
<br>
},0,Nf)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
plot2d_EIS(isBode,fZ)=&lt;[
<br>
out=&lt;(xt,yt),
<br>
scope2storage=&lt;last{addVar(xt),addVar(yt)},
<div class="condition">
init=&lt;last{N=sizer(fZ),xt=zeros(N,1),yt=zeros(N,1)},
</div>
<div class="run">
run=&lt;last{
<br>
switch(
<br>
isBode==0/*Nyquist-plot(real(Z),-imag(Z))*/,
<br>
=&lt;_sn(=&lt;last{
<br>
Z=fZ[n][1],
<br>
xt[n]=real(Z),
<br>
yt[n]=-imag(Z)
<br>
},0,N-1):
<br>
isBode&gt;0/*Bode-plot(log10(f),|Z|)*/,
<br>
=&lt;_sn(=&lt;last{
<br>
f=fZ[n][0],
<br>
Z=fZ[n][1],
<br>
xt[n]=log10(f),
<br>
yt[n]=abs(Z)
<br>
},0,N-1):
<br>
1/*else-Bode-plot(log10(f),deg_phi)*/,
<br>
=&lt;_sn(=&lt;last{
<br>
f=fZ[n][0],
<br>
Z=fZ[n][1],
<br>
xt[n]=log10(f),
<br>
yt[n]=deg_atan2(imag(Z),real(Z))
<br>
},0,N-1)
<br>
)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
[isImplicit=1,isBode=0,
<br>
=&lt;plot2d_EIS(isBode,=&lt;sweep_f(1e-3,1e3,0.01,10,100,1,isImplicit)=&gt;)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
_EIS_DFT
    </th>
    <td>
<span id="span-eqn-plot2d_EIS_DFT"></span>
<a href="#span-out-simulation-EIS">EIS simulation</a>参照
<br>
clear;
<br>
<br>
make_IV(dI,f,Nt,Nint,isImplicit)=&lt;last{
<br>
L=1e-4,
<br>
R0=1,
<br>
R1=2,C1=0.1,
<br>
a1=1/(R1*C1),b1=1/C1,
<br>
a2=0.01,b2=0.12,
<br>
omega=2*pi*f,
<br>
dt=1/(f*Nt),
<br>
N=Nt*Nint,
<br>
tI=zeros(N+1,1),tV=zeros(N+1,1),
<br>
oldV1=0,
<br>
oldV2=0,
<br>
_sn(=&lt;last{
<br>
t=n*dt,
<br>
It=dI*sin(omega*t),
<br>
dIt=dI*cos(omega*t)*omega,
<br>
newV1=switch(isImplicit,(oldV1+b1*dt*It)/(1+a1*dt):1,(1-a1*dt)*oldV1+b1*dt*It),
<br>
newV2=switch(isImplicit,(oldV2+b2*dt*It)/(1+a2*dt):1,(1-a2*dt)*oldV2+b2*dt*It),
<br>
oldV1=newV1,
<br>
oldV2=newV2,
<br>
Vt=L*dIt+R0*It+newV1+newV2,
<br>
tI[n]=It,
<br>
tV[n]=Vt
<br>
},0,N)
<br>
};
<br>
<br>
DFT_IV(IV,f,dt)=&lt;[
<br>
out=&lt;zIV,
<div class="condition">
init=&lt;last{N=sizer(IV)},
</div>
<div class="run">
run=&lt;last{
<br>
omega=2*pi*f,
<br>
zIV=_sn(=&lt;IV[n]*exp(-i*omega*n*dt),0,N-1)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
calc_Z(zI,zV)=&lt;[
<br>
out=&lt;Z,
<div class="condition">
init=&lt;last{0},
</div>
<div class="run">
run=&lt;last{
<br>
Z=zV/zI
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
sweep_f(dI,f0,f1,Nf,Nt,Nint,isImplicit)=&lt;[
<br>
out=&lt;fZ,
<div class="condition">
init=&lt;last{fZ=zeros(Nf+1,2)},
</div>
<div class="run">
run=&lt;last{
<br>
calc_f(n)=&lt;exp(log(f0)+(log(f1)-log(f0))*n/Nf),
<br>
_sn(=&lt;last{
<br>
f=calc_f(n)=&gt;,
<br>
make_IV(dI,f,Nt,Nint,isImplicit)==&gt;,
<br>
fZ[n]=(f,calc_Z(DFT_IV(=&lt;tI,f,dt)=&gt;,DFT_IV(=&lt;tV,f,dt)=&gt;)=&gt;)
<br>
},0,Nf)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
plot2d_EIS_DFT(isBode,fZ)=&lt;[
<br>
out=&lt;(xt,yt),
<br>
scope2storage=&lt;last{addVar(xt),addVar(yt)},
<div class="condition">
init=&lt;last{N=sizer(fZ),xt=zeros(N,1),yt=zeros(N,1)},
</div>
<div class="run">
run=&lt;last{
<br>
switch(
<br>
isBode==0/*Nyquist-plot(real(Z),-imag(Z))*/,
<br>
=&lt;_sn(=&lt;last{
<br>
Z=fZ[n][1],
<br>
xt[n]=real(Z),
<br>
yt[n]=-imag(Z)
<br>
},0,N-1):
<br>
isBode&gt;0/*Bode-plot(log10(f),|Z|)*/,
<br>
=&lt;_sn(=&lt;last{
<br>
f=fZ[n][0],
<br>
Z=fZ[n][1],
<br>
xt[n]=log10(f),
<br>
yt[n]=abs(Z)
<br>
},0,N-1):
<br>
1/*else-Bode-plot(log10(f),deg_phi)*/,
<br>
=&lt;_sn(=&lt;last{
<br>
f=fZ[n][0],
<br>
Z=fZ[n][1],
<br>
xt[n]=log10(f),
<br>
yt[n]=deg_atan2(imag(Z),real(Z))
<br>
},0,N-1)
<br>
)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
[isImplicit=1,isBode=0,
<br>
=&lt;plot2d_EIS_DFT(isBode,=&lt;sweep_f(1e-3,1e3,0.01,10,100,1,isImplicit)=&gt;)=&gt;]=&gt;;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
_IV
    </th>
    <td>
<span id="span-eqn-plot2d_IV"></span>
<a href="#span-out-simulation-EIS">EIS simulation</a>参照
<br>
clear;
<br>
<br>
make_tIV(dI,f,Nt,Nint,isImplicit)=&lt;last{
<br>
L=1e-4,
<br>
R0=1,
<br>
R1=2,C1=0.1,
<br>
a1=1/(R1*C1),b1=1/C1,
<br>
a2=0.01,b2=0.12,
<br>
omega=2*pi*f,
<br>
dt=1/(f*Nt),
<br>
N=Nt*Nint,
<br>
tt=zeros(N+1,1),tI=zeros(N+1,1),tV=zeros(N+1,1),
<br>
oldV1=0,
<br>
oldV2=0,
<br>
_sn(=&lt;last{
<br>
t=n*dt,
<br>
It=dI*sin(omega*t),
<br>
dIt=dI*cos(omega*t)*omega,
<br>
newV1=switch(isImplicit,(oldV1+b1*dt*It)/(1+a1*dt):1,(1-a1*dt)*oldV1+b1*dt*It),
<br>
newV2=switch(isImplicit,(oldV2+b2*dt*It)/(1+a2*dt):1,(1-a2*dt)*oldV2+b2*dt*It),
<br>
oldV1=newV1,
<br>
oldV2=newV2,
<br>
Vt=L*dIt+R0*It+newV1+newV2,
<br>
tt[n]=t,
<br>
tI[n]=It,
<br>
tV[n]=Vt
<br>
},0,N)
<br>
};
<br>
<br>
plot2d_IV(dI,f,Nt,Nint,isImplicit)=&lt;[
<br>
out=&lt;(xt,yt),
<br>
scope2storage=&lt;last{addVar(xt),addVar(yt)},
<div class="condition">
init=&lt;last{N=Nt*Nint,xt=zeros(N+1,1),yt=zeros(N+1,2)},
</div>
<div class="run">
run=&lt;last{
<br>
make_tIV(dI,f,Nt,Nint,isImplicit)==&gt;,
<br>
_sn(=&lt;last{xt[n]=tt[n],yt[n]=(tI[n],tV[n])},0,N)
<br>
},
</div>
init=&gt;,run=&gt;,return=out=&gt;,scope2storage=&gt;,
<br>
=&lt;return]=&gt;;
<br>
<br>
[isImplicit=1,
<br>
=&lt;plot2d_IV(1e-3,0.5,100,2,isImplicit)=&gt;]=&gt;;
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

  </div>
</body>

</html>
