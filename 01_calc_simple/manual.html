<!DOCTYPE html>

<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="description" content="[説明書]電卓non-eval">
  <meta name="author" content="online-simulator.github.io">
  <noscript>JavaScript is not enabled on browser.</noscript>
  <link rel="stylesheet" type="text/css" href="../00_common/css/common.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/color.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/size.css">
  <link rel="stylesheet" type="text/css" href="css/common.css">
  <link rel="stylesheet" type="text/css" href="css/color.css">
  <link rel="stylesheet" type="text/css" href="css/size.css">
</head>

<body>
  <div>

<div>
<h2>[説明書]電卓non-eval</h2>
</div>

<hr>
<div>
<table>
<caption>初期表示の複素数演算の解はオプションの条件設定によって異なる</caption>
<thead>
  <tr>
    <th>
結合条件
    </th>
    <th>
優先条件
    </th>
    <th>
条件設定に依らない括弧明示
    </th>
    <th>
解
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td colspan="2">
下記4種類
    </td>
    <td>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
←初期表示
    </td>
    <td>
=e^(i{t})
   </td>
  </tr>
  <tr>
    <td>
左結合
    </td>
    <td>
記号省略乗算優先
    </td>
    <td>
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
←既定
    </td>
    <td>
=e^(i{-pi/4})
    </td>
  </tr>
  <tr>
    <td>
右結合
    </td>
    <td>
記号省略乗算優先
    </td>
    <td>
e^(-i({1pi()2}/{{2i(5-{3-1})i}/(-4)}))
    </td>
    <td>
=e^(i{-4pi/3})
    </td>
  </tr>
  <tr>
    <td>
左結合
    </td>
    <td>
除算優先
    </td>
    <td>
e^(-i(1pi(){2/2i}({5-3}-1){i/(-4)}))
    </td>
    <td>
=e^(i{pi/4})
    </td>
  </tr>
  <tr>
    <td>
右結合
    </td>
    <td>
除算優先
    </td>
    <td>
e^(-i(1pi(){2/2i}(5-{3-1}){i/(-4)}))
    </td>
    <td>
=e^(i{3pi/4})
    </td>
  </tr>
  <tr>
    <td colspan="4">
実数演算不可（0*Infinity->NaNが発生するため）
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption>電卓説明書の前置き</caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
目次
    </th>
    <td>
<span id="span-index"></span>
本説明書の目次を列挙する
<br>
<br>
前提
<br>
・
<a href="#span-pre-out">
外部仕様
</a>
<br>
・
<a href="#span-pre-in">
内部仕様
</a>
<br>
・
<a href="#span-pre-ref">
参考文献
</a>
<br>
<br>
<a href="#span-out">
外部仕様
</a>
<br>
・
<a href="#span-out-UI-simple">
簡易電卓UI
</a>
<br>
・
<a href="#span-out-log">
ログ表示仕様
</a>
<br>
・
<a href="#span-out-options">
オプション
</a>
<br>
・
<a href="#span-out-prec">
優先順位
</a>
<br>
・
<a href="#span-out-float">
浮動小数点演算
</a>
<br>
・
<a href="#span-out-error">
誤差の扱い
</a>
<br>
・
<a href="#span-out-config">
裏設定
</a>
<br>
・
<a href="#span-out-ope">
演算仕様
</a>
<br>
・
<a href="#span-out-flow">
演算フロー
</a>
<br>
・
<a href="#span-out-storage">
ストレージ
</a>
<br>
・入力仕様
<br>
　・
<a href="#span-out-comment">
コメント文
</a>
<br>
　・
<a href="#span-out-command">
命令文
</a>
<br>
　・
<a href="#span-out-SR">
区切り文字
</a>
<br>
　・
<a href="#span-out-BT">
括弧
</a>
<br>
　・
<a href="#span-out-RW">
予約語
</a>
<br>
　・
<a href="#span-out-FN0">
定数
</a>
<br>
　・
<a href="#span-out-BRmo">
記号省略乗算
</a>
<br>
　・
<a href="#span-out-com">
複素数
</a>
<br>
　・
<a href="#span-out-FN">
関数
</a>
<br>
　・
<a href="#span-out-mat">
行列
</a>
<br>
　・
<a href="#span-out-FNm0">
定数扱いの行列
</a>
<br>
　・
<a href="#span-out-FNm">
行列関数
</a>
<br>
　・
<a href="#span-out-concat">
行列操作
</a>
<br>
　・
<a href="#span-out-FNmspecial">
特殊行列関数
</a>
<br>
　・
<a href="#span-out-vars">
変数
</a>
<br>
　・
<a href="#span-out-substitution">
変数への代入
</a>
<br>
　・
<a href="#span-out-eqns">
式変数
</a>
<br>
　・
<a href="#span-out-substitution-equation">
式変数への代入
</a>
<br>
　・
<a href="#span-out-FNh">
高階関数
</a>
<br>
　・
<a href="#span-out-FNmh">
行列高階関数
</a>
<br>
・解法
<br>
　・
<a href="#span-out-fdm">
有限差分法
</a>
<br>
　・
<a href="#span-out-linear">
連立線形方程式
</a>
<br>
　・
<a href="#span-out-non-linear">
連立非線形方程式
</a>
<br>
　・
<a href="#span-out-limit">
極限
</a>
<br>
・
<a href="#span-out-special">
特殊仕様
</a>
<br>
<br>
<a href="#span-in">
内部仕様
</a>
<br>
・
<a href="#span-in-tree">
単位tree構造
</a>
<br>
・
<a href="#span-in-options">
オプション
</a>
<br>
・
<a href="#span-in-prec">
変数・関数・区切り文字・演算子の優先順位
</a>
<br>
・
<a href="#span-in-FN">
定義済みの関数・予約語
</a>
    </td>
  </tr>
  <tr>
    <th>
外部仕様の前提
    </th>
    <td>
<span id="span-pre-out"></span>
外部仕様の前提を列挙する
<br>
<br>
・論理記号||は、ORを意味する
<br>
・アロー記号->の左側に入力の演算内容、右側に出力の演算結果を示す
<br>
　入力演算内容 -> 出力演算結果
<br>
・誤差のオーダーをLandauの記号O(指数表記1e-16等)で表記する
<br>
・数学で言うベクトルまたは行列の成分を要素と表記する
<br>
・方程式または関数式を引数に取る関数を高階関数と表記する
<br>
　この場合の引数を通常の値渡しに対して式渡しと表記する
    </td>
  </tr>
  <tr>
    <th>
内部仕様の前提
    </th>
    <td>
<span id="span-pre-in"></span>
内部仕様の前提について記述する
<br>
<br>
直接入力による構文解析で問題となるeval不使用(non-eval)
<br>
<br>
evalに代わる実装項目とファイル名の対応関係を列挙する
<br>
・構文解析・単位tree構造: parser.js/operation.js/DATA.js
<br>
・変数・関数・区切り文字・演算子の優先順位: operation.js
<br>
・演算ユニット: operation.js/unit.js
<br>
・定義済みの関数・予約語: parser.js/math.js/math_com.js/math_mat.js
<br>
　その他、ビルトインの関数・演算子を使用
<br>
・連立方程式の解法: solver.js
    </td>
  </tr>
  <tr>
    <th>
参考文献
    </th>
    <td>
<span id="span-pre-ref"></span>
参考文献について記述する
<br>
<br>
developer.mozilla.org/ja/docs/項目を列挙する
<br>
・浮動小数点数
<br>
・Number
<br>
<br>
en.m.wikipedia.org/wiki/項目を列挙する
<br>
・Rotation_formalisms_in_three_dimensions
<br>
<br>
ja.m.wikipedia.org/wiki/項目を列挙する
<br>
・演算子の優先順位
<br>
・IEEE_754
<br>
・誤差
<br>
・行列
<br>
・有限差分
<br>
・ラグランジュ補間
<br>
・シンプソンの公式
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-out">電卓の設定項目と入力仕様に関する外部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
簡易電卓
<br>
UI
    </th>
    <td>
<span id="span-out-UI-simple"></span>
簡易電卓の操作パネルについて記述する
<br>
<br>
パネル上段について記述する
<br>
・ドラッグ移動可チェックでドラッグ移動有効化
<br>
・出力欄に入力欄の演算結果を表示
<br>
・入力欄に演算内容を入力
<br>
・swチェックでpush/pop入力と直接入力を切替え可
<br>
・0xチェックで16進数のa-fの入力ボタンを追加表示
<br>
・その下のiの入力ボタンはcomplexチェック時のみ表示
<br>
・左側に0-9の数字と小数点.の入力ボタンを表示
<br>
・その右側に四則演算の演算子記号の入力ボタンを表示
<br>
<br>
パネル右側について記述する
<br>
・Cボタンは入力欄／出力欄の内容と保存変数のクリア実行を確定する
<br>
　マルチスレッド実行時は演算を中断する
<br>
・BSボタンは入力欄の選択位置の前を消去する
<br>
・ansボタンは出力欄の演算結果を入力欄に確定する
<br>
　演算結果が実数以外の場合、入力欄を消去して予約変数ansを挿入
<br>
・＝ボタンは入力欄の内容で演算実行を確定する
<br>
<br>
パネル中段について記述する
<br>
・complexチェックで複素数演算を有効化・iの入力ボタンを表示
<br>
・matrixチェックで行列演算を有効化
<br>
　定義できる2項の演算のみ
<br>
・演算結果の小数表記と指数表記を選択可
<br>
　小数表記: 0.1
<br>
　指数表記: 1e-1 -> 0.1
<br>
<br>
パネル下段について記述する
<br>
・履歴欄に最新を上にして演算履歴を表示・表示制限5000字以内
<br>
・履歴欄下のリンクから演算履歴の全文をテキスト保存可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
ログ
<br>
表示仕様
    </th>
    <td>
<span id="span-out-log"></span>
ログ表示上の仕様と付随する留意事項について記述する
<br>
<br>
代入を伴わない場合
<br>
・演算後の値のみ表示する
<br>
・直前の実行文の演算結果を保持する予約変数ansへの代入を明示しない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
(3*2,1) -> (6,1)
<br>
ans -> (6,1)
<br>
<br>
変数への代入の場合
<br>
・変数名と代入値を明示する
<br>
x=3*2 -> x=6
<br>
x=(3*2,3) -> x=(6,3)
<br>
・予約変数ansは更新されない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
x=2 -> x=2
<br>
ans -> 6
<br>
<br>
式変数への代入の場合
<br>
・式変数名のみ明示する
<br>
eqn_x&lt;=(a*x+b=0) -> stored_eqn(eqn_x)
<br>
3*2 -> 6
<br>
eqn_t&lt;=sin(omega(t)) -> stored_eqn(eqn_t)
<br>
ans -> 6
<br>
<br>
表示仕様ではないが、以下の演算都合上の仕様について記述する
<br>
・代入を括弧で括った場合、零を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は零が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をカンマまたはコロンで区切った場合、零を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
(1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、行列を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
オプション
    </th>
    <td>
<span id="span-out-options"></span>
選択可能なオプション設定について記述する
<br>
<br>
2項演算子の結合性を左右選択可
<br>
・左から順に結合する場合、左結合（既定）
<br>
-5-3-1 || ((0-5)-3)-1 -> -9
<br>
3^2^3 || 3**2**3 || (3^2)^3 || (3**2)**3 -> 729
<br>
-(1,1)-(2,2) || ((0,0)-(1,1))-(2,2) -> (-3,-3)
<br>
・右から順に結合する場合、右結合
<br>
-5-3-1 || 0-(5-(3-1)) -> -3
<br>
3^2^3 || 3**2**3 || 3^(2^3) || 3**(2**3) -> 6561
<br>
-(1,1)-(2,2) || (0,0)-((1,1)-(2,2)) -> (1,1)
<br>
・前置き単項の符号は同種の2項演算子と区別しない
<br>
・符号の左側には零または零行列が存在すると仮定して結合する
<br>
・べき乗の2項演算子は^と**を区別しない
<br>
<br>
記号省略乗算と除算の優先順位を切替え可
<br>
・除算より記号省略乗算優先（既定）
<br>
1/2(2) || 1/(2(2)) -> 0.25
<br>
・記号省略乗算より除算優先
<br>
1/2(2) || (1/2)(2) -> 1
<br>
<br>
マルチスレッド実行を選択可
<br>
・シングルスレッド実行時はタイムアウトまで演算を中断不可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
優先順位
    </th>
    <td>
<span id="span-out-prec"></span>
演算子の優先順位について一部記述する
<br>
<br>
除算と乗算の2項演算子は区別せず、結合性に従って演算する
<br>
記号省略乗算は除算より優先する
<br>
<br>
減算と加算の2項演算子は区別せず、結合性に従って演算する
<br>
前置き単項の符号は同種の2項演算子と区別せず、結合性に従って演算する
<br>
<br>
後置きの単項演算子は2項演算子より優先する
<br>
3^2! || 3^(2!) -> 9
<br>
2*3!! || 2*(3!!) -> 6
<br>
・階乗の被演算子は自然数のみ対応
<br>
<br>
ビット演算子を除く2項演算子は前置き単項の符号より優先する
<br>
-2^2 || -(2^2) -> -4
<br>
-0xff&gt;&gt;2 || (-0xff)&gt;&gt;2 || (-255)&gt;&gt;2 -> -64
<br>
・排他的論理和XORの2項演算子は^の代わりに@を使用する
<br>
-0xff&gt;&gt;1@1 || (-0xff&gt;&gt;1)@1 || (-128)@1 -> -127
<br>
<br>
詳細は<a href="#span-in-prec">内部仕様</a>参照
<br>
<br>
細かな設定変更は
<a href="#span-out-config">裏設定</a>
参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
浮動小数点
<br>
演算
    </th>
    <td>
<span id="span-out-float"></span>
JavaScriptによる実数の浮動小数点演算について記述する
<br>
<br>
次のIEEE754規格の倍精度64bit2進形式の浮動小数点数を使用する
<br>
これによる演算を以降、浮動小数点演算と呼ぶ
<br>
・64bitの上位から順に3つのフィールド（符号部・指数部・仮数部）を持つ
<br>
10進換算の浮動小数点数
<br>
=(-1)^(符号部1bit)*pow(基数2,指数部11bit-バイアス)*(0||1+仮数部52bit)
<br>
・指数部・仮数部は符号なしの2進数
<br>
・指数部は符号ありを符号なしに変換する次のバイアスを持つ
<br>
バイアス=2^(11-1)-1=1023
<br>
・pow関数(base,exponent)はbase^exponentを返却する関数
<br>
・10進換算の指数に相当する
<br>
pow(2,10) || 2^10 || 1024 -> 1.024e3
<br>
・仮数部が小数点以下の有効桁（10進換算で16~17桁）を保持する
<br>
・最上位bitから最下位bitまでの10進換算した有効数字の演算結果を示す
<br>
pow(2,-1) || 2^(-1) -> 0.5
<br>
pow(2,-2) || 2^(-2) -> 0.25
<br>
...
<br>
pow(2,-51) || 2^(-51) -> 4.440892098500626e-16
<br>
pow(2,-52) || 2^(-52) -> 2.220446049250313e-16
<br>
・この最小値より小さな有効数字は保持できない
<br>
・これを丸める誤差をマシンイプシロン（以降、マシン誤差）と呼ぶ
<br>
・仮数部の最下位bitの有効数字未満を丸める相対誤差を次のεで定義する
<br>
epsilon || eps || pow(2,-52) -> 2.220446049250313e-16
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> 1
<br>
10+10epsilon -> 10.000000000000002
<br>
10+10epsilon/2 -> 10.000000000000002
<br>
10+10epsilon/4 -> 10
<br>
100+100epsilon/4 -> 100
<br>
1000+1000epsilon/4 -> 1000
<br>
1e4+1e4epsilon/4 -> 10000
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> 0.9999999999999999
<br>
1-epsilon/4 -> 1
<br>
10-10epsilon/4 -> 10
<br>
100-100epsilon/4 -> 100
<br>
1000-1000epsilon/4 -> 1000
<br>
1e4-1e4epsilon/4 -> 10000
<br>
<br>
64bit2進形式の浮動小数点演算の挙動を示す
<br>
・16桁の小数を入力した場合、同じ
<br>
0.9999999999999999 -> 0.9999999999999999
<br>
-0.9999999999999999 -> -0.9999999999999999
<br>
・17桁の小数を入力した場合、先述のマシン誤差が生じる
<br>
0.99999999999999999 -> 1
<br>
-0.99999999999999999 -> -1
<br>
・整数も小数同様の形式で保存される
<br>
・よって17桁以上の整数を入力した場合、小数同様にマシン誤差が生じる
<br>
9007199254740991 -> 9007199254740991
<br>
90071992547409911 -> 90071992547409900
<br>
900719925474099111 -> 900719925474099100
<br>
9007199254740991111 -> 9007199254740991000
<br>
90071992547409911111 -> 90071992547409900000
<br>
900719925474099111111 -> 900719925474099100000
<br>
9007199254740991111111 -> 9.007199254740991e+21
<br>
・1000で割って1000を掛けた場合、マシン誤差が生じる
<br>
9007199254740991/1000 -> 9007199254740.99
<br>
ans*1000 -> 9007199254740990
<br>
0.9999999999999999/1000 -> 0.0009999999999999998
<br>
ans*1000 -> 0.9999999999999998
<br>
・2の累乗倍で演算すれば仮数部の有効桁はそのまま保持される
<br>
9007199254740991/1024 -> 8796093022207.999
<br>
ans*1024 -> 9007199254740991
<br>
9007199254740991/2^100 -> 7.105427357601001e-15
<br>
ans*2^100 -> 9007199254740991
<br>
9007199254740991/2^(-100) -> 1.1417981541647678e+46
<br>
ans*2^(-100) -> 9007199254740991
<br>
0.9999999999999999/1024 -> 0.0009765624999999999
<br>
ans*1024 -> 0.9999999999999999
<br>
0.9999999999999999/2^100 -> 7.888609052210117e-31
<br>
ans*2^100 -> 0.9999999999999999
<br>
0.9999999999999999/2^(-100) -> 1.2676506002282293e+30
<br>
ans*2^(-100) -> 0.9999999999999999
<br>
<br>
JavaScriptのNumber型の定数を示す
<br>
EPSILON -> 2.220446049250313e-16
<br>
MIN_SAFE_INTEGER || -(2^53-1) -> -9007199254740991
<br>
MAX_SAFE_INTEGER || +(2^53-1) -> 9007199254740991
<br>
MIN_VALUE -> 5e-324
<br>
MIN_VALUE/2 -> 0
<br>
MIN_VALUE*(1-EPSILON) -> 5e-324
<br>
MAX_VALUE -> 1.7976931348623157e+308
<br>
MAX_VALUE*2 -> Infinity
<br>
MAX_VALUE*(1+EPSILON) -> Infinity
<br>
・Nativeの場合
<br>
Math.pow(2,Math.pow(2,10)) || 2**(2**10) -> Infinity
<br>
・実数演算の場合、Nativeに同義
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> Infinity
<br>
・複素数演算の場合、辛うじてMAX_VALUEに近い値が得られる
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> 1.7976931348622732e+308
<br>
ans*2 -> Infinity
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
誤差の扱い
    </th>
    <td>
<span id="span-out-error"></span>
誤差の種類とその扱いについて記述する
<br>
<br>
本説明書では大きく分けて次の2種類に分類する
<br>
・丸め誤差: 計算機での数値表現由来の誤差
<br>
　・情報落ち（絶対値の大きく異なる2つの数値の差または和を取る場合）
<br>
　・桁落ち（丸め誤差を含む同符号の2つの近い数値の差を取る場合）
<br>
・数値誤差: 数学的な近似由来の誤差
<br>
　・離散化誤差（微分・積分の無限小を有限の幅で離散化する場合）
<br>
　・打切り誤差（無限級数を有限の次数で打切る場合）
<br>
<br>
丸め誤差は無理数等を仮数部の有効桁に丸める際の、
<br>
近似値の真値に対する絶対誤差または相対誤差と定義する
<br>
・円周率20桁の演算結果を例に示す
<br>
3.14159265358979323846 -> 3.141592653589793
<br>
・円周率20桁の絶対誤差はマシン誤差に相当する
<br>
0.00000000000000023846 -> 2.3846e-16
<br>
・円周率20桁の相対誤差
<br>
0.00000000000000023846/pi -> 7.590417545938672e-17
<br>
<br>
2つの数値の減算または加算で情報落ちが発生した場合、警告を表示する
<br>
1+1e-16 -> infoLost!! 1
<br>
1-1e-16 -> infoLost!! 0.9999999999999999
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> infoLost!! 1
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> infoLost!! 0.9999999999999999
<br>
<br>
虚数単位iを求める複素数演算を一例に誤差情報の特徴を示す
<br>
(-1)^0.5 -> 6.123233995736766e-17+i
<br>
・実部にマシン誤差が残るため、1を加算すると情報落ちが発生する
<br>
ans+1 -> infoLost!! 1+i
<br>
・さらに演算を繰り返すと、誤差情報は消えることなく伝播する
<br>
ans+1 -> infoLost!! 2+i
<br>
ans+1 -> infoLost!! 3+i
<br>
ans+1 -> infoLost!! 4+i
<br>
ans+1 -> infoLost!! 5+i
<br>
<br>
桁落ちは判定困難で評価にかかる演算量を見積もれないため、評価しない
<br>
・整数演算を一例に示す
<br>
・丸め誤差を含む2つの整数を作る
<br>
・コメントに有効桁のbitの並びを示す
<br>
255  // 11111111 -> 255
<br>
255&gt;&gt;2  // 111111 -> 63
<br>
ans&lt;&lt;2  // 11111100 -> 252
<br>
255&gt;&gt;3  // 11111 -> 31
<br>
ans&lt;&lt;3  // 11111000 -> 248
<br>
・2つの整数の差を取ると有効桁が減少して丸め誤差が拡大する
<br>
252-248  // 100 -> 4
<br>
<br>
数値誤差は無限を有限で近似した際の、
<br>
近似値の真値に対する絶対誤差または相対誤差、あるいは、
<br>
近似解の厳密解に対する絶対誤差または相対誤差、あるいは、
<br>
数値解の解析解に対する絶対誤差または相対誤差と定義する
<br>
<br>
数値誤差は目安の解析誤差（絶対誤差）のオーダーを表示する
<br>
<br>
f(x)=x^2のx=1+iにおける1階微分の数値解
<br>
x=1+i; _dx(&lt;={x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・上記微分の解析解
<br>
x=1+i; 2x -> 2+2i
<br>
・変数を使用
<br>
ansn=1.9999999999996223+1.9999999999996223i;
<br>
ansa=2+2i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 3.7769787297747826e-13+3.7769787297747826e-13i
<br>
・絶対誤差のEuclidノルム
<br>
norm(erra) -> 5.341454544442203e-13
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 1.8884893648873913e-13+1.8884893648873913e-13i
<br>
・相対誤差のEuclidノルム
<br>
norm(errr) -> 2.6707272722211015e-13
<br>
<br>
f(x)=x^4の積分範囲[0,1+i]における定積分の数値解
<br>
a=0; b=1+i; _ix(&lt;={x^4},a,b) || ab=[0,1+i]; _ix(&lt;={x^4},ab)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・解析解
<br>
a=0; b=1+i; (b^5-a^5)/5 -> -0.8000000000000003-0.8000000000000002i
<br>
・変数を使用
<br>
ansn=-0.8000000053333336-0.8000000053333334i;
<br>
ansa=-0.8000000000000003-0.8000000000000002i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 5.333333330526102e-9+5.3333332195038e-9i
<br>
・絶対誤差のEuclidノルム
<br>
norm(erra) -> 7.54247225018186e-9
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 6.666666663157625e-9+6.666666524379749e-9i
<br>
・相対誤差のEuclidノルム
<br>
norm(errr) -> 9.428090312727323e-9
<br>
<br>
数値誤差の特徴を示す
<br>
・数値誤差を含む演算結果に対して
<br>
x=1+i; _dx(&lt;={x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・演算すると目安の解析誤差も演算される
<br>
ans*1e3 -> 1999.9999999996223+1999.9999999996223i+O(1e-9+1e-9i)
<br>
ans/1e3 -> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
ans*ans -> 7.999999999996978i+O(8e-12i)
<br>
sinh(ans) -> 0.9893582466238214i+O(1e-12i)
<br>
・ただし、減算または加算では誤差の最大値を選択する
<br>
ans+2ans -> 2.968074739871464i+O(2e-12i)
<br>
ans-2ans -> -2.968074739871464i+O(5e-12i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
裏設定
    </th>
    <td>
<span id="span-out-config"></span>
UIには表示しない裏設定について記述する
<br>
<br>
ブラウザ上部のURL入力欄のGET入力で
<a href="#span-in-options">内部オプション</a>
を変更可
<br>
・html直後の?に続けて&amp;区切りでパラメータを渡す
<br>
index.html?param0=value0&amp;param1=value1&amp;param2=value2&amp;...
<br>
<br>
演算子の優先順位を変更する場合
<br>
・演算子の
<a href="#span-in-prec">tag名</a>
を優先順にカンマ区切りで列挙する
<br>
precedence=URi,URf,BRp,BRr,BRmo,BRdm,BRsa,BRbs,BRba,BRbx,BRbo
<br>
・別途、乗算記号の省略を許容しない場合、tag名BRmoを削除する
<br>
　その場合、treeを全走査判定する無駄な演算量が減る
<br>
<br>
checkError=trueの場合、情報落ちの発生や微分・積分の数値誤差を評価する
<br>
checkError=falseに設定した場合、演算量が数倍軽くなる
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算仕様
    </th>
    <td>
<span id="span-out-ope"></span>
演算量または演算速度に関係する演算仕様の概要について記述する
<br>
<br>
UI設定によって対応する用途を4種類示す
<br>
・有次元の複素数の行列演算（complex/matrixにチェック）
<br>
・有次元の実数の行列演算（matrixにチェック）
<br>
・無次元の複素数演算（complexにチェック）
<br>
・無次元の実数演算（チェックなし）
<br>
<br>
次の2次の正方行列の積を例に
<br>
(0,0:0,1+i)(1,0:0,1)
<br>
・上記の用途順に演算結果のみ示す
<br>
-> (0,0:0,1+i)
<br>
-> (0,0:0,1)
<br>
-> 1+i
<br>
-> 1
<br>
<br>
用途によらず、行列要素は左から右にすべて演算する
<br>
・行ベクトルをコロンで区切って列挙
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
・列ベクトルをコロンで区切って列挙
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
<br>
<br>
その上で、無次元の場合、行列の最終要素を取り出して演算する
<br>
(x=1,x=2x:x=2x,x)1 || {x=1,x=2x:x=2x,x}1 || (0,0:0,4)1 || (4)*1 -> 4
<br>
・よって行列の積は次の乗算に変換される
<br>
(x=1,x=2x:x=2x,x){x=1,x=2x:x=2x,x} || (4)*{4} -> 16
<br>
<br>
以上より、n次の正方行列の積の演算量を用途順に概算して示す
<br>
4*(n*n)*(n*n)
<br>
(n*n)*(n*n)
<br>
4
<br>
1
<br>
<br>
演算単位の数値データは内部で複素数の行列として扱う
<br>
・これより用途をシームレスに切替えて上記の演算量を調整する
<br>
<br>
合わせて共通化する仕様について記述する
<br>
<br>
関数の引数ベクトル
<br>
・行列の最終行ベクトルを左から順に参照
<br>
max(1,2,3:-1,-2,-3) || max(-1,-2,-3) -> -1
<br>
sqrt(1,2,3:4,5,6) || sqrt(4,5,6) || sqrt(4) -> 2
<br>
<br>
定義できない行列演算
<br>
・差と和のみ行列サイズ不一致で入力ミスによるerror終了
<br>
(1,3)+(1) -> [MyErr]Invalid matrix operation
<br>
・無次元の場合、行列の最終要素を演算・無次元化するのと同様に
<br>
(1,3)+(1) || (3)+(1) -> 4
<br>
・剰余等の演算を実行した場合、行列の最終要素を参照して演算・無次元化
<br>
(1,2)%2 || (2)%2 -> 0
<br>
<br>
詳細は<a href="#span-in-tree">単位tree構造</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算フロー
    </th>
    <td>
<span id="span-out-flow"></span>
演算実行確定1回の演算フローについて記述する
<br>
<br>
次の3関数による演算フローを示す
<br>
main関数　⇔　parse関数　⇔　operation関数
<br>
・main関数
<br>
　・入力データを作ってparse関数に渡す
<br>
　・出力データから演算結果を外部に表示する
<br>
・parse関数
<br>
　・入力データから実行文を作ってoperation関数に渡す
<br>
　・演算結果から出力データを作ってmain関数に返す
<br>
・operation関数
<br>
　・実行文から演算結果を作ってparse関数に返す
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
ストレージ
    </th>
    <td>
<span id="span-out-storage"></span>
ストレージ（storage）について記述する
<br>
<br>
ストレージは変数・式変数を保存するオブジェクトで次の2種類
<br>
<br>
ローカルstorage
<br>
・演算実行確定1回の各実行文の変数・式変数を保存する
<br>
・保存された変数をローカル変数と呼ぶ
<br>
・保存された式変数をローカル式変数と呼ぶ
<br>
<br>
グローバルstorage
<br>
・演算実行確定1回毎に返される変数・式変数を累積保存する
<br>
・保存された変数をグローバル変数と呼ぶ
<br>
・保存された式変数をグローバル式変数と呼ぶ
<br>
<br>
演算実行確定1回のローカル変数とグローバル変数のフローを示す
<br>
（式変数も同様）
<br>
・演算実行開始　グローバル変数⇒ローカル変数に保存
<br>
・演算実行途中　ローカル変数をread/write
<br>
・演算実行終了　ローカル変数⇒グローバル変数に保存
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
コメント文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-comment"></span>
コメント文の入力仕様と付随する留意事項について記述する
<br>
<br>
次のコメント文2種類は実行文に含まれない
<br>
// 行コメント
<br>
/* ブロックコメント */
<br>
<br>
一例を示す
<br>
x=-0xff; /*x:16進数値*/ x&gt;&gt;3 // 右シフト3回
<br>
-> -32
<br>
・parse後の実行文を示す
<br>
x=-0xff; x&gt;&gt;3 -> -32
<br>
・以下の演算に同義
<br>
x=-255; floor(x/(2^3)) -> -32
<br>
x=-255; int(x/(2^3)) -> -32
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
命令文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-command"></span>
命令文の入力仕様と付随する留意事項について記述する
<br>
<br>
次の命令文は上位の実行文に相当する
<br>
<br>
clear
<br>
・ローカルstorageをクリアする
<br>
x=3;演算実行確定
<br>
-> x=3
<br>
clear;演算実行確定 -> local storage cleared
<br>
x;演算実行確定 -> 3
<br>
clear; x;演算実行確定 -> [MyErr]Invalid REv(x)
<br>
x;演算実行確定 -> 3
<br>
clear; ans;演算実行確定 -> [MyErr]Invalid REv(ans)
<br>
ans;演算実行確定 -> 3
<br>
・続けてグローバルstorageをクリアする場合
<br>
クリア実行確定
<br>
-> storage cleared
<br>
x;演算実行確定 -> [MyErr]Invalid REv(x)
<br>
ans;演算実行確定 -> [MyErr]Invalid REv(ans)
<br>
・グローバルstorageに一切の変数を残さない場合
<br>
x=3; y=3x; y; clear;演算実行確定
<br>
x;演算実行確定 -> [MyErr]Invalid REv(x)
<br>
y;演算実行確定 -> [MyErr]Invalid REv(y)
<br>
ans;演算実行確定 -> [MyErr]Invalid REv(ans)
<br>
<br>
stop
<br>
・それ以降の演算を中断する
<br>
x=3; 3x; stop; x;演算実行確定
<br>
x=3 -> x=3
<br>
3x -> 9
<br>
stop -> operation stopped
<br>
x -> operation stopped
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
区切り文字
<br>
入力仕様
    </th>
    <td>
<span id="span-out-SR"></span>
区切り文字の入力仕様と付随する留意事項について記述する
<br>
<br>
区切り文字を優先順に列挙する
<br>
・各実行文を区切るセミコロン;
<br>
実行文; 実行文; ...
<br>
・行列の各ベクトルを区切るコロン:
<br>
ベクトル: ベクトル: ...
<br>
・ベクトルの各要素または関数の引数を区切るカンマ,
<br>
要素, 要素, ... || 引数, 引数, ...
<br>
<br>
区切り文字は2項の結合性や深さとは関係なく左から順に演算する
<br>
・区切り文字の優先順位は最優先
<br>
x=3,(x=9),2x -> (0,0,18)
<br>
x -> 9
<br>
・よって変数は実行直前ではなく列挙直前の代入値を参照する
<br>
x=3; x=2:3x -> (0:6)
<br>
<br>
区切り文字はカンマ演算子同様に働くが、行列の次元は残る
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
括弧
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT"></span>
括弧の入力仕様と付随する留意事項について記述する
<br>
<br>
実行文の一部を括る括弧は3種類使用可
<br>
<br>
優先順に列挙する
<br>
・波括弧{}
<br>
・丸括弧()
<br>
・角括弧[]
<br>
<br>
括弧は区切り文字に含める
<br>
・実行文を区切るセミコロンを括弧の中で使用した場合、error終了
<br>
(;) -> [MyErr]Invalid {([])}
<br>
・対応関係が取れない括弧の入れ子が見つかった場合、error終了
<br>
[(0]) -> [MyErr]Invalid {([])}
<br>
<br>
丸括弧()は行ベクトルをコロンで区切って列挙する
<br>
・角括弧[]は丸括弧()に準ずる
<br>
(行ベクトル: 行ベクトル: ...) || [行ベクトル: 行ベクトル: ...]
<br>
<br>
波括弧{}は列ベクトルをコロンで区切って列挙する
<br>
{列ベクトル: 列ベクトル: ...}
<br>
<br>
丸括弧()と波括弧{}は互いに転置の関係にあり使い分け可
<br>
transpose({1,2:3,4}) || trans({1,2:3,4}) || trans{1,2:3,4} -> (1,2:3,4)
<br>
<br>
演算結果のログ表示は丸括弧
<br>
{1,2:3,4} || [1,3:2,4] -> (1,3:2,4)
<br>
<br>
角括弧[]は直前の行列要素の参照位置を指定する
<br>
・よって括弧の中で最下位の優先順位
<br>
・唯一の右結合（右から左を参照）
<br>
A=(1,2:3,4); A[0][0] || (1,2:3,4)[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] || (1,2:3,4)[1][1] -> 4
<br>
・複数の要素を持つ場合のみ、行列として使用可
<br>
A=(1,2:3,4); A[1,2:3,4] -> (7,10:15,22)
<br>
[1,2][0][0] -> 1
<br>
[1,2:3,4][0] -> (1,2)
<br>
[1,2:3,4][1] -> (3,4)
<br>
[1,2:3,4][0][1,2:3,4][0] || [1,2][1,2] -> (1,2)
<br>
<br>
詳細は
<a href="#span-out-concat">行列操作入力仕様</a>
参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
予約語
<br>
入力仕様
    </th>
    <td>
<span id="span-out-RW"></span>
予約語の入力仕様と付随する留意事項について記述する
<br>
<br>
予約語の種類を列挙する
<br>
・コメント文
<br>
・命令文
<br>
・区切り文字・括弧
<br>
・定数含む関数名
<br>
・演算子記号
<br>
・被演算子記号
<br>
　・予約変数
<br>
　・10進数値小数
<br>
　・10進数値指数
<br>
　・16進数値0x
<br>
<br>
予約語の規則を列挙する
<br>
・大文字・小文字・全角・半角を区別しない
<br>
・変数名・式変数名に使用不可
<br>
stop=3 -> [MyErr]Invalid stop called
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
max&lt;=3 -> [MyErr]Invalid BTe([object Object])
<br>
ＭＡＸ=3 -> [MyErr]Invalid ans isFound
<br>
<br>
予約語の一覧は
<a href="#span-in-FN">内部仕様</a>
参照
   </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN0"></span>
定数の入力仕様と付随する留意事項について記述する
<br>
<br>
定数は引数括弧なしで厳密には関数に含めない
<br>
・実行文を作るparse段階で数値に変換する
<br>
・Excel同様に空括弧()付を許容する
<br>
・空括弧()はparse段階で除去する
<br>
<br>
関数を使用して円周率piとNapier数eを例に示す
<br>
PI() || pi || 2acos(0) || 2asin(1) || 4atan(1) -> 3.141592653589793
<br>
E() || e || e^1 || exp(1) ||  -> 2.718281828459045
<br>
<br>
eは指数と区別するために空括弧()を付ける方が間違いが少ない
<br>
2e-1 || 2E-1 -> 0.2
<br>
2e()-1 || 2E()-1 -> 4.43656365691809
<br>
・記号省略乗算を許容した弊害への対策
<br>
<br>
定数に限らず、空括弧()はparse段階ですべて除去する
<br>
()3()3() || 3*3 -> 9
<br>
()3()/()3() || 3/3 -> 1
<br>
() ->
<br>
・本来は関数の呼び出し時に空括弧を含めて判別するが、
<br>
・定数の引数括弧の有無と記号省略乗算を同時に許容した弊害への対策
<br>
<br>
次の場合、代入errorとは判別されず、右辺に移項して演算される
<br>
pi=3 || pi()=3 || =3-pi -> -0.14159265358979312
<br>
・parse後の実行文を示す
<br>
3.141592653589793=3 || =3-3.141592653589793 -> -0.14159265358979312
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
記号省略乗算
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BRmo"></span>
記号省略乗算入力仕様と付随する留意事項について記述する
<br>
<br>
2πの演算方法を円周率piを使用して次に示す
<br>
2pi || 2*pi -> 6.283185307179586
<br>
・pi2と入力した場合、変数と見なされる
<br>
pi2 -> [MyErr]Invalid REv(pi2)
<br>
・piの後に続ける場合、括弧で区切るか記号を明示する
<br>
pi(2) || pi*2 -> 6.283185307179586
<br>
<br>
角括弧は使用不可
<br>
pi[2] -> [MyErr]Invalid reference of array
<br>
[2]pi -> [MyErr]Invalid reference
<br>
x=2; x[0] -> 2
<br>
x=2; x[2] -> [MyErr]Invalid reference of array
<br>
x=2; [2]x -> [MyErr]Invalid reference
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
複素数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-com"></span>
複素数の入力仕様と付随する留意事項について記述する
<br>
<br>
複素数の虚数単位iは後置きの単項演算子とする
<br>
(+1)i || +(1)i || +1(i) || +(i) -> i
<br>
(-1)i || -(1)i || -1(i) || -(i) -> -i
<br>
3i/2 -> 1.5i
<br>
1/2i || 1/(2i) -> -0.5i
<br>
<br>
複素数を宣言する関数を示す
<br>
complex(1,-1) || comp(1,-1) -> 1-i
<br>
<br>
複素数を実部と虚部に分離する関数を示す
<br>
real(3+i) -> 3
<br>
imag(3+i) -> 1
<br>
<br>
iの2乗の演算方法を2項演算子または関数を使用して3種類示す
<br>
(i)^2 || (i)**2 || pow(i,2) -> -1+1.2246467991473532e-16i
<br>
・浮動小数点演算では、epsilonに相当するマシン誤差O(1e-16)が残る
<br>
epsilon || eps -> 2.220446049250313e-16
<br>
・この傾向は演算量に応じて実数演算よりも顕著に現れる
<br>
<br>
-1の平方根の演算方法を3種類示す
<br>
(-1)^0.5 || pow(-1,0.5) || sqrt(-1) -> 6.123233995736766e-17+i
<br>
・先頭の丸括弧()を省略した場合、次のように演算される
<br>
-1^0.5 || -(1^0.5) -> -1
<br>
・符号付の分母の丸括弧を省略した場合、error終了
<br>
1/-i || (1/)(-i) -> [MyErr]Invalid binary operation
<br>
1/(-i) -> i
<br>
<br>
Napier数eの空括弧()を省略してEulerの公式より極形式の複素数を示す
<br>
(sqrt2)e^(i{pi/4}) || sqrt2()ecomp(pi/4) -> 1.0000000000000002+i
<br>
sqrt2 || sqrt2() -> 1.4142135623730951
<br>
<br>
変数を使用
<br>
・複素数zの偏角/piを示す
<br>
z=e^(i{pi/4}); arg(z)/pi -> 0.25
<br>
・複素数zの絶対値を示す
<br>
z=e^(i{pi/4}); abs(z) -> 1
<br>
<br>
以上より、次の複素数演算をテストケースとして初期表示する
<br>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
<br>
・既定では左結合の2項演算で除算より記号省略乗算を優先する
<br>
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
<br>
<br>
2項の結合性や演算子の優先順位によって解が異なる場合、入力を見直す
<br>
<br>
具体的には次のように対策する
<br>
a={5-3}-1; b=2/{2i(a)i}; e^(-i(1pi()b/(-4)))
<br>
・一部分を変数に代入し、セミコロンで区切って演算順序を明確化する
<br>
・2項演算子が連続する場合、括弧を明示する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN"></span>
関数の入力仕様と付随する留意事項について記述する
<br>
<br>
関数の引数に行列を指定した場合、最終行ベクトルの左から順に参照する
<br>
・引数1個の関数の場合
<br>
x=(1,2,3:4,5,6); log(x) || log(4,5,6) || log(4) -> 1.3862943611198906
<br>
・引数1個か2個の関数の場合
<br>
x=(1,2,3:4,5,6); log_ex(x) || log_ex(4,5,6) || log_ex(4,5) -> 0.8613531161467861
<br>
・引数2個の関数の場合
<br>
x=(1,2,3:4,5,6); atan2(x) || atan2(4,5,6) || atan2(4,5) -> 0.6747409422235527
<br>
x=(1,2,3:4); atan2(x) || atan2(4) -> [MyErr]FN isNaN
<br>
・引数不定の関数の場合
<br>
x=(1,2,3:4,5,6); max(x) || max(4,5,6) -> 6
<br>
<br>
log関数の仕様はJavaScript準拠の自然対数とする
<br>
ln(e) || log(e) -> 1
<br>
ln(10) || ln10() -> 2.302585092994046
<br>
ln(2) || ln2() -> 0.6931471805599453
<br>
<br>
常用対数
<br>
log10(10) -> 1
<br>
<br>
Excel準拠の引数(値,底||10)は次のlog_exを使用する
<br>
log_ex(10) || log_ex(10,10) -> 1
<br>
log_ex(e) || log10e() -> 0.43429448190325176
<br>
log_ex(e,2) || log2e() -> 1.4426950408889634
<br>
<br>
atan2関数の仕様はJavaScript準拠の引数(y,x)とする
<br>
atan2(1,0)/pi -> 0.5
<br>
deg_atan2(1,0) || degrees(atan2(1,0)) -> 90
<br>
<br>
変数を使用
<br>
・実軸と虚軸の複素数平面から弧度数radに変換する場合
<br>
z=e^(i{pi/6}); atan2(imag(z),real(z)) -> 0.5235987755982987
<br>
z=e^(i{pi/6}); arg(z) -> 0.5235987755982987
<br>
・さらに度数degに変換する場合
<br>
degrees(ans) || deg_atan2(imag(z),real(z)) -> 29.999999999999993
<br>
・再度、弧度数radに変換
<br>
radians(ans) -> 0.5235987755982987
<br>
<br>
Excel準拠の引数(x,y)は次のatan2_exを使用する
<br>
atan2_ex(0,1)/pi -> 0.5
<br>
deg_atan2_ex(0,1) || degrees(atan2_ex(0,1)) -> 90
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-mat"></span>
行列の入力仕様と付随する留意事項について記述する
<br>
<br>
ベクトルの入力方法2種類
<br>
・各ベクトルの要素はカンマ,で区切る
<br>
行ベクトル(1,2) || [1,2] -> (1,2)
<br>
列ベクトル{1,3} -> (1:3)
<br>
<br>
2行2列の行列の入力方法
<br>
1　2
<br>
3　4
<br>
・各ベクトルはコロン:で区切る
<br>
(1,2:3,4) || [1,2:3,4] || {1,3:2,4} -> (1,2:3,4)
<br>
<br>
定義できない除算以外の四則演算に対応
<br>
・積
<br>
・乗算記号同様に積の記号は省略可
<br>
(1,2,3)*(1,2,3) || (1,2,3)(1,2,3) -> (1,2,3)
<br>
{1,2,3}{1,2,3} -> (1:2:3)
<br>
(1,2:3,4)(1,2:3,4) -> (7,10:15,22)
<br>
・標準内積
<br>
(1,2,3){1,2,3} -> 14
<br>
・標準外積
<br>
{1,2,3}(1,2,3) -> (1,2,3:2,4,6:3,6,9)
<br>
{1,2,3}(1,2) -> (1,2:2,4:3,6)
<br>
・Hermit内積
<br>
(1+i,1){1-i,1} -> 3
<br>
・Hermit外積
<br>
{1-i,1}(1+i,1) -> (2,1-i:1+i,1)
<br>
・空要素は零
<br>
(()) -> 0
<br>
(,) -> (0,0)
<br>
(1,2,3:){1,2,3:} || (1,2,3:,,){1,2,3:,,} -> (14,0:0,0)
<br>
・標準外積の拡張（Scalar倍ではない）
<br>
(1,2:3,4)2 || (1,2:3,4){2,} -> (2:6)
<br>
2(1,2:3,4) || (2,)(1,2:3,4) -> (2,4)
<br>
{2,}(1,2:3,4) || {2,:,}(1,2:3,4) -> (2,4:0,0)
<br>
・単位行列
<br>
k=1; (k,:,k) -> (1,0:0,1)
<br>
・Scalar行列
<br>
k=-3; (k,:,k) -> (-3,0:0,-3)
<br>
・Scalar倍（同サイズのScalar行列との積）
<br>
k=-3; (k,:,k)(1,2:3,4) || (1,2:3,4)(k,:,k) -> (-3,-6:-9,-12)
<br>
k=-3; k(1,2:3,4)  // NG -> (-3,-6)
<br>
・符号
<br>
-(1,2:3,4) || (,:,)-(1,2:3,4) || (-1,:,-1)(1,2:3,4) -> (-1,-2:-3,-4)
<br>
・差
<br>
(1,2:3,4)-(1,2:3,4) -> (0,0:0,0)
<br>
・和
<br>
(1,2:3,4)+(1,2:3,4) -> (2,4:6,8)
<br>
・変数を使用
<br>
x=1; y=(x,2x:3x,4x); y*y-y || (7,10:15,22)-(1,2:3,4) -> (6,8:12,18)
<br>
t=pi/4; (cos(t),sin(t):,){i(sin(t)),i(cos(t)):,} -> (i,0:0,0)
<br>
<br>
列指定の不規則行列
<br>
・抜け要素は零
<br>
{1:2:3,4} -> (1,2,3:0,0,4)
<br>
{1:2,3} -> (1,2:0,3)
<br>
{1:2,,3} -> (1,2:0,0:0,3)
<br>
{1,2:3,,,4} -> (1,3:2,0:0,0:0,4)
<br>
{1,,,2:3,4:5,,,,,6} -> (1,3,5:0,4,0:0,0,0:2,0,0:0,0,0:0,0,6)
<br>
<br>
行指定の不規則行列
<br>
A=(11:21,22:31,32,33,34); A -> (11:21,22:31,32,33,34)
<br>
tA={11:21,22:31,32,33,34}; tA -> (11,21,31:0,22,32:0,0,33:0,0,34)
<br>
・行指定の行列で抜け要素がある場合、転置の関数を使用
<br>
A=(11:21,22:31,32,33,34); trans(trans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
A=(11:21,22:31,32,33,34); htrans(htrans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
・結合処理が重くなるため、行指定の行列は抜け要素を自動で埋めない
<br>
<br>
差と和のみ行列サイズ不一致で入力ミスによるerror終了
<br>
(1,2:3,4)+(-1) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)-(-1,2) -> [MyErr]Invalid matrix operation
<br>
<br>
無次元の場合、行列の演算規則とは関係なく最終要素を演算する
<br>
(1,2:3)1 || (3)*1 -> 3
<br>
(1,2)/(3,4) || (2)/(4) -> 0.5
<br>
(1,2,3)+(4,5) || (3)+(5) -> 8
<br>
(1,2:3)-(4,5:6:7) || (3)-(7) -> -4
<br>
<br>
行列に対して定義できない2項演算を実行した場合も同様とする
<br>
(5,3,1)/(3i,i) || (1)/(i) -> -i
<br>
(1,2,3)^(1.5,0.5) || (3)^(0.5) -> 1.7320508075688772
<br>
(3,5,7)%(1,5) || (7)%(5) -> 2
<br>
(2,4,8)&gt;&gt;(3,1) || (8)&gt;&gt;(1) -> 4
<br>
<br>
行列に対して後置きの単項演算を実行した場合も無次元確定とする
<br>
(5,3)i || (3)i -> 3i
<br>
(10,5:,)! || (0)! -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数扱いの
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm0"></span>
定数扱いの行列の入力仕様と付随する留意事項について記述する
<br>
<br>
定数同様に扱う行列を列挙する
<br>
vector2r || vector2r() -> (0,0)
<br>
vector3r -> (0,0,0)
<br>
vector4r -> (0,0,0,0)
<br>
vector2c -> (0:0)
<br>
vector3c -> (0:0:0)
<br>
vector4c -> (0:0:0:0)
<br>
zeros2 -> (0,0:0,0)
<br>
zeros3 -> (0,0,0:0,0,0:0,0,0)
<br>
zeros4 -> (0,0,0,0:0,0,0,0:0,0,0,0:0,0,0,0)
<br>
ones2 -> (1,1:1,1)
<br>
ones3 -> (1,1,1:1,1,1:1,1,1)
<br>
ones4 -> (1,1,1,1:1,1,1,1:1,1,1,1:1,1,1,1)
<br>
identity2 || id2 -> (1,0:0,1)
<br>
identity3 || id3 -> (1,0,0:0,1,0:0,0,1)
<br>
identity4 || id4 -> (1,0,0,0:0,1,0,0:0,0,1,0:0,0,0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm"></span>
行列関数の入力仕様と付随する留意事項について記述する
<br>
<br>
行列の転置
<br>
trans(1,2:3,4) -> (1,3:2,4)
<br>
・行ベクトルを列ベクトルに変換
<br>
transpose(1,2,3) || trans(1,2,3) -> (1:2:3)
<br>
・列ベクトルを行ベクトルに変換
<br>
trans({1,2,3}) || trans{1,2,3} -> (1,2,3)
<br>
<br>
複素数の行列のHermit転置
<br>
htrans(1-i,1-2i:1-3i,1-4i) || hermitian(1-i,1-2i:1-3i,1-4i) -> (1+i,1+3i:1+2i,1+4i)
<br>
<br>
列ベクトルのEuclidノルムを演算
<br>
norm{1,2,3} -> 3.7416573867739413
<br>
norm{-i,2i,-3i} -> 3.7416573867739413
<br>
norm{(1-i)/sqrt2,2i,-3i} -> 3.7416573867739413
<br>
・有次元の場合、同義
<br>
x={(1-i)/sqrt2,2i,-3i}; sqrt(htrans(x)x) -> 3.7416573867739413
<br>
・Hermit内積
<br>
x={(1-i)/sqrt2,2i,-3i}; htrans(x)x -> 14
<br>
・標準内積
<br>
x={(1-i)/sqrt2,2i,-3i}; trans(x)x -> -13-0.9999999999999998i
<br>
・よって複素数の場合、非同義
<br>
x={(1-i)/sqrt2,2i,-3i}; abs(sqrt(trans(x)x))  // NG -> 3.6108731368472777
<br>
・行ベクトルを誤入力した場合
<br>
norm((1-i)/sqrt2,2i,-3i) || norm(-3i)  // NG -> 3
<br>
<br>
ベクトルの正規化
<br>
・行ベクトルを正規化する場合
<br>
vr=(1,i,-i); vr -> (1,i,-i)
<br>
normalizer(vr) ->
<br>
(0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・列ベクトルを正規化する場合
<br>
vc={1,i,-i}; vc -> (1:i:-i)
<br>
normalize(vc) || normalizec(vc) -> 
<br>
(0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
vr=(1,i,-i); normalizec(vr)  // NG -> (1,i,-i)
<br>
<br>
行列の正規化
<br>
・すべての行ベクトルを正規化する場合
<br>
A=(1:1,i:1,i,-i); A -> (1:1,i:1,i,-i)
<br>
normalizer(A) ->
<br>
(1,0,0:
<br>
0.7071067811865475,0.7071067811865475i,0:
<br>
0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・各行ベクトルを行列操作で正規化する場合
<br>
(1/norm(trans(A[0])))A[0] -> 1
<br>
(1/norm(trans(A[1])))A[1]
<br>
-> (0.7071067811865475,0.7071067811865475i)
<br>
(1/norm(trans(A[2])))A[2]
<br>
-> (0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・すべての列ベクトルを正規化する場合
<br>
tA={1:1,i:1,i,-i}; tA -> (1,1,1:0,i,i:0,0,-i)
<br>
normalizec(tA) ->
<br>
(1,0.7071067811865475,0.5773502691896258:
<br>
0,0.7071067811865475i,0.5773502691896258i:
<br>
0,0,-0.5773502691896258i)
<br>
・各列ベクトルを行列操作で正規化する場合
<br>
tA={1:1,i:1,i,-i}; A=trans(tA); A -> (1,0,0:1,i,0:1,i,-i)
<br>
trans((1/norm(trans(A[0])))A[0]) -> (1:0:0)
<br>
trans((1/norm(trans(A[1])))A[1])
<br>
-> (0.7071067811865475:0.7071067811865475i:0)
<br>
trans((1/norm(trans(A[2])))A[2])
<br>
-> (0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
<br>
行列要素を取得
<br>
・最初要素
<br>
first(1,2:3,4) -> 1
<br>
first{1,2:3,4} -> 1
<br>
・最終要素
<br>
last(1,2:3,4) -> 4
<br>
last{1,2:3,4} -> 4
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列操作
<br>
入力仕様
    </th>
    <td>
<span id="span-out-concat"></span>
行列操作の入力仕様と付随する留意事項について記述する
<br>
<br>
任意要素を取得
<br>
A=(1,2:3,4); A[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] -> 4
<br>
A=(1:1,i:1,i,-i); A[0][1] -> [MyErr]Invalid reference of array
<br>
・式変数を使用
<br>
clear; n=2; xn&lt;=(n,2n); xn[0][1] || (xn=&gt;)[0][1] -> 4
<br>
clear; n=2; xn&lt;=(n,2n); xn=&gt;[0][1] -> [MyErr]Invalid REe(=&gt;)
<br>
clear; n=2; xn&lt;=(n,2n)[0][1]; xn=&gt; -> 4
<br>
<br>
任意要素を演算
<br>
(1,2:3,4)[0][0]3 || 1*3 -> 3
<br>
(1)[0][0]3=(x=3) || 1*3=0 -> -3
<br>
<br>
行ベクトルを取得
<br>
A=(1,2:3,4); A[1] -> (3,4)
<br>
<br>
列ベクトルを取得
<br>
・転置の関数を使用
<br>
A=(1,2:3,4); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2:4)
<br>
A=(i,2i:3i,4i); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2i:4i)
<br>
trans((trans(1,2:3,4))[1]) || htrans((htrans(1,2:3,4))[1]) -> (2:4)
<br>
trans((trans(i,2i:3i,4i))[1]) || htrans((htrans(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
・括弧は関数より優先するため、関数の外側を上位の括弧で括る
<br>
A=(1,2:3,4); trans(A)[1] || trans((A)[1])  // NG -> (3:4)
<br>
trans(1,2:3,4)[1] || trans((1,2:3,4)[1])  // NG -> (3:4)
<br>
A=(1,2:3,4); (trans(A))[1]  // OK -> (2,4)
<br>
(trans(1,2:3,4))[1]  // OK -> (2,4)
<br>
<br>
定義済みの行列要素のみ代入可
<br>
・要素指定の代入
<br>
A=(1,2:3,4); A[0][0]=-1; A -> (-1,2:3,4)
<br>
A=(1,2:3,4); ii=1; A[ii][ii]=-1; A -> (1,2:3,-1)
<br>
A=(1,2:3,4); A[1][1]=(x=2); A -> (1,2:3,0)
<br>
・行列を代入した場合、最終要素を代入
<br>
A=(1,2:3,4); A[0][0]=A; A -> (4,2:3,4)
<br>
A=(1,2:3,4); A[1][1]=(x=2,-2x); A -> (1,2:3,-4)
<br>
・行指定の代入
<br>
A=(1,2:3,4); A[1]=A[0]; A -> (1,2:1,2)
<br>
A=(1,2:3,4); A[1]=-A[1]; A -> (1,2:-3,-4)
<br>
A=(1,2:3,4); A[1]=-2A[1]; A -> (1,2:-6,-8)
<br>
A=(1,2:3,4); A[1]=(,); A -> (1,2:0,0)
<br>
A=(1,2:3,4); w=A[1]; A[1]=A[0]; A[0]=w; A -> (3,4:1,2)
<br>
・行列を代入した場合、最終行ベクトルを代入
<br>
A=(1,2:3,4); A[0]=A; A -> (3,4:3,4)
<br>
A=(1,2:3,4); A[0]=(A:A(2,:,2)); A -> (6,8:3,4)
<br>
・列指定で代入する場合、転置の関数を使用
<br>
A=(1,2:3,4); tA=trans(A); tA[0]=-tA[0]; A=trans(tA); A -> (-1,2:-3,4)
<br>
・列サイズの異なる代入不可
<br>
A=(1,2:3,4); A[1]=0 || A[1]=(1) || A[1]=(,,) || A[1]={,} -> [MyErr]Invalid store array
<br>
・未定義の行列要素への代入不可
<br>
A=(1,2:3,4); A[2]=A[1] -> [MyErr]Invalid reference of array
<br>
A=(1,2:3,4); A[1]=-1 || A[2][0]=5 -> [MyErr]Invalid substitution
<br>
A=(1,2:3,4); A[0.5][0]=-1 -> [MyErr]Invalid reference of array
<br>
・式変数への要素指定・行指定の代入不可
<br>
clear; A&lt;=(1,2:3,4); A[1][1]=0 -> [MyErr]Undef var(A)
<br>
clear; A&lt;=(1,2:3,4); A[1]=(,) -> [MyErr]Undef var(A)
<br>
clear; A&lt;=(1,2:3,4); (A=&gt;)[1][1]=0 || =0-4 -> -4
<br>
clear; A&lt;=(1,2:3,4); (A=&gt;)[1]=(,) || =(,)-(A=&gt;)[1] -> (-3,-4)
<br>
<br>
ベクトルの結合
<br>
((1,2),(3,4)) -> (1,2,3,4)
<br>
x=(1,2); y=(3,4); (x,y) -> (1,2,3,4)
<br>
A=(1,2:3,4); (A[0],A[1]) -> (1,2,3,4)
<br>
・区切り文字の左から順に結合する
<br>
((1,2),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4,},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
(1,2),{3,4:5:6,7:8} -> (1,2,3,5,6,8:0,0,4,0,7)
<br>
(1,2),{3,4:5:6,7:8,9,10} -> (1,2,3,5,6,8:0,0,4,0,7,9:0,0,0,0,0,10)
<br>
(1,2),{3,4:5:6,7:8,(9,10)} -> (1,2,3,5,6,8:0,0,4,0,7,9,10)
<br>
<br>
行列の結合
<br>
((1,2:5,6),(3,4:7,8):{-1,-5:-2,-6},{-3,-7:-4,-8})
<br>
-> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
<br>
・変数を使用
<br>
mat00=(1,2:5,6);
<br>
mat01=(3,4:7,8);
<br>
mat10={-1,-5:-2,-6};
<br>
mat11={-3,-7:-4,-8};
<br>
mat=(mat00,mat01:mat10,mat11);
<br>
mat -> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmspecial"></span>
特殊行列関数の入力仕様と付随する留意事項について記述する
<hr>
<br>
回転行列
<br>
・3次元Euclid実空間の各軸周りの回転行列を演算して返す
<br>
・引数はEuler角の弧度数実数値rad
<br>
・返値の回転行列は引数の誤差情報を継承しない
<br>
<br>
使用例を列挙する
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,-1:
<br>
0,1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(-pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,1:
<br>
0,-1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(pi/4) ->
<br>
(1.0000000000000002,0,1:
<br>
0,1.4142135623730951,0:
<br>
-1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(-pi/4) ->
<br>
(1.0000000000000002,0,-1:
<br>
0,1.4142135623730951,0:
<br>
1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(pi/4) ->
<br>
(1.0000000000000002,-1,0:
<br>
1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(-pi/4) ->
<br>
(1.0000000000000002,1,0:
<br>
-1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
t=_dx(&lt;={x},1,1)pi/4+1000i; t
<br>
-> infoLost!! 0.7853981633974194+1000i+O(8e-13+8e-13i)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(t) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000289,-0.9999999999999711:
<br>
0,0.9999999999999711,1.0000000000000289)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-vars"></span>
変数の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への代入・再代入方法は、変数名=代入値とする
<br>
x=2; x -> 2
<br>
x=2; x=4; x -> 4
<br>
x=2; x=2x; x -> 4
<br>
<br>
変数の命名規則を列挙する
<br>
・大文字と小文字を区別する
<br>
x=1; X=2; x+X -> 3
<br>
・変数名の後に続く数字は変数名に含まれる
<br>
x0=1; x1=2; x0+x1 -> 3
<br>
・バイナリ文字の全角は半角に変換される
<br>
Ｘ＝３；X -> 3
<br>
・マルチバイト文字を使用可
<br>
番号=1; 番号 -> 1
<br>
・予約語は使用不可
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
・数字から開始不可
<br>
clear; 2x=4 -> [MyErr]Invalid ans isFound
<br>
<br>
予約変数を示す
<br>
・ansは直前の実行文の演算結果を保持する
<br>
2; ans*2; ans*2; ans -> 8
<br>
2; (ans*2,ans*3); ans -> (4,6)
<br>
・代入ではansは更新されない
<br>
2; x=3; ans -> 2
<br>
・error終了時はansは更新されない
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数への
<br>
代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution"></span>
変数への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への代入規則を列挙する
<br>
・代入する変数の左側に数値や演算子を置けない
<br>
clear; 2x=3 -> [MyErr]Invalid ans isFound
<br>
clear; 3+x=4 -> [MyErr]Invalid binary operation
<br>
・未定義変数の代入不可
<br>
clear; x=y(z) -> [MyErr]Invalid ans isFound
<br>
・このような場合、式変数を使用する
<br>
<br>
代入を括弧で括った場合、零を返す
<br>
(x=3) -> 0
<br>
<br>
代入をカンマかコロンで区切った場合、零を返す
<br>
clear; x=2,3x -> (0,6)
<br>
clear; x=2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-eqns"></span>
式変数の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数へ代入・再代入方法は、式変数名&lt;=方程式または関数式とする
<br>
・式変数への代入を以降、式代入と呼ぶ
<br>
y&lt;={a*x+b=0}; -> stored_eqn(y)
<br>
y&lt;=a*x+b=0; -> stored_eqn(y)
<br>
y&lt;={a*x+b}; -> stored_eqn(y)
<br>
y&lt;=a*x+b; -> stored_eqn(y)
<br>
<br>
式変数から値を読出す方法は、式変数名=&gt;とする
<br>
式変数から変数に値代入する方法は、式変数名=&gt;変数名とする
<br>
・式変数からの値読出しを以降、式読出しと呼ぶ
<br>
y&lt;=a*x+b; y=&gt; -> [MyErr]Invalid binary operation
<br>
y&lt;=a*x+b; y=&gt;y0 -> [MyErr]Invalid binary operation
<br>
<br>
関数式の変数を定義して再度読出す
<br>
y&lt;=a*x+b; a=1; b=2; x=3; y=&gt; || 1*3+2 -> 5
<br>
y&lt;=a*x+b; a=1; b=2; x=3; y=&gt;y0; y0 -> 5
<br>
・式読出しを括弧で括れば変数同様に扱える
<br>
2; y&lt;=ans; max(3,4(y=&gt;)2) || max(3,4*2*2) -> 16
<br>
2; y&lt;=ans; max(3,4(y=&gt;y0)2); y=&gt; -> 16
<br>
<br>
式変数と同名の変数が未定義の場合、直接、式読出し可
<br>
clear; y&lt;=a*x+b; a=1; b=2; x=3; 2y -> 10
<br>
clear; y&lt;=a*x+b; a=1; b=2; x=3; y0=2y; y0 -> 10
<br>
・ただし、式読出し記号を明示する方が間違いが少ない
<br>
y=-1; y&lt;=a*x+b; a=1; b=2; x=3; 2y -> -2
<br>
y=-1; y&lt;=a*x+b; a=1; b=2; x=3; 2(y=&gt;) -> 10
<br>
・さらに、式変数名と変数名は区別する方が間違いが少ない
<br>
y=3; y&lt;=3y-1; 2y -> 6
<br>
y=3; y&lt;=3y-1; y=&gt;y; 2y -> 16
<br>
y0=3; y&lt;=3y0-1; y=&gt;y1; 2y1 -> 16
<br>
<br>
式変数名で明示して直接読出す方法もあり得る
<br>
clear; eqn_x&lt;=(a*x+b=0); a=1; b=2; x=3; 2eqn_x || 2*(-5) -> -10
<br>
<br>
以降、変数名と式変数名は被らない前提で式読出し記号を省略する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数への
<br>
代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-equation"></span>
式変数への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数と同名の変数が未定義で循環参照した場合、error終了
<br>
clear; y&lt;=3y-1; y -> [MyErr]Invalid circular(y)
<br>
<br>
式変数名&lt;=関数名として関数名を任意に変更可（参照渡しを模擬）
<br>
clear; tr&lt;=trans; tr(1,2:3,4) || (tr=&gt;)(1,2:3,4) -> (1,3:2,4)
<br>
clear; htr&lt;=htrans; htr((htr(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
clear; tr&lt;=trans; tr[2] -> [MyErr]Invalid FNm(transpose)
<br>
clear; trans&lt;=trans -> [MyErr]Invalid FNm(transpose)
<br>
・高階関数の場合
<br>
clear; d&lt;=_d -> [MyErr]Invalid FNh called
<br>
clear; dx&lt;=_dx; dx(&lt;={x^2},1,2)
<br>
-> 3.999999999999929+3.5537737875913754e-14i+O(2e-11+1e-12i)
<br>
<br>
式代入を括弧で括った場合、零を返す
<br>
(x&lt;=3) -> 0
<br>
<br>
式代入をカンマかコロンで区切った場合、零を返す
<br>
clear; x&lt;=2,3x -> (0,6)
<br>
clear; x&lt;=2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
<br>
<br>
式変数を式代入可
<br>
・式変数の式代入を以降、通常の値渡しに対して式渡しと呼ぶ
<br>
・式読出し記号を明示する場合
<br>
clear; eqn_x&lt;=3x; eqn_y&lt;=(eqn_x=&gt;); x=3; eqn_y=&gt; ->9
<br>
・同名の変数未定義の前提で式読出し記号を省略する場合
<br>
clear; eqn_x&lt;=3x; eqn_y&lt;=eqn_x; x=3; eqn_y ->9
<br>
<br>
式渡しの仕様を列挙する
<br>
・式渡しの直接読出し
<br>
(&lt;=3)=&gt; -> 3
<br>
(&lt;={3})=&gt; -> 3
<br>
({3})=&gt; -> [MyErr]Invalid mat([object Object])
<br>
(1,2,&lt;=3)=&gt; -> 3
<br>
(1,2,3)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
・一続きにまとめて変数値を読出す場合、最終引数を式渡し
<br>
・last行列関数は最終要素しか取り出せない
<br>
clear; (x=(1,2),&lt;=x)=&gt; -> (1,2)
<br>
clear; last(x=(1,2),x) -> 2
<br>
・式変数の場合も同様
<br>
clear; f&lt;={x}; x=(1,2); f=&gt; -> (1,2)
<br>
clear; (f&lt;={x},x=(1,2),&lt;=f)=&gt; -> (1,2)
<br>
clear; (f&lt;={x},x=(1,2),f) -> (0,0,1,2)
<br>
clear; (f&lt;={x},x=(1,2),f)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; last(f&lt;={x},x=(1,2),f) -> 2
<br>
clear; last(f&lt;={x},x=(1,2),&lt;=f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f&lt;={x},x=(1,2),&lt;=f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f&lt;={x},x=(1,2),eqn_f&lt;=f); eqn_f -> (1,2)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh"></span>
高階関数の入力仕様と付随する留意事項について記述する
<hr>
<br>
総和高階関数
<br>
・任意関数の範囲[a,b]の総和を演算して返す
<br>
・アンダーバーs変数名で呼び出す
<br>
・変数は無次元でローカル変数から独立する
<br>
<br>
_s変数名(&lt;=第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: 変数の関数式を式渡し
<br>
・第2引数: 変数の範囲下限a（整数）を値渡し
<br>
・第3引数: 変数の範囲上限b（整数）を値渡し
<br>
オプション
<br>
・第4引数: 変数のステップ（正の整数）を値渡し[省略時、1]
<br>
<br>
使用例を列挙する
<br>
・n=0~10のnの総和
<br>
_sn(&lt;={n},0,10) || _Sn(&lt;={n},0,10) || (10+1)10/2 -> 55
<br>
・定積分同様に定義
<br>
_Sn(&lt;={n},10,0) -> -55
<br>
_Sn(&lt;={n},0,-10) -> 55
<br>
・ステップ2の場合
<br>
_sn(&lt;={n},0,10,2) || 0+2+4+6+8+10 -> 30
<br>
_Sn(&lt;={n},10,0,2) -> -30
<br>
・ステップが負の場合、暗黙で絶対値に変換
<br>
_sn(&lt;={n},0,10,-2) -> 30
<br>
_Sn(&lt;={n},10,0,-2) -> -30
<br>
・n=0~10の行列の総和
<br>
_sn(&lt;={(n,2n:3n,4n)},N=2,5N) -> (55,110:165,220)
<br>
_Sn(&lt;={(n,2n:3n,4n)},10,0) -> (-55,-110:-165,-220)
<br>
・2変数の多重総和
<br>
_sy(&lt;={_sx(&lt;={x+y},0,y)},0,2) || 0+1+2+2+3+4 -> 12
<br>
_Sy(&lt;={_Sx(&lt;={x+y},y,0)},2,0) || 4+3+2+2+1+0 -> 12
<br>
_sy(&lt;={_Sx(&lt;={x+y},y,0)},0,2) || 0-2-1-4-3-2 -> -12
<br>
_Sy(&lt;={_sx(&lt;={x+y},0,y)},2,0) || 0-2-3-4-1-2 -> -12
<br>
・総和を取る変数はローカル変数から独立
<br>
x=-1; y=-2; _sy(&lt;={_sx(&lt;={x+y},0,y)},0,2); x+y -> -3
<br>
・高階関数の引数も関数同様に最終行ベクトルの左から順に参照
<br>
_sn(,ns=0,:,ne=10,:&lt;={n},ns,ne) -> 55
<br>
・変数の命名規則に準拠
<br>
_smax(&lt;={0},1,2) -> [MyErr]Invalid max called
<br>
_spi(&lt;={0},1,2) -> [MyErr]Invalid pi called
<br>
_s3(&lt;={0},1,2) -> [MyErr]Invalid 3 called
<br>
_s3n(&lt;={0},1,2) -> [MyErr]Invalid FNh called
<br>
<br>
応用例を示す
<br>
・1回試行で当たりの確率をPb[%]とする
<br>
・10回試行中、n回当たりの確率Pn[%]を式変数で定義する
<br>
storage cleared
<br>
Pb=3; Pn&lt;={100combin(10,n)(Pb/100)^n((100-Pb)/100)^(10-n)};
<br>
n=0; Pn -> 73.74241268949281
<br>
n=1; Pn -> 22.806931759636946
<br>
n=2; Pn -> 3.1741606057226677
<br>
n=3; Pn -> 0.2617864417090862
<br>
n=4; Pn -> 0.014168853803842281
<br>
n=5; Pn -> 0.0005258543679776511
<br>
n=6; Pn -> 0.000013552947628290013
<br>
n=7; Pn -> 2.3952190212e-7
<br>
n=8; Pn -> 2.7779602049999973e-9
<br>
n=9; Pn -> 1.909250999999996e-11
<br>
n=10; Pn -> 5.904899999999982e-14
<br>
・10回試行中、N回以上当たりの確率[%]
<br>
N=10; _sn(&lt;=Pn,N,10) || 100(Pb/100)^N -> 5.904899999999982e-14
<br>
N=9; _sn(&lt;=Pn,N,10) -> 1.9151558999999963e-11
<br>
N=8; _sn(&lt;=Pn,N,10) -> 2.7971117639999973e-9
<br>
N=7; _sn(&lt;=Pn,N,10) -> 2.42319013884e-7
<br>
N=6; _sn(&lt;=Pn,N,10) -> 0.000013795266642174013
<br>
N=5; _sn(&lt;=Pn,N,10) -> 0.0005396496346198251
<br>
N=4; _sn(&lt;=Pn,N,10) -> 0.014708503438462106
<br>
N=3; _sn(&lt;=Pn,N,10) -> 0.27649494514754835
<br>
N=2; _sn(&lt;=Pn,N,10) -> 3.4506555508702164
<br>
N=1; _sn(&lt;=Pn,N,10) -> 26.257587310507166
<br>
N=0; _sn(&lt;=Pn,N,10) -> 99.99999999999999
<hr>
<br>
総乗・総積高階関数
<br>
・任意関数の整数範囲[a,b]の総乗・総積を演算して返す
<br>
・アンダーバーp変数名で呼び出す
<br>
・変数は無次元でローカル変数から独立する
<br>
<br>
_p変数名(&lt;=第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: 変数の関数式を式渡し
<br>
・第2引数: 変数の範囲下限a（整数）を値渡し
<br>
・第3引数: 変数の範囲上限b（整数）を値渡し
<br>
オプション
<br>
・第4引数: 変数のステップ（正の整数）を値渡し[省略時、1]
<br>
<br>
使用例を列挙する
<br>
・n=1~10のnの総乗
<br>
_pn(&lt;={n},1,10) || 10! -> 3628800
<br>
_Pn(&lt;={n},10,1) -> 3628800
<br>
・ステップ2の場合
<br>
_pn(&lt;={n},1,10,2) || 9!! -> 945
<br>
_Pn(&lt;={n},10,1,2) || 10!! -> 3840
<br>
・n=1~2の行列の総積
<br>
An&lt;=(n,2n:3n,4n); _pn(&lt;={An},1,2) || (1,2:3,4)(2,4:6,8) -> (14,20:30,44)
<br>
An&lt;=(n,2n:3n,4n); _Pn(&lt;={An},2,1) || (2,4:6,8)(1,2:3,4) -> (14,20:30,44)
<br>
・2変数の多重総積
<br>
_py(&lt;={_px(&lt;={(x:y)},1,y)},1,3) || (1:1)(1:2)(2:2)(1:3)(2:3)(3:3) -> (12:12)
<br>
_Py(&lt;={_Px(&lt;={(x:y)},y,1)},3,1) || (3:3)(2:3)(1:3)(2:2)(1:2)(1:1) -> (12:12)
<br>
・行列の場合、結合性に依存
<br>
_py(&lt;={_Px(&lt;={(x:y)},y,1)},1,3) || (1:1)(2:2)(1:2)(3:3)(2:3)(1:3) -> (12:12)
<br>
_Py(&lt;={_px(&lt;={(x:y)},1,y)},3,1) || (1:3)(2:3)(3:3)(1:2)(2:2)(1:1) -> (12:36)
<br>
・任意行列Aの累乗
<br>
A=(1,2:3,4); N=2; _pn(&lt;={A},1,N) -> (7,10:15,22)
<br>
A=(1,2:3,4); N=5; _pn(&lt;={A},1,N) -> (1069,1558:2337,3406)
<br>
A=(1,2:3,4); N=5; _pn(&lt;={trans(A)},1,N) -> (1069,2337:1558,3406)
<br>
・複素数の任意行列cAの累乗
<br>
cA=(e^{i(pi/4)},:,e^{i(-pi/4)}); N=4; _pn(&lt;={cA},1,N)
<br>
-> (-1+2.7755575615628914e-16i,0:0,-1-2.7755575615628914e-16i)
<hr>
<br>
再帰高階関数
<br>
・任意処理の演算結果を変数に代入する操作を再帰回数繰り返す
<br>
・最後の演算結果を返す
<br>
・アンダーバーr変数名で呼び出す
<br>
・変数は無次元でローカル変数から独立する
<br>
<br>
_r変数名(&lt;=第1引数,第2引数,第3引数)
<br>
・第1引数: 任意処理を式渡し
<br>
・第2引数: 変数の初期値を値渡し
<br>
・第3引数: 再帰回数（正の整数）を値渡し
<br>
<br>
使用例を列挙する
<br>
・再帰回数が零以下の場合、初期値を返す
<br>
・加算の漸化式
<br>
_rn(&lt;={n+1},,0) -> 0
<br>
_rn(&lt;={n+1},,1) -> 1
<br>
_rn(&lt;={n+1},,2) -> 2
<br>
・同義
<br>
Pn=0; _rn(&lt;={Pn=Pn+1},0,2); Pn -> 2
<br>
_rn(&lt;={Pn=Pn+1},Pn=0,2); Pn -> 2
<br>
・初期値未定義の場合、error終了
<br>
clear; _rn(&lt;={Pn=Pn+1},,2); Pn -> [MyErr]Invalid binary operation
<br>
・非同義（変数への代入は零が返る）
<br>
clear; _rn(&lt;={n=n+1},,2)  // NG -> 0
<br>
clear; _rn(&lt;={n=n+1},,2); n -> [MyErr]Invalid REv(n)
<br>
clear; _rn(&lt;={n=n+1},n=0,2); n -> 0
<br>
・乗算の漸化式
<br>
_rn(&lt;={n*2},1,0) -> 1
<br>
_rn(&lt;={n*2},1,1) || 2^1 -> 2
<br>
_rn(&lt;={n*2},1,2) || 2^2 -> 4
<br>
_rn(&lt;={n*2},1,3) || 2^3 -> 8
<br>
・同義
<br>
Pn=1; _rn(&lt;={Pn=Pn*2},0,3); Pn -> 8
<br>
_rn(&lt;={Pn=Pn*2},Pn=1,3); Pn -> 8
<br>
・任意行列Aの累乗
<br>
An=(1,:,1); A=(1,2:3,4); N=2; _rn(&lt;={An=An*A},,N); An -> (7,10:15,22)
<br>
_rn(&lt;={An=An*(1,2:3,4)},An=(1,:,1),5); An -> (1069,1558:2337,3406)
<br>
・2変数の多重再帰
<br>
_ry(&lt;={_rx(&lt;={x+y},1,2)},1,2) || (1+(2+1))+3 -> 7
<br>
_Ry(&lt;={_Rx(&lt;={x+y+1},1,2)},1,2) -> 13
<hr>
<br>
微分高階関数
<br>
・連続関数の微分位置における微分係数を数値的に演算して返す
<br>
・精度優先で微分位置に応じた情報落ちを対策する
<br>
・数値誤差O(dx^4以上)を含み、演算結果に目安の解析誤差を表示する
<br>
・1階微分の差分間隔実数値dxDの既定値dxD=1e-3
<br>
・微分位置xでの差分間隔dxの既定値dx=max(1,abs(x))dxD(1+i)
<br>
・アンダーバーd変数名で呼び出す
<br>
・変数は無次元でローカル変数を参照するが、上書きしない
<br>
<br>
_d変数名(&lt;=第1引数[,第2引数[,第3引数[,第4引数]]])
<br>
・第1引数: 変数の関数式を式渡し
<br>
オプション
<br>
・第2引数: 微分階数（正の整数）を値渡し[省略時、1]
<br>
・第3引数: 微分位置を値渡し[省略時、ローカル変数を参照]
<br>
・第4引数: 1階微分の差分間隔dxを値渡し[省略時、dx既定値]
<br>
<br>
数値誤差に関する精度次数について記述する
<br>
・数値誤差は絶対誤差
<br>
・微分階数が1階上がる毎に差分間隔2倍を仮定
<br>
・微分階数が2階までは中心差分法による4次精度以下
<br>
・微分階数が3階以降は中心差分法による2次精度以下
<br>
<br>
詳細は<a href="#span-out-fdm">有限差分法</a>参照
<br>
<br>
使用例を示す
<br>
・f(x)=(x+i)^5のx=1における微分を示す
<br>
x=1; dxD=1e-3; dx=max(1,abs(x))dxD(1+i); f&lt;={(x+i)^5} -> stored_eqn(f)
<br>
・0階微分
<br>
_dx(&lt;=f,) || _dx(&lt;=f,0)
<br>
-> -4.000000000000002-4.000000000000001i
<br>
f -> -4.000000000000002-4.000000000000001i
<br>
・1階微分は4次精度
<br>
_dx(&lt;=f,1)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
_dx(&lt;=f)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
・2階微分は4次精度以下
<br>
・差分間隔が異なる多重化とは完全には一致しない
<br>
_dx(&lt;=f,2)
<br>
-> -39.99999999980588+39.99999999944028i+O(2e-11+2e-11i)
<br>
_dx(&lt;={_dx(&lt;=f)})
<br>
-> -40.00000000012216+40.00000000037086i+O(8e-12+8e-12i)
<br>
・2階微分を4次精度1階微分で厳密に多重化する場合4次精度以下
<br>
_dx(&lt;={_dx(&lt;=f,1,x,dx)},1,x,2dx)
<br>
-> -39.99999999980588+39.99999999944028i+O(2e-11+2e-11i)
<br>
・3階微分以降は2次精度
<br>
・多重化は1階上がる毎に精度悪化
<br>
_dx(&lt;=f,3)
<br>
-> 2.6203811256259035e-11+120.00084001140233i+O(2e-5+2e-5i)
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;=f)})})
<br>
-> 4.378068605950494e-8+120.00000084539053i+O(6e-11+6e-11i)
<br>
・3階微分を4次精度1階微分で厳密に多重化する場合3次精度以下
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;=f,1,x,1dx)},1,x,2dx)},1,x,4dx)
<br>
-> -3.5859384520417787e-10+120.00000000321582i+O(3e-10+3e-10i)
<br>
・4階微分
<br>
_dx(&lt;=f,4)
<br>
-> 120.00000006268098+120.0000001718161i+O(6e-5+6e-5i)
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f)})})})
<br>
-> 120.00001615650766+120.00019838028798i+O(5e-10+5e-10i)
<br>
・4階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f,1,x,1dx)},1,x,2dx)},1,x,4dx)},1,x,8dx)
<br>
-> 119.99999887453464+120.00000028081901i+O(4e-9+4e-9i)
<br>
・5階微分
<br>
_dx(&lt;=f,5)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(3e-4+3e-4i)
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f)})})})})
<br>
-> 119.18659727305976+0.3620753183716584i+O(4e-9+4e-9i)
<br>
・5階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(7e-8+7e-8i)
<br>
・6階微分
<br>
_dx(&lt;=f,6)
<br>
-> -0.0004498352662456228+0.0005560189878646384i+O(1e-3+1e-3i)
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f)})})})})})
<br>
-> -322.002293591315+54.781879309774695i+O(3e-8+3e-8i)
<br>
・6階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)
<br>
-> -0.004201126114795549+0.005541058257682469i+O(1e-6+1e-6i)
<br>
・7階微分
<br>
_dx(&lt;=f,7)
<br>
-> -0.0007280114418273857+0.0030141311391229672i+O(4e-3+4e-3i)
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f)})})})})})})
<br>
-> -177398.93670986558-669172.3211788241i+O(3e-7+3e-7i)
<br>
・7階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;={_dx(&lt;=f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)},1,x,64dx)
<br>
-> -0.009902789205100404+0.05048924924402281i+O(2e-5+2e-5i)
<br>
・8階微分
<br>
_dx(&lt;=f,8)
<br>
-> 0.03950452954492218+0.04027593568552271i+O(2e-2+2e-2i)
<br>
・9階微分
<br>
_dx(&lt;=f,9)
<br>
-> -0.16566502311270223-0.015219989707358128i+O(7e-2+7e-2i)
<br>
・10階微分
<br>
_dx(&lt;=f,10)
<br>
-> 0.044163954487214524-0.06480605313760723i+O(3e-1+3e-1i)
<br>
・微分位置を大きくした場合
<br>
_dx(&lt;={x^2},1,1e10)
<br>
-> 20000000000.027855-2.790277777777778e-12i+O(1e+28+1e-12i)
<br>
_dx(&lt;={x^2},2,1e10)
<br>
-> 1.9999999995176474+9.657789228690995e-20i+O(2e+29+2e-11i)
<br>
_dx(&lt;={x^2},3,1e10)
<br>
-> 1.894235601707095e-17-5.686908543633962e-27i+O(2e+15+2e-5i)
<br>
・微分位置を小さくした場合
<br>
_dx(&lt;={x^2},1,1e-10)
<br>
-> 2.0000000041847774e-10+7.305374602696278e-19i+O(1e-12+1e-12i)
<br>
_dx(&lt;={x^2},2,1e-10)
<br>
-> 2.0000000000000013+9.411477191714447e-16i+O(2e-11+2e-11i)
<br>
_dx(&lt;={x^2},3,1e-10)
<br>
-> 1.5072697186506098e-13-7.131763305997033e-14i+O(2e-5+2e-5i)
<br>
・2変数の多重微分
<br>
_Dy(&lt;={_Dx(&lt;={x*y*y},1,0)},1,1)
<br>
-> 1.9999999999998288+1.8785308474662037e-13i+O(8e-12+8e-12i)
<br>
<br>
応用例を示す
<br>
・非線形方程式の解法を使用
<br>
・微分方程式(x^3)"+x-7(1+i)=0の解析解x=1+iの求解
<br>
storage cleared
<br>
f&lt;={_dx(&lt;={x^3},2)+x-7(1+i)=0};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;={x}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,6) -> infoLost!! 2.3549912261033786e-10+O(2e-2)
<br>
x -> infoLost!! 0.9999999999877383+1.0000000000273828i+O(5e-5+5e-5i)
<br>
・ノルムがマシン誤差まで収束困難のため、一定回数の反復で打切る
<br>
・次に数値解の一例を示す
<br>
storage cleared
<br>
f&lt;={2x*_dx(&lt;={x*exp(3x)})=i};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;={x}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,12) -> 3.844899655887233e-14+O(1e+0)
<br>
x -> -0.17989326929739397-0.5079280004968542i+O(2e-1+2e-1i)
<br>
・続けて厳密解同等の数値解を示す
<br>
storage cleared
<br>
f&lt;={2x*(1*exp(3x)+x*exp(3x)3)=i};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;={x}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,12) -> infoLost!! 3.3306690738754696e-16
<br>
x -> infoLost!! -0.17989326929046887-0.5079280004963925i
<br>
・連立方程式の解析解{x0,x1}={1,1}の求解
<br>
storage cleared
<br>
f0&lt;={1*x0^2+x1};
<br>
f1&lt;={i*x1^3+x0};
<br>
dx0&lt;=_dx0; dx1&lt;=_dx1;
<br>
x&lt;={x0,x1};
<br>
f&lt;={x0+x1=2,dx0(&lt;={f0})+dx1(&lt;={f1},2)=2+6i};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,12) -> infoLost!! 3.236567392072123e-11+O(2e-3)
<br>
x ->
<br>
(infoLost!! 1.000000000003112+3.106688703682062e-12i+O(1e-5+1e-5i):
<br>
infoLost!! 0.9999999999968879-3.106688703682063e-12i+O(1e-5+1e-5i))
<br>
・同じく実数演算の場合
<br>
storage cleared
<br>
f0&lt;={1*x0^2+x1};
<br>
f1&lt;={i*x1^3+x0};
<br>
dx0&lt;=_dx0; dx1&lt;=_dx1;
<br>
x&lt;={x0,x1};
<br>
f&lt;={x0+x1=2,dx0(&lt;={f0})+dx1(&lt;={f1},2)=2+6i};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,12) -> 7.724854831493598e-14+O(9e-4)
<br>
x -> (1.000000000000009+O(1e-5):0.9999999999999909+O(1e-5))
<hr>
<br>
積分高階関数
<br>
・連続関数の積分範囲[a,b]における定積分を数値的に演算して返す
<br>
・数値誤差O(dxI^4以上)を含み、演算結果に目安の解析誤差を表示する
<br>
・積分範囲の分割数の既定値NI=100
<br>
・積分の差分間隔dxI=(b-a)/NI
<br>
・アンダーバーi変数名で呼び出す
<br>
・変数は無次元でローカル変数を参照するが、上書きしない
<br>
<br>
_i変数名(&lt;=第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: 変数の関数式を式渡し
<br>
・第2引数: 変数の積分下限aを値渡し
<br>
・第3引数: 変数の積分上限bを値渡し
<br>
オプション
<br>
・第4引数: 積分範囲の分割数（正の偶数）を値渡し[省略時、NI既定値]
<br>
<br>
数値誤差に関する精度次数について記述する
<br>
・数値誤差は絶対誤差
<br>
・既定で合成Simpson公式による4次精度
<br>
・台形公式による2次精度を選択可（内部オプション）
<br>
<br>
詳細は<a href="#span-out-fdm">有限差分法</a>参照
<br>
<br>
使用例を示す
<br>
・f(x)=x^4の積分範囲[0,1+i]における定積分を示す
<br>
a=0; b=1+i; ab=[a,b]; f&lt;={x^4} -> stored_eqn(f)
<br>
・分割数100
<br>
_ix(&lt;=f,ab) || _ix(&lt;=f,a,b)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数10
<br>
_ix(&lt;=f,ab,10)
<br>
-> -0.8000533333333335-0.8000533333333333i+O(1e-4+1e-4i)
<br>
・分割数1000
<br>
_ix(&lt;=f,ab,1000)
<br>
-> -0.8000000000005332-0.800000000000533i+O(1e-12+1e-12i)
<br>
・積分範囲を反転
<br>
_ix(&lt;=f,[b,a]) || _ix(&lt;=f,b,a)
<br>
-> 0.8000000053333336+0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が奇数の場合、暗黙で+1して偶数に変換される
<br>
_ix(&lt;=f,ab,99) || _ix(&lt;=f,ab,99+1)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が負の場合、暗黙で絶対値に変換される
<br>
_ix(&lt;=f,ab,-100)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・2次精度選択の場合（参考）
<br>
_ix(&lt;=f,ab)
<br>
-> -0.8001333320000001-0.8001333319999999i+O(1e-4+1e-4i)
<br>
・2変数の多重積分
<br>
_iy(&lt;={_ix(&lt;={x^2*y},0,y)},0,2) -> 2.1333333475555563+O(2e-7)
<br>
_iy(&lt;={y^4/3},0,2) -> 2.1333333475555563+O(2e-7)
<br>
・微分・積分
<br>
_ix(&lt;={_dx(&lt;={x^3})},1,2)
<br>
-> 7.000000000000061-3.369899113923336e-14i+O(1e-8+1e-14i)
<br>
_Ix(&lt;={_Dx(&lt;={sin(x)},1,0)},-pi,pi)
<br>
-> 6.283185307180439+2.010557877134426e-14i+O(2e-5+8e-14i)
<br>
・積分・微分
<br>
_dx(&lt;={_ix(&lt;={x^3},0,x)},1,2)
<br>
-> 7.999999999998895+5.517384388870678e-13i+O(1e-6+1e-12i)
<br>
<br>
応用例を示す
<br>
・非線形方程式の解法を使用
<br>
・f(x)=x^2のx=[0,b]の定積分=3^3/3となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f&lt;={_ix(&lt;={x^2},0,b)=3^3/3};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;={b},&lt;={1}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,12) -> infoLost!! 1.3839478914652153e-28+O(8e-7)
<br>
b -> infoLost!! 2.9999999999999996+4.613167602434132e-34i+O(1e-1+2e-1i)
<br>
・2次関数の積分の場合、補間多項式に一致するため、数値誤差が出ない
<br>
_ix(&lt;={x^2},0,3,2) -> 9+O(5e+0)
<br>
_ix(&lt;={x^2},0,3,10) -> 8.999999999999998+O(8e-3)
<br>
_ix(&lt;={x^2},0,3,100) -> 8.999999999999998+O(8e-7)
<br>
_ix(&lt;={x^2},0,3,1000) -> 8.999999999999998+O(8e-11)
<br>
・f(x)=x^4のx=[0,b]の定積分=3^5/5となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f&lt;={_ix(&lt;={x^4},0,b)=3^5/5};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;={b},&lt;={1}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,20) -> 1.4210854715508634e-14+O(8e-7)
<br>
b -> infoLost!! 2.9999999959999992-1.15251646351758e-21i+O(2e-2+2e-2i)
<br>
・高次の関数の積分の場合、収束までの反復回数が増える
<br>
・得られる近似解の精度は分割数に依存する
<br>
_ix(&lt;={x^4},0,3,2) -> 50.62499999999998+O(5e+0)
<br>
_ix(&lt;={x^4},0,3,10) -> 48.60323999999998+O(8e-3)
<br>
_ix(&lt;={x^4},0,3,100) -> 48.60000032400001+O(8e-7)
<br>
_ix(&lt;={x^4},0,3,1000) -> 48.60000000003241+O(8e-11)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh"></span>
行列高階関数の入力仕様と付随する留意事項について記述する
<hr>
<br>
Jacobi高階関数
<br>
・Jacobi行列を数値的に演算して返す
<br>
・数値的安定性・収束性を最優先
<br>
　精度を上げると不必要にNewton法の収束速度が悪化する
<br>
　微分位置に応じて差分間隔を可変すると収束速度が悪化する
<br>
　近似解の目安の解析誤差が過大評価される背反が残る
<br>
・1次精度の数値誤差O(dx)を含むが、演算結果に表示しない
<br>
・1階偏微分の差分間隔実数値dxJの既定値dxJ=1e-5
<br>
・微分位置xでの差分間隔dxの既定値dx=dxJ(1+i)
<br>
・ローカル変数を参照するが、上書きしない
<br>
<br>
Jacobi(&lt;=第1引数,&lt;=第2引数[,&lt;=第3引数[,&lt;=第4引数]])
<br>
・第1引数: 方程式または関数式の列ベクトルを式渡し
<br>
・第2引数: 未知変数の列ベクトルを式渡し
<br>
オプション
<br>
・第3引数: 未知変数初期値の列ベクトルを式渡し[省略時、零ベクトル]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: 偏微分の差分間隔dxを値渡し[省略時、dx既定値]
<br>
<br>
xの1次方程式の偏微分係数を求める場合
<br>
clear; Jacobi(&lt;={3x-3=0},&lt;={x},&lt;={0})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
clear; Jacobi(&lt;={3x-3=0},&lt;={x})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
・右辺に移項した関数=-3x+3のx=0周辺の傾き-3を返す
<br>
<br>
xの2次関数の偏微分係数を求める場合
<br>
clear; Jacobi(&lt;={2x^2},&lt;={x},&lt;={1})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
・1階偏微分の解析解=4xよりx=1周辺の傾き4を返す
<br>
<br>
微分位置を大きくした場合
<br>
clear; Jacobi(&lt;={2x^2},&lt;={x},&lt;={1e10})  // NG
<br>
-> 19999999999.999996+19999999999.999996i
<br>
clear; a=1e10; h=max(1,abs(a))1e-5(1+i); Jacobi(&lt;={2x^2},&lt;={x},&lt;={a},h)  // OK
<br>
-> 40000200000.65538+199999.3446694911i
<br>
・情報落ちの対策が必要
<br>
・1階偏微分の解析解=4xよりx=1e10周辺の傾き4e10を返す
<br>
<br>
ローカル変数を参照するが、上書きしない
<br>
storage cleared
<br>
x=1;
<br>
Jacobi(&lt;={2x^2},&lt;={x})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
x -> 1
<hr>
<br>
Newton高階関数
<br>
・Newton法による反復1回の演算結果を返す
<br>
・引数はJacobi高階関数に同じ
<br>
・返値は符号付の解の修正ベクトル
<br>
・ローカル変数を参照、上書きする
<br>
<br>
Newton(&lt;=第1引数,&lt;=第2引数[,&lt;=第3引数])
<br>
・第1引数: 方程式または関数式の列ベクトルを式渡し
<br>
・第2引数: 未知変数の列ベクトルを式渡し
<br>
オプション
<br>
・第3引数: 未知変数初期値の列ベクトルを式渡し[省略時、零ベクトル]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
<br>
応用例は連立方程式の解法と併せて記述する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
有限
<br>
差分法
    </th>
    <td>
<span id="span-out-fdm"></span>
有限差分法の解法について記述する
<hr>
<br>
有限差分による微分の数値解法について記述する
<br>
<br>
差分間隔をhとして連続関数f(x)のx周辺の2次打切りテイラー展開より
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+O(h^3)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+O(h^3)
<br>
・1階微分の2次精度中心差分
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O(h^2)
<br>
・2階微分の2次精度中心差分
<br>
f"(x)=(f(x+h)-2f(x)+f(x-h))/(h^2)+O(h^2)
<br>
<br>
2次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(f'(x+h)-f'(x-h))/(2h)=(f(x+2h)-f(x)-f(x)+f(x-2h))/(2h)^2+O(h)
<br>
・本来、2階微分の精度次数が落ちるが、H=2hとすれば精度次数が落ちない
<br>
f"(x)=(f(x+H)-2f(x)+f(x-H))/(H^2)+O(H^2)
<br>
・よって微分階数が1階上がる毎に差分間隔2倍の関係が成立すると仮定して
<br>
・3階微分以降も同様に、再帰的に多重化する
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O((h)^2)
<br>
f"(x)=(f'(x+2h)-f'(x-2h))/(4h)+O((2h)^2)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+8h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
<br>
<br>
続いて4次打切りテイラー展開より
<br>
f(x-2h)=f(x)+f'(x)(-2h)+f"(x)(-2h)^2/2!+f"'(x)(-2h)^3/3!+f""(x)(-2h)^4/4!+O(h^5)
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+f"'(x)(-h)^3/3!+f""(x)(-h)^4/4!+O(h^5)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+f"'(x)(h)^3/3!+f""(x)(h)^4/4!+O(h^5)
<br>
f(x+2h)=f(x)+f'(x)(2h)+f"(x)(2h)^2/2!+f"'(x)(2h)^3/3!+f""(x)(2h)^4/4!+O(h^5)
<br>
・次の3階微分を消去すれば
<br>
f(x+2h)-f(x-2h)=f'(x)(4h)-f"'(x)(2h)^3/3+O(h^5)
<br>
f(x+h)-f(x-h)=f'(x)(2h)-f"'(x)(h)^3/3+O(h^5)
<br>
・1階微分の4次精度中心差分
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
<br>
さらに5次打切りテイラー展開より
<br>
・次の4階微分を消去すれば
<br>
f(x+2h)+f(x-2h)=2f(x)+f"(x)(2h)^2+f""(x)(2h)^4/12+O(h^6)
<br>
f(x+h)+f(x-h)=2f(x)+f"(x)(h)^2+f""(x)(h)^4/12+O(h^6)
<br>
・2階微分の4次精度中心差分
<br>
f"(x)=(16(f(x+h)+f(x-h))-(f(x+2h)+f(x-2h))-30f(x))/(12h^2)+O(h^4)
<br>
<br>
4次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
・2次精度の場合と異なり、必要な離散点数が増えるが、
<br>
f'(x+h)=(8(f(x+2h)-f(x))-(f(x+3h)-f(x-h)))/(12h)
<br>
f'(x-h)=(8(f(x)-f(x-2h))-(f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)=(8(f(x+3h)-f(x+h))-(f(x+4h)-f(x)))/(12h)
<br>
f'(x-2h)=(8(f(x-h)-f(x-3h))-(f(x)-f(x-4h)))/(12h)
<br>
・ステンシルが2倍に広がる点は変わらない
<br>
f'(x+h)-f'(x-h)=(8(f(x+2h)-2f(x)+f(x-2h))-(f(x+3h)-f(x-h)+f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)-f'(x-2h)=(8(f(x+3h)-f(x+h)-f(x-h)+f(x-3h))-(f(x+4h)-2f(x)+f(x-4h)))/(12h)
<br>
・よって再帰的に多重化した場合、微分階数が上がる毎に精度が悪化する
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
f"'(x)=(8(f"(x+h)-f"(x-h))-(f"(x+2h)-f"(x-2h)))/(12h)+O(h^2)
<br>
f""(x)=(8(f"'(x+h)-f"'(x-h))-(f"'(x+2h)-f"'(x-2h)))/(12h)+O(h)
<br>
...
<br>
<br>
2階微分の演算結果を示す
<br>
_dx(&lt;={(x+i)^5},2,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
　・1階微分を多重化して再帰的に微分階数を上げる際、
<br>
　・拡張なしは差分間隔一定
<br>
　・拡張ありは1階上がる毎に差分間隔2倍の関係を仮定
<br>
-> -40.000079995027676+40.000100045239535i+O(1e-6+1e-6i)
<br>
-> -40.000199999917704+40.00019999969536i+O(4e-6+4e-6i)
<br>
-> -40.00000000012216+40.00000000037086i+O(8e-12+8e-12i)
<br>
-> -39.99999999980588+39.99999999944028i+O(2e-11+2e-11i)
<br>
・2階微分までは拡張の有無は大差ない
<br>
<br>
5階微分の演算結果を示す
<br>
_dx(&lt;={(x+i)^5},5,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
-> -2376.9807493302333+2495.6629047556085i+O(1e-6+1e-6i)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(3e-4+3e-4i)
<br>
-> 119.18659727305976+0.3620753183716584i+O(4e-9+4e-9i)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(7e-8+7e-8i)
<br>
・3階微分以降は拡張必須
<br>
<br>
以上より、微分階数が2階までは4次精度拡張、それ以降は2次精度拡張とする
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+2h)-f'(x-2h))-(f'(x+4h)-f'(x-4h)))/(24h)+O(h^3)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+4h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
<hr>
<br>
有限差分による積分の数値解法について記述する
<br>
<br>
前提を列挙する
<br>
・2項演算子は左結合を前提に記述する
<br>
・除算より記号省略乗算優先を前提に記述する
<br>
・行列は本説明書の構文を前提に記述する
<br>
・総和をΣ&lt;変数=開始値,終了値&gt;で記述する
<br>
・線形結合をベクトルの内積で記述する
<br>
<br>
公式を導出する
<br>
・連続関数f(x)の積分範囲[a,b]をN等分割して差分間隔をhとする
<br>
h=(b-a)/N
<br>
・分割した離散点xiに対する関数の離散点f{i}を定義する
<br>
xi=a+i*h, i=0~N
<br>
f{i}=f(xi)
<br>
・分割した微小区間の面積dS{i}と全区間の面積Sを定義する
<br>
dS{i}, i=0~N-1
<br>
S=Σ&lt;i=0,N-1&gt;dS{i}
<br>
<br>
微小区間の関数fを線形補間する場合、2次精度の台形公式
<br>
・微小区間の台形の面積の総和を取ることで
<br>
dS{0}=(f{0}+f{1})h/2+O(h^3)
<br>
dS{i}=(f{i}+f{i+1})h/2+O(h^3)
<br>
S=Σ&lt;i=0,N-1&gt;dS{i}=Σ&lt;i=0,N-1&gt;(f{i}+f{i+1})h/2+O(h^2)
<br>
・次の台形公式が導出される
<br>
S=(f{0}+2Σ&lt;i=1,N-1&gt;f{i}+f{N})h/2+O(h^2)
<br>
・両端を除く離散点f{i}は2回足されて2倍
<br>
・離散化誤差のオーダーは微小区間の正方形面積h*h
<br>
<br>
微小区間の関数fを1次多項式で補間する場合も同様
<br>
・1次の補間多項式P1(x)を定義する
<br>
P1(x)=(1,x)(l:m)
<br>
・独立する2点の離散点xiに対する離散点f{i}から
<br>
P1(x0)=(1,x0)(l:m)=f{0}
<br>
P1(x1)=(1,x1)(l:m)=f{1}
<br>
・次の連立線形方程式V1*y1=r1を解くことで
<br>
V1=(1,x0:1,x1)
<br>
y1=(l:m)
<br>
r1=(f{0}:f{1})
<br>
・P1(x)の係数ベクトルy1が求まる
<br>
・VはVandermonde行列
<br>
・離散点がすべて独立であればVの逆行列が一意に存在する
<br>
・予め逆行列を解いた方が丸め誤差の影響を受けにくい
<br>
・その形式に変形したLagrange基底の補間多項式を導出する
<br>
m=(f{0}-f{1})/(x0-x1)
<br>
l=f{0}-(f{0}-f{1})/(x0-x1)*x0
<br>
(l:m)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))(f{0}:f{1})
<br>
・y1=inverse(V1)*r1より
<br>
・V1の逆行列inverse(V1)
<br>
inverse(V1)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
・P1(x)=(1,x)(l:m)=(1,x)*inverse(V1)*(f{0}:f{1})より
<br>
・1次のLagrange基底多項式のベクトルL1=(1,x)*inverse(V1)
<br>
L1=(1,x)(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・1次のLagrange型の補間多項式
<br>
P1(x)=L1*(f{0}:f{1})
<br>
L1=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・P1(x)の不定積分integral(P1(x))
<br>
h=x1-x0
<br>
L1=(1/h)(-(x-x1),(x-x0))
<br>
integral(P1(x))=(1/2h)(-(x-x1)^2+C{0},(x-x0)^2+C{1})(f{0}:f{1})
<br>
・C{i}は積分定数
<br>
・P1(x)の微小区間[x0,x1]における定積分
<br>
dS{0}=(1/2h)(h^2,h^2)(f{0}:f{1})=(h/2)(1,1)(f{0}:f{1})=(f{0}+f{1})h/2
<br>
・以上より、次の台形公式が導出される
<br>
S=(f{0}+2Σ&lt;i=1,N-1&gt;f{i}+f{N})h/2+O(h^2)
<br>
<br>
微小区間の関数fを2次多項式で補間する場合、4次精度の合成Simpson公式
<br>
・2次の補間多項式P2(x)を定義する
<br>
P2(x)=(1,x,x^2)(l:m:n)
<br>
・独立する3点の離散点xiに対する離散点f{i}から
<br>
P2(x0)=(1,x0,x0^2)(l:m:n)=f{0}
<br>
P2(x1)=(1,x1,x1^2)(l:m:n)=f{1}
<br>
P2(x2)=(1,x2,x2^2)(l:m:n)=f{2}
<br>
・次の連立線形方程式V2*y2=r2を解くことで
<br>
V2=(1,x0,x0^2:1,x1,x1^2:1,x2,x2^2)
<br>
y2=(l:m:n)
<br>
r2=(f{0}:f{1}:f{2})
<br>
・P2(x)の係数ベクトルy2が求まる
<br>
・以下、1次の場合同様に導出
<br>
・2次のLagrange型の補間多項式
<br>
P2(x)=L2*(f{0}:f{1}:f{2})
<br>
L2=(
<br>
(x-x1)(x-x2)/(x0-x1)(x0-x2),
<br>
(x-x0)(x-x2)/(x1-x0)(x1-x2),
<br>
(x-x0)(x-x1)/(x2-x0)(x2-x1))
<br>
・P2(x)の不定積分integral(P2(x))
<br>
h=x1-x0=x2-x1
<br>
L2=(1/(2h^2))((x-x1)(x-x2),-2(x-x0)(x-x2),(x-x0)(x-x1))
<br>
integral(P2(x))=(1/(2h^2))(
<br>
x^3/3-(x1+x2)x^2/2+x1*x2*x+C{0},
<br>
-2(x^3/3-(x0+x2)x^2/2+x0*x2*x+C{1}),
<br>
x^3/3-(x0+x1)x^2/2+x0*x1*x+C{2})(f{0}:f{1}:f{2})
<br>
・C{i}は積分定数
<br>
・P2(x)の微小2区間[x0,x2]における定積分
<br>
・1列目のみ示す
<br>
x0=x1-h
<br>
x2=x1+h
<br>
(x2^3-x0^3)/3-(x1+x2)(x2+x0)(x2-x0)/2+x1*x2(x2-x0)
<br>
=((x1+h)^3-(x1-h)^3)/3-(2x1+h)(2x1)h+x1(x1+h)2h
<br>
=(3x1^2+h^2)2h/3-(2x1+h)(x1)2h+x1(x1+h)2h
<br>
=(3x1^2+h^2-(2x1+h)(x1)3+x1(x1+h)3)2h/3
<br>
=(h^2)2h/3
<br>
・2列目以降も同様
<br>
・以上より、次のSimpson公式が導出される
<br>
dS{0}+dS{1}=(h/3)(1,4,1)(f{0}:f{1}:f{2})+O(h^5)
<br>
・さらに分割数Nは正の偶数を前提として総和を取ることで
<br>
S=Σ&lt;k=0,N/2-1&gt;(dS{2k}+dS{2k+1})+O(h^4)
<br>
=(h/3)(Σ&lt;k=0,N/2-1&gt;((1,4,1)(f{2k}:f{2k+1}:f{2k+2})))+O(h^4)
<br>
・次の合成Simpson公式が導出される
<br>
S=(f{0}+4Σ&lt;k=0,N/2-1&gt;f{2k+1}+2Σ&lt;k=1,N/2-1&gt;f{2k}+f{N})h/3+O(h^4)
<br>
・両端を除く偶数の離散点f{2k}は2回足されて2倍
<br>
・離散化誤差のオーダーは微小区間の正方形面積h*hの2乗
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-linear"></span>
式変数を使用した連立線形方程式の解法について記述する
<br>
<br>
連立方程式の解法には直接法と反復法の2種類が存在し、特徴を列挙する
<br>
・直接法は解を厳密に解くため、線形方程式のみ適用可
<br>
・反復法は解の修正を繰り返して近似的に解くため、非線形方程式に拡張可
<br>
<br>
2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(1,2:3,4);
b={5,6};
<br>
<br>
直接法
<br>
・pivot選択の前処理付きGaussの消去法を用いる
<br>
x=Gauss(A,b); x -> (-3.9999999999999982:4.499999999999999)
<br>
・行列操作を駆使して演算内容を以下に示す
<br>
・pivot選択
<br>
A=(1,2:3,4); A=(A[1]:A[0]); A -> (3,4:1,2)
<br>
b={5,6}; b=(b[1]:b[0]); b -> (6:5)
<br>
・前進消去
<br>
k=A[1][0]/A[0][0]; k -> 0.3333333333333333
<br>
・係数kは左から標準外積
<br>
A[1]=A[1]-k(A[0]); A -> (3,4:0,0.6666666666666667)
<br>
b[1]=b[1]-k(b[0]); b -> (6:3)
<br>
・後退代入
<br>
x={,}; x -> (0:0)
<br>
x[1]=b[1]/A[1][1]; x -> (0:4.499999999999999)
<br>
x[0]=(b[0]-A[0]x)/A[0][0]; x -> (-3.9999999999999982:4.499999999999999)
<br>
・式変数を使用して一般化
<br>
A=(1,2:3,4); A=(A[1]:A[0]);
<br>
b={5,6}; b=(b[1]:b[0]);
<br>
x={,};
<br>
ir=0;
<br>
forward&lt;={ir=ir+1,k=A[ir][0]/A[0][0],A[ir]=A[ir]-k(A[0]),b[ir]=b[ir]-k(b[0]),&lt;=A}=&gt;;
<br>
forward -> (3,4:0,0.6666666666666667)
<br>
forward -> [MyErr]Invalid reference of array
<br>
ir -> 1
<br>
x[ir]=b[ir]/A[ir][ir];
<br>
backward&lt;={ir=ir-1,x[ir]=(b[ir]-A[ir]x)/A[ir][ir],&lt;=x}=&gt;;
<br>
backward -> (-3.9999999999999982:4.499999999999999)
<br>
backward -> [MyErr]Invalid reference of array
<br>
<br>
反復法
<br>
・連立方程式と未知変数初期値（以降、初期値と省略する）を定義する
<br>
storage cleared
<br>
x0=0;
<br>
x1=0;
<br>
x&lt;={x0,x1}; x_initial&lt;={x0,x1};
<br>
f&lt;={1x0+2x1=5,3x0+4x1=6};
<br>
・続いて以降の処理を反復する
<br>
・簡単のため、式変数を直接読出す
<br>
J=Jacobi(&lt;=f,&lt;=x,&lt;=x_initial);
<br>
dx=Gauss(J,-f);
<br>
x_next=x+dx;
<br>
x0=x_next[0];
<br>
x1=x_next[1];
<br>
normf=max(norm(f),norm(-dx));
<br>
・反復3回目のノルムと近似解を示す
<br>
normf -> infoLost!! 2.2204460494935903e-15
<br>
x0 -> infoLost!! -3.999999999999999-3.362471994400586e-26i
<br>
x1 -> infoLost!! 4.499999999999999+6.466216308756395e-26i
<br>
・ノルムがマシン誤差O(1e-16)に収束すれば収束判定条件を満たす
<br>
・その場合、近似解は厳密解にほぼ一致する
<br>
・線形方程式の場合、即座に解付近に飛ぶため、収束が速い
<br>
<br>
上記の線形・非線形の連立方程式を一般化する解法について記述する
<br>
・近似解の列ベクトル{x}の各要素を表す添字をjとする
<br>
・方程式の列ベクトル{f}の各要素を表す添字をiとする
<br>
・これより方程式の全微分dfを次のテンソルで表記する
<br>
{df[i]}=(df[i]/dx[j]){dx[j]}
<br>
・左辺の全微分を単純に仮定すると（Jacobi行列に高精度を求めない理由）
<br>
{df[i]}={0-f[i]}
<br>
・Ax=bの連立線形方程式に一般化されたNewton法が導出される
<br>
・ここで符号は零行列との差分またはScalar倍で定義される
<br>
(df[i]/dx[j]){dx[j]}={-f[i]}
<br>
A=(df[i]/dx[j])
<br>
x={dx[j]}
<br>
b={-f[i]}
<br>
・Jacobi行列Aがfull-rankであれば求解の必要十分条件を満たす
<br>
・直接法で求解した解の修正ベクトルdxを用いて近似解を修正する
<br>
<br>
上記の反復1回の処理をまとめたNewton高階関数について記述する
<br>
・引数はJacobi高階関数に同じとする
<br>
・Scalar倍の符号位置を変えて次の連立線形方程式を直接法で解く
<br>
A=(df[i]/dx[j])
<br>
x={-dx[j]}
<br>
b={f[i]}
<br>
・さらに得られた符号付の解の修正ベクトルをmdxとして
<br>
・近似解のベクトルを一度に修正する（ローカル変数を上書きする）
<br>
x=x-mdx
<br>
・関数の返値はmdxとする
<br>
<br>
以上より、反復1回の処理を簡潔にまとめる
<br>
storage cleared
<br>
x&lt;={x0,x1}; x_initial&lt;={0,0};
<br>
f&lt;={1x0+2x1=5,3x0+4x1=6};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;=x_initial),max(norm(f),norm(mdx)));
<br>
・実行用の式変数runを定義してノルムのみ表示する
<br>
<br>
反復を実行
<br>
run -> 6.020797289251035
<br>
run -> 2.0548659974995737e-10
<br>
・反復3回目のノルムと近似解は先述の通り一致する
<br>
run -> infoLost!! 2.2204460494935903e-15
<br>
x ->
<br>
(infoLost!! -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost!! 4.499999999999999+6.466216308756395e-26i)
<br>
<br>
再帰高階関数を使用して反復を実行
<br>
storage cleared
<br>
x&lt;={x0,x1}; x_initial&lt;={0,0};
<br>
f&lt;={1x0+2x1=5,3x0+4x1=6};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;=x_initial),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,3) -> infoLost!! 2.2204460494935903e-15
<br>
x ->
<br>
(infoLost!! -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost!! 4.499999999999999+6.466216308756395e-26i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
非線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-non-linear"></span>
式変数を使用した連立非線形方程式の反復解法について記述する
<br>
<br>
虚数単位を求める1元2次の方程式を一例に示す
<br>
x0^2+1=0
<br>
・解を2個示す
<br>
x0=i; x0^2+1=0 -> -1.2246467991473532e-16i
<br>
x0=-i; x0^2+1=0 -> 1.2246467991473532e-16i
<br>
・非線形方程式を定義する
<br>
storage cleared
<br>
x&lt;={x0};
<br>
f&lt;={x0^2+1=0};
<br>
<br>
初期値を1+2iとした反復6回目の近似解を示す
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;={1+2i}),max(norm(f),norm(mdx)));
<br>
_rn(&lt;={run},,6) -> 4.848187063331881e-11
<br>
x -> 6.918085522901255e-17+0.9999999999999997i
<br>
<br>
初期値を1-2iとした反復6回目の近似解を示す
<br>
・上記演算に続けてクリア実行しない場合、初期値を直接更新して実行
<br>
x0=1-2i;
<br>
_rn(&lt;={run},,6) -> 4.2544881989018353e-11
<br>
x -> -5.067058578678027e-17-1.0000000000000002i
<br>
・方程式または関数の次数に応じて収束までの反復回数が増える
<br>
<br>
実数演算の場合、解が存在しないため、収束しない
<br>
・2次の方程式の場合、右辺に移項した関数の極値周辺を右往左往する
<br>
storage cleared
<br>
x&lt;={x0};
<br>
f&lt;={real(x0)^2+1=0}; || f&lt;={-(real(x0)^2+1)};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;={1}),max(norm(f),norm(mdx)));
<br>
run -> 1.414206491330789
<br>
run -> 2500010689.1876636
<br>
run -> 625005364.923743
<br>
run -> 156251267.10125032
<br>
run -> 39062798.523787886
<br>
run -> 9765710.483364047
<br>
run -> 2441427.7048029117
<br>
run -> 610357.137491086
<br>
run -> 152589.53659088546
<br>
run -> 38147.63324071567
<br>
<br>
以上の結果をまとめる
<br>
・解が複数存在する場合、得られる近似解は初期値に依存する
<br>
・解が存在しない場合、解が収束しないか解が無限大に発散する
<br>
・高次の方程式または関数の場合、解が存在しても初期値によっては発散する
<br>
<br>
次に関数を使用した2元の連立非線形方程式を一例に示す
<br>
・連立非線形方程式と初期値を定義する
<br>
storage cleared
<br>
x&lt;={x0,x1}; x_initial&lt;={1+i,1-i};
<br>
f&lt;={x0^i-2x1=3i,3x0+exp(x1)=5i};
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;=x_initial),max(norm(f),norm(mdx)));
<br>
・反復6回目の近似解を示す
<br>
_rn(&lt;={run},,6) -> infoLost!! 2.2368035825474494e-16
<br>
x ->
<br>
(infoLost!! -0.04901921620544653+2.023423045158351i:
<br>
infoLost!! 0.07726186556052178-1.434248862158042i)
<br>
<br>
同じく引数の列ベクトルに丸括弧を使用する場合
<br>
・連立非線形方程式と初期値を定義する
<br>
storage cleared
<br>
x&lt;=(x0:x1); x_initial&lt;=(1+i:1-i);
<br>
f&lt;=(x0^i-2x1=3i:3x0+exp(x1)=5i);
<br>
run&lt;=last(mdx=Newton(&lt;=f,&lt;=x,&lt;=x_initial),max(norm(f),norm(mdx)));
<br>
・反復6回目の近似解を示す
<br>
_rn(&lt;={run},,6) -> infoLost!! 2.2368035825474494e-16
<br>
x ->
<br>
(infoLost!! -0.04901921620544653+2.023423045158351i:
<br>
infoLost!! 0.07726186556052178-1.434248862158042i)
<br>
<br>
同じく引数の列ベクトルを直接式渡しする場合
<br>
・mdxのノルムを返す式変数runを定義して反復6回目の近似解を示す
<br>
storage cleared
<br>
run&lt;=last(
<br>
mdx=Newton(&lt;=(x0^i-2x1=3i:3x0+exp(x1)=5i),&lt;=(x0:x1),&lt;=(1+i:1-i)),
<br>
norm(mdx));
<br>
_rn(&lt;={run},,6) -> 2.2368035825474494e-16
<br>
{x0,x1} ->
<br>
(infoLost!! -0.04901921620544653+2.023423045158351i:
<br>
infoLost!! 0.07726186556052178-1.434248862158042i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
極限の解法
    </th>
    <td>
<span id="span-out-limit"></span>
極限の解法について記述する
<br>
<br>
複素数演算の場合、次の極限演算不可
<br>
1/0 -> [MyErr]FN isNaN
<br>
・0割の演算で次の反則が発生
<br>
0*Infinity -> [MyErr]FN isNaN
<br>
<br>
complexのチェックを外して実数演算
<br>
1/0 -> Infinity
<br>
MIN_VALUE -> 5e-324
<br>
1/(-MIN_VALUE) -> -Infinity
<br>
1/(+MIN_VALUE) -> Infinity
<br>
1/Infinity || 1/Inf || 1/pInf -> 0
<br>
-Infinity+1 || nInf+1 -> infoLost!! -Infinity
<br>
Infinity-Infinity -> [MyErr]BRsa isNaN
<br>
<br>
極限値演算の一例を列挙する
<br>
x=MIN_VALUE; x -> 5e-324
<br>
sin(x)/x  // OK -> 1
<br>
sin(-x)/(-x)  // OK -> 1
<br>
ln(1+x)/x  // NG -> infoLost!! 0
<br>
・L'Hôpitalの定理
<br>
・複素数演算の場合
<br>
_dx(&lt;={ln(1+x)})/_dx(&lt;={x})  // OK
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(3e-24i)
<br>
_dx(&lt;={ln(1-x)})/_dx(&lt;={-x})  // OK
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(2e-16+3e-24i)
<br>
・実数演算の場合
<br>
_dx(&lt;={ln(1+x)})/_dx(&lt;={x})  // OK -> 0.9999999999991271
<br>
_dx(&lt;={ln(1-x)})/_dx(&lt;={-x})  // OK -> 0.9999999999991271
<br>
・無限大の極限は自明の演算以外は演算不可
<br>
y=pInf -> y=Infinity
<br>
(1/y)/y  // OK -> 0
<br>
y*y  // OK -> Infinity
<br>
y/(y*y)  // NG -> [MyErr]FN isNaN
<br>
_dy(&lt;={y})/_dy(&lt;={y*y})  // NG -> [MyErr]BRsa isNaN
<br>
_dy(&lt;={1/(y*y)})/_dy(&lt;={1/y})  // NG -> [MyErr]FN isNaN
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊仕様
    </th>
    <td>
<span id="span-out-special"></span>
最後に一般的でない可能性のある仕様について記述する
<br>
<br>
前置き単項の符号の扱いについて記述する
<br>
・単項の符号は同種の2項演算子と区別せず、結合性に従って演算する
<br>
・この時、符号の左側には零が存在すると仮定する
<br>
左結合時　+3-5+7-9 || ((((0+3)-5)+7)-9)
<br>
右結合時　+3-5+7-9 || (0+(3-(5+(7-9))))
<br>
・行列も同様に単項の符号は零行列との差分またはScalar倍として扱う
<br>
-(1,2:3,4) || (,:,)-(1,2:3,4) || (-1,:,-1)(1,2:3,4) -> (-1,-2:-3,-4)
<br>
・よって実用しないが、符号が連続する場合、右結合時のみ演算可
<br>
左結合時　--(1,i) || (-)-(1,i) -> Invalid binary operation
<br>
右結合時　--(1,i) || (,)-((,)-(1,i)) || (-1,)((-1,)(1,i)) -> (1,i)
<br>
左結合時　---(1,i) || ((-)-)-(1,i) -> Invalid binary operation
<br>
右結合時　---(1,i) || (,)-((,)-((,)-(1,i))) || (-1,)((-1,)((-1,)(1,i))) -> (-1,-i)
<br>
<br>
次にイコール記号=の扱いについて記述する
<br>
・代入と判別されないイコール記号は、右辺移行の2項演算子として扱う
<br>
・2項の結合性に依存するが、単体使用を前提とする
<br>
-3=5 || (0-3)=5 || =5+3 -> 8
<br>
(1,2:3,4)=(,:,) || =(,:,)-(1,2:3,4) -> (-1,-2:-3,-4)
<br>
(1,2:3,4)=(,) || =(,)-(1,2:3,4) -> [MyErr]Invalid matrix operation
<br>
・単項の場合、符号同様に左辺には零または零行列が存在すると仮定する
<br>
=8 || 0=8 || =8-0 -> 8
<br>
=(1,2:3,4) || (,:,)=(1,2:3,4) || =(1,2:3,4)-(,:,) -> (1,2:3,4)
<br>
・本仕様は式変数への方程式の代入で次の構文を許容する
<br>
f&lt;={x0^2+1=0}
<br>
<br>
行列を扱う上での演算都合上の仕様について記述する
<br>
・代入を括弧で括った場合、零を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は零が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をカンマまたはコロンで区切った場合、零を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
clear; (1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、行列を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
clear; x=(1,2),x || 0,(1,2) -> (0,1,2)
<br>
clear; max(x=(-1,-2),min(x)) || max(0,-2) -> 0
<br>
vector={1,2,3}:trans(vector)vector -> (0:14)
<br>
・式変数への代入も同様
<br>
(x&lt;=(a,b,c,d,e)) -> 0
<br>
・変数への式読出しは読出し値が残る
<br>
clear; y&lt;=3x-1,x=3,y=&gt;,y=&gt;y0,y0 -> (0,0,8,8,8)
<br>
<br>
式変数について記述する
<br>
・式変数、式代入、式読出し、式渡しの仕様は呼び名含めて一般的でない
<br>
・連立方程式をスクリプト入力から解くために独自に定義している
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-in">内部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
ソース抜粋
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
単位tree構造
    </th>
    <td>
<span id="span-in-tree"></span>
演算単位となる単位tree構造を以下に示す
<br>
<br>
これに基づく演算仕様について記述する
<br>
・i行j列の行列要素は2次元配列arr[i][j]を参照する
<br>
・関数の引数ベクトルはarr[arr.length-1]を参照する
<br>
・無次元の演算や定義できない行列演算はarrの最終要素を参照する
<br>
<pre><code>
            j-th sentence
  trees2d: [j][i]{tag || num}
  trees1d,     i-th token
    trees: [i]{}
  trees0d,
     tree: {}
      tag: {"name": {val: val}}
      num: {mat:    {arr: arr}}
      1+i: arr [0] [0] {com: {r: 1, i: 1}}
   matrix:     row col {complex number   }
(i,2:3,4): arr [0] [0] {com: {r: 0, i: 1}}
               [0] [1] {com: {r: 2, i: 0}}
               [1] [0] {com: {r: 3, i: 0}}
               [1] [1] {com: {r: 4, i: 0}}
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
オプション
    </th>
    <td>
<span id="span-in-options"></span>
コマンドライン実行で必要な内部のオプション項目について記述する
<br>
<br>
全オブジェクトはグローバルスコープから見えないMy_entryで始まる
<br>
<br>
My_entry.parserに渡すdataオブジェクトを示す
<br>
var data = {options:{}, vars:{}, eqns:{}};
<br>
<br>
内部オプションに相当するdata.optionsのプロパティを以下に列挙する
<br>
<br>
・makeLog: 演算終了後にログ出力用の文字列を作成するフラグ
<br>
　コマンドラインからログを見る場合、フラグを立てる
<br>
　一例を次に示す（以降のフラグも同様）
<pre><code>
var data = new My_entry.DATA().data();
data.in = "2*3";
new My_entry.parser().run(data);
data.out -> [Array(1)]  // 上記の単位tree構造が返却される
data.log -> undefined
data.options.makeLog = true;
new My_entry.parser().run(data);
data.log -> "6"
data.logh -> "2*3\n6"
data.logo -> "makeLog=true"
</code></pre>
・useComplex: 複素数を使用するフラグ
<br>
<br>
・useMatrix: 行列を使用するフラグ
<br>
<br>
以降、省略で既定値
<br>
<br>
・isRightAssociativityBR: 2項演算子の結合性を右結合に変更するフラグ
<br>
<br>
・isDIVprior2OMUL: 記号省略乗算より除算を優先するフラグ
<br>
<br>
・expDigit: 演算結果を表示する指数表記の桁数
<br>
<br>
・precedence: カンマ区切りで演算子のtag名を列挙した文字列
<br>
<br>
・checkError: 情報落ちの発生や微分・積分の数値誤差を評価するフラグ
<br>
<br>
・BTrow2col: 行ベクトルを列ベクトルに変更する括弧のtag名
<br>
<br>
・BTref: 行列要素を参照する括弧のtag名
<br>
<br>
・dxJ: Jacobi行列演算時の1階偏微分の差分間隔実数値
<br>
<br>
・dxD: 有限差分による1階微分の差分間隔実数値
<br>
<br>
・orderD: 有限差分による微分の精度次数
<br>
<br>
・NI: 有限差分による積分範囲の分割数
<br>
<br>
・orderI: 有限差分による積分の精度次数
<br>
<br>
以降、コマンドライン実行は無効
<br>
<br>
・useWorker: Workerを使用するフラグ
<br>
<br>
ブラウザから実行する場合、URLのGET入力で既定値を上書き可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数・関数・
<br>
区切り文字・
<br>
演算子の優先順位
    </th>
    <td>
<span id="span-in-prec"></span>
変数・関数・区切り文字・演算子の優先順位について記述する
<br>
<br>
配列要素の定義順で優先順位を動的に変更可能とする
<br>
<br>
operation.js抜粋
<pre><code>
  precedence: [
                 // comments and white-spaces are removed by parser
    [
      [
        /* following delimiter */
                 // SeparatoR semi-colon; are removed by parser
        "SRr",   // SeparatoR colon:
        "SRt"    // SeparatoR comma,
      ],
      [
        /* following store */
        "SEe"    // StorE obvious equation including bracket
      ],
      [
        /* following delimiter */
        "BT2",   // BrackeT {
        "BT1",   // BrackeT (
        "BT0"    // BrackeT [
      ],
      [
        /* following restore */
        "REe",   // RestorE obvious equation
        "REv"    // RestorE variable first, equation second
      ],
      [
        /* following function */
        "FNmh",  // FunctioN for matrix high-order
        "FNm",   // FunctioN for matrix
        "FNh",   // FunctioN high-order
        "FN",    // FunctioN 1~4-arguments
        "FNn"    // FunctioN n-arguments
      ]
    ],
    [
      [
        /* following operator */
        "URi",   // post-Unary operatoR imaginary unit i
        "URf"    // factorial mark ! || !!... operand is only natural number
      ],
      [
        "BRp",   // Binary operatoR ** || ^ -&gt; pow(left, right)
        "BRr"    // Binary operatoR %       -&gt; mod(left, right)
      ],
      [
        "BRmo"   // omitted multiplication sign
      ],
      [
        "BRdm"   // Binary operatoR / || *
      ],
      [
        "BRsa"   // Binary operatoR - || + including Pre-Unary operator - || +
      ],
      [
        "BRbs",  // Binary operatoR bit shift &lt;&lt; || &gt;&gt; || &gt;&gt;&gt;
        "BRba",  // Binary operatoR bit   and &amp;
        "BRbx",  // Binary operatoR bit   xor @
        "BRbo"   // Binary operatoR bit    or |
      ]
    ],
    [
      [
        "BRe"    // Binary operatoR = including Pre-Unary operator =
      ],
      [
        /* following store */
        "SEv"    // StorE variable
      ]
    ]
  ],
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定義済みの
<br>
関数・予約語
    </th>
    <td>
<span id="span-in-FN"></span>
定義済みの関数・予約語について記述する
<br>
<br>
予約語は大文字・小文字・全角・半角を区別しない
<br>
<br>
parser.js抜粋
<pre><code>
      // reserved word
      case "clear":
      case "stop":
        throw "Invalid "+token+" called";
        break;
      case "ans":
        tree = DATA.tree_tag("REv", token_lower);
        break;
      // "FNmh"
      case "jacobi":
      case "jacobian":
        tree = DATA.tree_tag("FNmh", "jacobian");
        break;
      case "newton":
      case "newtonian":
        tree = DATA.tree_tag("FNmh", "newtonian");
        break;
      // "FNm"
      // "FNm0"
      case "vector2r":
      case "vector3r":
      case "vector4r":
      case "vector2c":
      case "vector3c":
      case "vector4c":
      case "zeros2":
      case "zeros3":
      case "zeros4":
      case "ones2":
      case "ones3":
      case "ones4":
      case "id2":
      case "identity2":
      case "id3":
      case "identity3":
      case "id4":
      case "identity4":
        tree = DATA.tree_mat(math_mat[token_lower]());
        break;
      // "FNm1"
      case "rotationx":
      case "rotationy":
      case "rotationz":
      case "normalizer":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      case "normalize":
      case "normalizec":
        tree = DATA.tree_tag("FNm", "normalizec");
        break;
      case "trans":
      case "transpose":
        tree = DATA.tree_tag("FNm", "transpose");
        break;
      case "htrans":
      case "htranspose":
      case "hermitian":
        tree = DATA.tree_tag("FNm", "hermitian");
        break;
      case "norm":
      case "euclidean":
        tree = DATA.tree_tag("FNm", "euclidean");
        break;
      case "first":
      case "last":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      // "FNm2"
      case "gauss":
      case "gaussian":
        tree = DATA.tree_tag("FNm", "gaussian");
        break;
      // "CT"
      // JavaScript defined
      case "epsilon":
      case "min_safe_integer":
      case "max_safe_integer":
        tree = DATA.tree_num(self.entry.math.config[token_upper], 0);
        break;
      case "min_value":
      case "max_value":
      case "positive_infinity":
      case "negative_infinity":
        tree = DATA.tree_num(Number[token_upper], 0);
        break;
      // My defined
      case "eps":
        tree = DATA.tree_num(self.entry.math.config["EPSILON"], 0);
        break;
      case  "inf":
      case  "infinity":
      case "pinf":
      case "pinfinity":
        tree = DATA.tree_num(Number.POSITIVE_INFINITY, 0);
        break;
      case "ninf":
      case "ninfinity":
        tree = DATA.tree_num(Number.NEGATIVE_INFINITY, 0);
        break;
      case  "infi":
      case  "infinityi":
      case "pinfinityi":
      case "pinfi":
        tree = DATA.tree_num(0, Number.POSITIVE_INFINITY);
        break;
      case "ninfinityi":
      case "ninfi":
        tree = DATA.tree_num(0, Number.NEGATIVE_INFINITY);
        break;
      // JavaScript defined
      case "ln2":
      case "ln10":
      case "log2e":
      case "log10e":
      case "sqrt1_2":
      case "sqrt2":
      // "FN0orCT"
      // Both defined
      case "e":
      case "pi":  // pi || PI() in Excel
        tree = DATA.tree_num(Math[token_upper], 0);
        break;
      // "FN0"
      // JavaScript defined
      case "random":
      // Excel defined
      case "rand":
        tree = DATA.tree_num(Math.random(), 0);
        break;
      // "FN1"
      case "ln":
        tree = DATA.tree_tag("FN", "log");
        break;
      case "int":
        tree = DATA.tree_tag("FN", "floor");
        break;
      // JavaScript defined
      case "ceil":
      case "floor":
      case "round":
      case "log":
      // Excel defined
      case "sinh":
      case "cosh":
      case "tanh":
      case "asinh":
      case "acosh":
      case "atanh":
      case "sign":
      case "fact":
      case "degrees":
      case "radians":
      // Both defined
      case "abs":
      case "sqrt":
      case "exp":
      case "sin":
      case "cos":
      case "tan":
      case "asin":
      case "acos":
      case "atan":
      case "log10":
      // My defined
      case "sin_deg":
      case "cos_deg":
      case "tan_deg":
      case "deg_asin":
      case "deg_acos":
      case "deg_atan":
      case "deg2rad":
      case "rad2deg":
      case "ecomp":
      case "ecomplex":
      case "real":
      case "imag":
      case "imaginary":
      case "conj":
      case "conjugate":
      case "arg":
      case "argument":
      case "deg_arg":
      case "deg_argument":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN1or2"
      // Excel defined
      case "log_ex":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN2"
      case "power":
        tree = DATA.tree_tag("FN", "pow");
        break;
      // JavaScript defined
      case "pow":
      case "atan2":
      case "imul":
      // Excel defined
      case "combin":
      case "combination":
      // My defined
      case "permut":
      case "permutation":
      case "deg_atan2":
      case "atan2_ex":  // Excel spec
      case "deg_atan2_ex":
      case "comp":
      case "complex":
      case "pcomp":
      case "pcomplex":
      case "kdelta":
      case "mod":
      case "fmod":
      // "FN3or4"
      // My defined
      case "star":
      case "poly":
      case "polygon":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FNn" n&lt;256 in Excel
      // Excel defined
      case "lcm":
      case "gcd":
      // Both defined
      case "min":
      case "max":
        tree = DATA.tree_tag("FNn", token_lower);
        break;
      default:
        tree = DATA.tree_tag("REv", token);
        break;
</code></pre>
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

  </div>
</body>

</html>
