<!DOCTYPE html>

<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="description" content="[manual]Calculator">
  <meta name="author" content="online-simulator.github.io">
  <noscript>JavaScript is not enabled on browser.</noscript>
  <link rel="stylesheet" type="text/css" href="../00_common/css/common.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/color.css">
  <link rel="stylesheet" type="text/css" href="../00_common/css/size.css">
  <link rel="stylesheet" type="text/css" href="css/common.css">
  <link rel="stylesheet" type="text/css" href="css/color.css">
  <link rel="stylesheet" type="text/css" href="css/size.css">
</head>

<body>
  <div class="absolute">

<div>
<h2>[manual]Calculator</h2>
</div>

<hr>
<div>
<table>
<caption>初期表示の<a href="#span-out-com">複素数</a>演算の解はoptionの条件設定によって異なる</caption>
<thead>
  <tr>
    <th>
Associativity
    </th>
    <th>
/prior2omitted*
    </th>
    <th>
条件設定に依らない括弧明示
    </th>
    <th>
Answer
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <td colspan="2">
下記4種類
    </td>
    <td>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
    </td>
    <td>
=e^(i{t})
   </td>
  </tr>
  <tr>
    <td class="condition">
left
    </td>
    <td class="condition">
false
    </td>
    <td class="condition">
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
    </td>
    <td class="condition">
=e^(i{-pi/4})
    </td>
  </tr>
  <tr>
    <td>
right
    </td>
    <td>
false
    </td>
    <td>
e^(-i({1pi()2}/{{2i(5-{3-1})i}/(-4)}))
    </td>
    <td>
=e^(i{-4pi/3})
    </td>
  </tr>
  <tr>
    <td>
left
    </td>
    <td>
true
    </td>
    <td>
e^(-i(1pi(){2/2i}({5-3}-1){i/(-4)}))
    </td>
    <td>
=e^(i{pi/4})
    </td>
  </tr>
  <tr>
    <td>
right
    </td>
    <td>
true
    </td>
    <td>
e^(-i(1pi(){2/2i}(5-{3-1}){i/(-4)}))
    </td>
    <td>
=e^(i{3pi/4})
    </td>
  </tr>
  <tr>
    <td colspan="4">
<a href="#span-out-ope">実数演算</a>不可（0*Infinity->NaN発生）
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption>[manual]Calculatorの前置き</caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
目次
    </th>
    <td>
<span id="span-index"></span>
本manualの目次を列挙する
<br>
<br>
前提
<br>
・
<a href="#span-pre-out">
外部仕様
</a>
<br>
・
<a href="#span-pre-in">
内部仕様
</a>
<br>
・
<a href="#span-pre-ref">
参考文献
</a>
<br>
<br>
<a href="#span-out">
外部仕様
</a>
<br>
・操作UI
<br>
　・
<a href="#span-out-UI-simple">
Simple Calculator
</a>
<br>
　・
<a href="#span-out-UI-graphing">
Graphing Calculator
</a>
<br>
・
<a href="#span-out-log">
log表示仕様
</a>
<br>
・
<a href="#span-out-options">
option
</a>
<br>
・
<a href="#span-out-associativity">
associativity
</a>
<br>
・
<a href="#span-out-prec">
演算のprecedence
</a>
<br>
・
<a href="#span-out-prec-ope">
演算子のprecedence
</a>
<br>
・
<a href="#span-out-float">
浮動小数点演算
</a>
<br>
・
<a href="#span-out-epsilon">
Machine epsilon
</a>
<br>
・
<a href="#span-out-number">
Number型定数
</a>
<br>
・
<a href="#span-out-error">
誤差の扱い
</a>
<br>
・
<a href="#span-out-config">
裏設定
</a>
<br>
・
<a href="#span-out-ope">
演算仕様
</a>
<br>
・
<a href="#span-out-storage">
storage
</a>
<br>
・
<a href="#span-out-flow">
演算flow
</a>
<br>
・
<a href="#span-out-development">
開発環境
</a>
<br>
・
<a href="#span-out-system">
動作test環境
</a>
<br>
・
<a href="#span-out-requirements">
動作要件
</a>
<br>
・graph出力仕様
<br>
　・
<a href="#span-out-plot2d">
plot2d
</a>
<br>
・入力仕様
<br>
　・
<a href="#span-out-plot2d-command">
plot2d-command
</a>
<br>
　・
<a href="#span-out-comment">
comment文
</a>
<br>
　・
<a href="#span-out-command">
命令文
</a>
<br>
　・
<a href="#span-out-SR">
区切り文字
</a>
<br>
　・
<a href="#span-out-BT">
括弧
</a>
<br>
　・
<a href="#span-out-RW">
予約語
</a>
<br>
　・
<a href="#span-out-FN0">
定数
</a>
<br>
　・
<a href="#span-out-BRmo">
記号省略乗算
</a>
<br>
　・
<a href="#span-out-com">
複素数
</a>
<br>
　・
<a href="#span-out-FN">
関数
</a>
<br>
　・
<a href="#span-out-FNspecial">
特殊関数
</a>
<br>
　・
<a href="#span-out-mat">
行列
</a>
<br>
　・
<a href="#span-out-FNm0">
定数扱いの行列
</a>
<br>
　・
<a href="#span-out-FNm">
行列関数
</a>
<br>
　・
<a href="#span-out-concat">
行列操作
</a>
<br>
　・
<a href="#span-out-FNmspecial">
特殊行列関数
</a>
<br>
　・
<a href="#span-out-vars">
変数
</a>
<br>
　・
<a href="#span-out-ans">
予約変数
</a>
<br>
　・
<a href="#span-out-substitution">
変数への代入
</a>
<br>
　・
<a href="#span-out-matching">
行列要素pattern matching
</a>
<br>
　・
<a href="#span-out-eqns">
式変数
</a>
<br>
　・
<a href="#span-out-substitution-equation">
式変数への代入
</a>
<br>
　・
<a href="#span-out-FNh">
高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-switch">
switch高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-SX">
総和高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-PX">
総乗・総積高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-RX">
再帰高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-DX">
微分高階関数
</a>
<br>
　　・
<a href="#span-out-FNh-IX">
積分高階関数
</a>
<br>
　・
<a href="#span-out-FNmh">
高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-jacobian">
Jacobi高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-newtonian">
Newton高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-OX">
ODE高階行列関数
</a>
<br>
　　・
<a href="#span-out-FNmh-EX">
symbolic高階行列関数
</a>
<br>
・解法
<br>
　・
<a href="#span-out-mat-product">
行列積
</a>
<br>
　・
<a href="#span-out-fdm">
有限差分法
</a>
<br>
　　・
<a href="#span-out-fdm-differential">
微分の数値解法
</a>
<br>
　　・
<a href="#span-out-fdm-integral">
積分の数値解法
</a>
<br>
　・
<a href="#span-out-evolution">
時間発展
</a>
<br>
　・
<a href="#span-out-linear">
連立線形方程式
</a>
<br>
　・
<a href="#span-out-inverse">
逆行列
</a>
<br>
　・
<a href="#span-out-non-linear">
連立非線形方程式
</a>
<br>
　・
<a href="#span-out-series">
級数展開
</a>
<br>
　　・
<a href="#span-out-series-Taylor">
Taylor級数・Maclaurin級数
</a>
<br>
　　・
<a href="#span-out-series-Fourier">
Fourier級数
</a>
<br>
　・
<a href="#span-out-limit">
極限
</a>
<br>
・
<a href="#span-out-special">
特殊仕様
</a>
<br>
・
<a href="#span-out-application">
application
</a>
<br>
・
<a href="#span-out-remain">
残課題
</a>
<br>
<br>
<a href="#span-in">
内部仕様
</a>
<br>
・
<a href="#span-in-tree">
単位tree構造
</a>
<br>
・
<a href="#span-in-options">
option
</a>
<br>
・
<a href="#span-in-prec">
変数・関数・区切り文字・演算子のprecedence
</a>
<br>
・
<a href="#span-in-FN">
定義済みの関数・予約語
</a>
    </td>
  </tr>
  <tr>
    <th>
外部仕様の前提
    </th>
    <td>
<span id="span-pre-out"></span>
外部仕様の前提を列挙する
<br>
<br>
・論理記号||は、ORを意味する
<br>
・arrow記号->の左側に入力の演算内容、右側に出力の演算結果を示す
<br>
　入力演算内容 -> 出力演算結果
<br>
　入力演算内容case1 || 入力演算内容case2 -> 出力演算結果
<br>
・誤差のOrderをLandauの記号O(指数表記1e-16等)で表記する
<br>
・数学で言うvectorまたは行列の成分を要素と表記する
<br>
・方程式または関数式を引数に取る関数を高階関数と表記する
<br>
　この場合の引数を通常の値渡しに対して式渡しと表記する
    </td>
  </tr>
  <tr>
    <th>
内部仕様の前提
    </th>
    <td>
<span id="span-pre-in"></span>
内部仕様の前提について記述する
<br>
<br>
直接入力による構文解析で問題となるeval不使用
<br>
<br>
evalに代わる実装項目とfile名の対応関係を列挙する
<br>
・構文解析・字句解析・単位tree構造: parser.js/operation.js/DATA.js
<br>
・変数・関数・区切り文字・演算子のprecedence: operation.js
<br>
・演算unit: operation.js/unit.js
<br>
・定義済みの関数・予約語: parser.js/math.js/math_com.js/math_mat.js
<br>
　その他、built-inの関数・演算子を使用
<br>
・連立方程式の解法: solver.js
    </td>
  </tr>
  <tr>
    <th>
参考文献
    </th>
    <td>
<span id="span-pre-ref"></span>
参考文献について記述する
<br>
<br>
developer.mozilla.org/ja/docs/項目を列挙する
<br>
・浮動小数点数
<br>
・Number
<br>
<br>
en.m.wikipedia.org/wiki/項目を列挙する
<br>
・Rotation_formalisms_in_three_dimensions
<br>
<br>
ja.m.wikipedia.org/wiki/項目を列挙する
<br>
・演算子の優先順位
<br>
・IEEE_754
<br>
・誤差
<br>
・行列
<br>
・行列の乗法
<br>
・クロス積
<br>
・総和
<br>
・有限差分
<br>
・ルンゲ＝クッタ法
<br>
・ラグランジュ補間
<br>
・シンプソンの公式
<br>
・フーリエ級数
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-out">Calculatorの設定項目と入力仕様に関する外部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
内容
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Simple
<br>
Calculator
<br>
UI
    </th>
    <td>
<span id="span-out-UI-simple"></span>
Simple Calculatorの操作panelについて記述する
<br>
<br>
panel上段について記述する
<br>
・draggable checked時、drag移動有効化
<br>
・log出力欄に入力欄の演算結果のlogを表示
<br>
　文字数制限5000字以内
<br>
・入力欄に演算内容を入力
<br>
・sw checked時、push/pop入力と直接入力を切替え可
<br>
・0x checked時、16進数のa-f-buttonを追加表示
<br>
・complex checked時、虚数単位i-buttonを追加表示
<br>
・左側に0-9の数字と小数点.-buttonを表示
<br>
・右側に四則演算の演算子記号-buttonを表示
<br>
<br>
panel右側について記述する
<br>
・C-buttonは入力欄&amp;log出力欄の内容とglobal <a href="#span-out-storage">storage</a>のClear実行を確定する
<br>
　Multi-thread実行時は演算を中断する
<br>
・BS-buttonは入力欄の選択位置の1字前を消去する
<br>
・ans-buttonはlog出力欄の演算結果を入力欄に確定する
<br>
　演算結果が実数以外の場合、入力欄を消去して<a href="#span-out-ans">予約変数</a>ansのtextを挿入
<br>
・＝-buttonは入力欄の内容で演算実行を確定する
<br>
<br>
panel中段について記述する
<br>
・complex checked時、<a href="#span-out-com">複素数</a>演算を有効化
<br>
　虚数単位i-buttonを追加表示
<br>
・matrix checked時、<a href="#span-out-mat">行列</a>演算を有効化
<br>
　定義できる2項演算のみ
<br>
・演算結果の小数表記と指数表記を選択可
<br>
　小数表記: 0.1
<br>
　指数表記: 1e-1 -> 0.1
<br>
<br>
panel下段について記述する
<br>
・history欄に最新を上にして演算履歴を表示
<br>
　文字数制限5000字以内
<br>
・history欄下のlinkから演算履歴の全文をtext保存可
<br>
<br>
一般的な電卓の操作性を再現する場合、all checkbox unchecked
<br>
・遅延しないSingle-threadの<a href="#span-out-ope">実数演算</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Graphing
<br>
Calculator
<br>
UI
    </th>
    <td>
<span id="span-out-UI-graphing"></span>
Graphing Calculatorの操作panelについて記述する
<br>
<br>
panel上段について記述する
<br>
・canvas上部のlinkから描画結果のpng||svg||csvを保存可
<br>
　・pngは描画終了または中断後に保存可（逐次layer合成しない）
<br>
　・右clickまたはlong-tapによるpng保存不可（最前面は透明layer）
<br>
　・svg||csvはMulti-thread実行の場合、逐次保存可
<br>
　・png||svg出力共通でpixel座標小数点以下floorの出力桁数0~9桁を選択可
<br>
・canvasにplot2dの演算&amp;描画結果を表示
<br>
　・mouseまたはtouchによる範囲選択で拡大表示
<br>
　・single clickまたはone tapで拡大表示reset
<br>
・log出力欄にplot2dの演算&amp;描画結果のlogを表示
<br>
・plot-buttonは演算&amp;描画実行を確定する
<br>
・stop-buttonは演算&amp;描画実行を中断する・軸scaleを初期化する
<br>
・l-checkboxはlegend表示を選択
<br>
・tの入力欄に媒介変数の範囲下限t0と範囲上限t1の複素数値を入力
<br>
・媒介変数tの範囲等分割数Nを選択
<br>
・x(t)の入力欄に横軸xの演算内容をsemi-colon;区切りで入力
<br>
　・tは媒介変数で上書き可能なlocal変数
<br>
　・直下のcheckboxは軸label/value表示を選択
<br>
　・log-checkboxは対数表示を選択
<br>
　・i-checkboxは虚数表示を選択
<br>
　・x(t)のplot範囲外grid最小値~最大値を入力
<br>
・y(t)の入力欄に縦軸yの演算内容をsemi-colon;区切りで入力
<br>
　・tは媒介変数で上書き可能なlocal変数
<br>
　・直下のcheckboxは軸label/value表示を選択
<br>
　・log-checkboxは対数表示を選択
<br>
　・i-checkboxは虚数表示を選択
<br>
　・y(t)のplot範囲外grid最小値~最大値を入力
<br>
・zの入力欄にlegendのdatasetをsemi-colon;区切りで入力
<br>
　・空欄で既定の描画
<br>
　・legendのdatasetは設定値をcolon:区切りで入力
<br>
markerType:markerColor:markerSize:markerLineWidth:plotLineWidth:fillPath:
<br>
str:strFontSize
<br>
　・markerTypeはcircle||triangle||triangle2||square||diamond||cross
<br>
　・markerColorはcolor名（black等）またはHEX表記RGBA（#00000000等）
<br>
　・markerSizeはmarkerTypeの目安size
<br>
　・markerLineWidthはmarker-line-widthのpx数値
<br>
　・plotLineWidthはplot-line-widthのpx数値
<br>
　・fillPathは0以外を指定でplot線を閉じてfill
<br>
　・strはlegend-string
<br>
　・strFontSizeはlegend-stringのfont-sizeのpx数値
<br>
<br>
plot-configについて記述する
<br>
・描画canvas-size(canvas-width/canvas-height)を選択可
<br>
・bg-image-fileは任意size背景画像fileをread可
<br>
　read-cancel||image-file以外を選択で背景reset
<br>
　canvas-sizeはresetしない
<br>
　canvas-size変更で背景reset
<br>
・背景色はbg-colorの入力値優先で省略時、canvas-backgroundの選択値
<br>
　背景画像file未指定時のみ有効
<br>
・bg-colorとgrid-line-color（既定値gray）の入力欄はz-markerColor同様に色指定可
<br>
・grid-line-widthを選択可
<br>
・marker-sizeを選択可
<br>
・marker-line-widthを選択可
<br>
・plot-line-widthを選択可
<br>
・font-sizeを選択可
<br>
　軸value/legend-stringのfont-sizeは選択値
<br>
　軸label/titleのfont-sizeは選択値+2px
<br>
・各軸のgrid分割数grid-x-Ni/grid-y-Njを選択可
<br>
・余白の調整係数kx-adjを選択可
<br>
・legendのx位置を調整するlegend-kxを選択可
<br>
・legendのy位置を調整するlegend-kyを選択可
<br>
・各layerの合成方法canvas-globalCompositeOperationLayerを選択可
<br>
・各layerの背景への合成方法canvas-globalCompositeOperationを選択可
<br>
　background &lt;- grid &lt;- plotの順に背景にRGBA値を合成して出力
<br>
・titleの入力欄にgraph-titleを入力可
<br>
<br>
panel中段について記述する
<br>
・C-input-buttonは入力欄のtextを消去する
<br>
・list-vars-buttonはglobal変数の変数名listをlog出力欄に表示する
<br>
・list-eqns-buttonはglobal式変数の変数名listをlog出力欄に表示する
<br>
・plot2d(,)-buttonは入力欄の選択位置にplot2d(,)のtextを挿入する
<br>
・&lt;&lt;-buttonは入力欄の選択位置を最初に移動する
<br>
・&lt;-buttonは入力欄の選択位置を1字前に移動する
<br>
・&gt;-buttonは入力欄の選択位置を1字後に移動する
<br>
・&gt;&gt;-buttonは入力欄の選択位置を最後に移動する
<br>
・=-buttonは入力欄の内容で演算実行を確定する
<br>
・C-buttonは入力欄&amp;log出力欄の内容とglobal <a href="#span-out-storage">storage</a>のClear実行を確定する
<br>
　Multi-thread実行時は演算を中断する
<br>
・BS-buttonは入力欄の選択位置の1字前を消去する
<br>
・DEL-buttonは入力欄の選択位置の1字後を消去する
<br>
・i-buttonは入力欄の選択位置に虚数単位iのtextを挿入する
<br>
・()-buttonは入力欄の選択位置に丸括弧()のtextを挿入する
<br>
・{}-buttonは入力欄の選択位置に波括弧{}のtextを挿入する
<br>
・ans-buttonは入力欄の選択位置に<a href="#span-out-ans">予約変数</a>ansのtextを挿入する
<br>
<br>
Multi-thread実行の場合、plot-buttonと=-buttonは並列に実行可
<br>
・shared storage checked時、global <a href="#span-out-storage">storage</a>を共有
<br>
・plot-buttonによる演算はglobal storage readonly
<br>
<br>
panel下段は<a href="#span-out-UI-simple">Simple Calculator UI</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
log
<br>
表示仕様
    </th>
    <td>
<span id="span-out-log"></span>
log表示上の仕様と付随する留意事項について記述する
<br>
<br>
代入を伴わない場合
<br>
・演算後の値のみ表示する
<br>
・直前の実行文の演算結果を保持する<a href="#span-out-ans">予約変数</a>ansへの代入を明示しない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
(3*2,1) -> (6,1)
<br>
ans -> (6,1)
<br>
<br>
<a href="#span-out-substitution">変数への代入</a>の場合
<br>
・変数名と代入値を明示する
<br>
x=3*2 -> x=6
<br>
x=(3*2,3) -> x=(6,3)
<br>
<br>
<a href="#span-out-matching">行列要素pattern matching</a>による変数への代入の場合
<br>
・変数名のみ明示する
<br>
($a,$b)=(1,2) -> stored_var(a) stored_var(b) 
<br>
<br>
<a href="#span-out-substitution-equation">式変数への代入</a>の場合
<br>
・式変数名のみ明示する
<br>
eqn_x=&lt;(a*x+b=0) -> stored_eqn(eqn_x)
<br>
eqn_t=&lt;sin(omega(t)) -> stored_eqn(eqn_t)
<br>
<br>
代入の場合、<a href="#span-out-ans">予約変数</a>ansは更新されない
<br>
3*2 -> 6
<br>
ans -> 6
<br>
x=2; ($a,$b)=(1,2); eqn_x=&lt;(a*x+b=0) -> stored_eqn(eqn_x)
<br>
ans -> 6
<br>
<br>
表示仕様ではないが、以下の演算都合上の仕様について記述する
<br>
・代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は0が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をcomma,またはcolon:で区切った場合、0を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
(1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、<a href="#span-out-mat">行列</a>を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
option
    </th>
    <td>
<span id="span-out-options"></span>
選択可能なoption設定について記述する
<br>
<br>
2項演算子の結合性<a href="#span-out-associativity">associativity</a>を左右選択可
<br>
・左から順に結合する場合、左結合default
<br>
+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
-(1,1)-(2,2) || (((0,0)-(1,1))-(2,2)) -> (-3,-3)
<br>
・右から順に結合する場合、右結合
<br>
+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
-(1,1)-(2,2) || ((0,0)-((1,1)-(2,2))) -> (1,1)
<br>
・前置単項の符号は同種の2項演算子と区別しない
<br>
・符号の左側には0またはzeros行列が存在すると仮定して結合する
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>と除算のprecedenceを切替え可
<br>
・除算より記号省略乗算優先default
<br>
1/2(2) || 1/(2(2)) -> 0.25
<br>
・記号省略乗算より除算優先
<br>
1/2(2) || (1/2)(2) -> 1
<br>
<br>
Multi-thread実行を選択可
<br>
・Single-thread実行時はtimeoutまで演算を中断不可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
associativity
    </th>
    <td>
<span id="span-out-associativity"></span>
2項演算子の結合性associativityについて記述する
<br>
<br>
左結合left-associativity
<br>
+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
3^2^3 || ((3^2)^3) -> 729
<br>
3**2**3 || ((3**2)**3) -> 729
<br>
・べき乗の2項演算子は^と**を区別しない
<br>
<br>
右結合right-associativity
<br>
+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
3^2^3 || (3^(2^3)) -> 6561
<br>
3**2**3 || (3**(2**3)) -> 6561
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算の
<br>
precedence
    </th>
    <td>
<span id="span-out-prec"></span>
演算のprecedenceについて記述する
<br>
<br>
演算のprecedenceに従って実行文を解釈し、順番に演算を実行する
<br>
<br>
主要なprecedenceを優先順に列挙する
<br>
・<a href="#span-out-SR">区切り文字</a>
<br>
・<a href="#span-out-BT">括弧</a>
<br>
・<a href="#span-out-FN">関数</a>
<br>
・<a href="#span-out-prec-ope">演算子</a>
<br>
<br>
これに従う演算結果の一例を示す
<br>
max(x=1,(x):2,3)[0]2 || (max((0,1:2,3)[0]))2 || (max(0,1))2 || (1)2 -> 2
<br>
<br>
詳細は<a href="#span-in-prec">内部仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算子の
<br>
precedence
    </th>
    <td>
<span id="span-out-prec-ope"></span>
演算子のprecedenceと付随する留意事項について記述する
<br>
<br>
除算と乗算の2項演算子は区別せず、<a href="#span-out-associativity">associativity</a>に従って演算する
<br>
左結合既定時　1*2/3*4/5 || ((((1*2)/3)*4)/5) -> 0.5333333333333333
<br>
右結合選択時　1*2/3*4/5 || (1*(2/(3*(4/5)))) -> 0.8333333333333333
<br>
<br>
<a href="#span-out-BRmo">記号省略乗算</a>は除算より優先する
<br>
記号省略乗算優先既定時　1/2(2) || 1/(2(2)) -> 0.25
<br>
　　　　除算優先選択時　1/2(2) || (1/2)(2) -> 1
<br>
<br>
減算と加算の2項演算子は区別せず、<a href="#span-out-associativity">associativity</a>に従って演算する
<br>
前置単項の符号は同種の2項演算子と区別せず、<a href="#span-out-associativity">associativity</a>に従って演算する
<br>
左結合既定時　+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
右結合選択時　+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
<br>
後置の単項演算子は2項演算子より優先する
<br>
3^2! || 3^(2!) -> 9
<br>
2*3!! || 2*(3!!) -> 6
<br>
・階乗の被演算子は自然数のみ対応
<br>
・虚数単位iは後置の単項演算子とする
<br>
1/2i || 1/(2i) -> -0.5i
<br>
<br>
bit演算子を除く2項演算子は前置単項の符号より優先する
<br>
-2^2 || -(2^2) -> -4
<br>
-0xff&gt;&gt;2 || (-0xff)&gt;&gt;2 || (-255)&gt;&gt;2 -> -64
<br>
・排他的論理和XORのbit演算子は^の代わりに@を使用する
<br>
-0xff&gt;&gt;1@1 || (-0xff&gt;&gt;1)@1 || (-128)@1 -> -127
<br>
<br>
bit演算子は比較演算子・関係演算子より優先する
<br>
5&lt;2|4 || 5&lt;(2|4) || 5&lt;6 -> 1
<br>
・bit演算子は短絡評価しない
<br>
4==2|4 || 4==(2|4) || 4==6 -> 0
<br>
・bit演算子で代替可能な論理OR演算子||と論理AND演算子&amp;&amp;は未実装
<br>
・論理ORをbit ORで代替する場合、<a href="#span-out-BT">括弧</a>を明示する
<br>
・1==1 || 1==-1の一例
<br>
(1==1)|(1==-1) || 1|0 -> 1
<br>
左結合既定時　1==1|1==-1 || 1==(1|1)==-1 || (1==1)==-1 || 1==-1 -> 0
<br>
右結合選択時　1==1|1==-1 || 1==(1|1)==-1 || 1==(1==-1) || 1==0 -> 0
<br>
・同様に論理ANDをbit ANDで代替する場合、<a href="#span-out-BT">括弧</a>を明示する
<br>
・1==1 &amp;&amp; 1==-1の一例
<br>
(1==1)&amp;(1==-1) || 1&amp;0 -> 0
<br>
左結合既定時　1==1&amp;1==-1 || 1==(1&amp;1)==-1 || (1==1)==-1 || 1==-1 -> 0
<br>
右結合選択時　1==1&amp;1==-1 || 1==(1&amp;1)==-1 || 1==(1==-1) || 1==0 -> 0
<br>
・比較演算子は関係演算子より優先する
<br>
1==2>1 || 1==(2>1) || 1==1 -> 1
<br>
・bit演算子・比較演算子・関係演算子の被演算子は実数のみ対応
<br>
・被演算子に虚数を入力した場合、0と判別される
<br>
i&lt;&lt;2 || real(i)&lt;&lt;2 || 0&lt;&lt;2 -> 0
<br>
2i>i || real(2i)>real(i) || 0>0 -> 0
<br>
i==0 || real(i)==0 -> 1
<br>
・被演算子に行列を入力した場合、最終要素を取り出す
<br>
・last<a href="#span-out-FNm">行列関数</a>を使用
<br>
(1,2)==(3,2) || last(1,2)==last(3,2) || 2==2 -> 1
<br>
・代入と判別されないequal記号=は、右辺移行の2項演算子として扱う
<br>
2!=1 || 2=1 || =1-2 -> -1
<br>
・よってnot equal関係演算子は!=の代わりに&lt;&gt;を使用する
<br>
1&lt;&gt;2 -> 1
<br>
・次のような場合、関数で代替する方が間違いが少ない
<br>
2&lt;(=2) || lt(2,=2) -> 0
<br>
2&lt;=2 -> 1
<br>
<br>
比較演算子・関係演算子を代替する関数は<a href="#span-out-FN">関数入力仕様</a>参照
<br>
<br>
演算子のprecedenceを変更する場合
<br>
<a href="#span-out-BRmo">記号省略乗算</a>を許容しない場合
<br>
<a href="#span-out-config">裏設定</a>
参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
浮動小数点
<br>
演算
    </th>
    <td>
<span id="span-out-float"></span>
JavaScriptによる実数の浮動小数点演算について記述する
<br>
<br>
次のIEEE754規格の倍精度64bit2進形式の浮動小数点数を使用する
<br>
これによる演算を以降、浮動小数点演算と呼ぶ
<br>
・64bitの上位から順に3つのfield（符号部・指数部・仮数部）を持つ
<br>
10進換算の浮動小数点数
<br>
=(-1)^(符号部1bit)*pow(基数2,指数部11bit-bias)*(0||1+仮数部52bit)
<br>
・指数部・仮数部は符号無しの2進数
<br>
・指数部は符号有りを符号無しに変換する次のbiasを持つ
<br>
bias=2^(11-1)-1=1023
<br>
・pow関数(base,exponent)はbase^exponentを返却する関数
<br>
・10進換算の指数に相当する
<br>
pow(2,10) || 2^10 || 1024 -> 1.024e3
<br>
・仮数部が小数点以下の有効桁（10進換算で16~17桁）を保持する
<br>
・最上位bitから最下位bitまでの10進換算した有効数字の演算結果を示す
<br>
pow(2,-1) || 2^(-1) -> 0.5
<br>
pow(2,-2) || 2^(-2) -> 0.25
<br>
...
<br>
pow(2,-51) || 2^(-51) -> 4.440892098500626e-16
<br>
pow(2,-52) || 2^(-52) -> 2.220446049250313e-16
<br>
・この最小値O(1e-16)より小さな有効数字は保持できない
<br>
・これを丸める誤差を<a href="#span-out-epsilon">Machine epsilon</a>と呼ぶ
<br>
<br>
64bit2進形式の浮動小数点演算の挙動を示す
<br>
・16桁の小数を入力した場合、同じ
<br>
0.9999999999999999 -> 0.9999999999999999
<br>
-0.9999999999999999 -> -0.9999999999999999
<br>
・17桁の小数を入力した場合、<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
0.99999999999999999 -> 1
<br>
-0.99999999999999999 -> -1
<br>
・整数も小数同様の形式で保存される
<br>
・よって17桁以上の整数を入力した場合、小数同様に<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
9007199254740991 -> 9007199254740991
<br>
90071992547409911 -> 90071992547409900
<br>
900719925474099111 -> 900719925474099100
<br>
9007199254740991111 -> 9007199254740991000
<br>
90071992547409911111 -> 90071992547409900000
<br>
900719925474099111111 -> 900719925474099100000
<br>
9007199254740991111111 -> 9.007199254740991e+21
<br>
・1000で割って1000を掛けた場合、<a href="#span-out-epsilon">Machine epsilon</a>が生じる
<br>
9007199254740991/1000 -> 9007199254740.99
<br>
ans*1000 -> 9007199254740990
<br>
0.9999999999999999/1000 -> 0.0009999999999999998
<br>
ans*1000 -> 0.9999999999999998
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
・2の累乗倍で演算すれば仮数部の有効桁はそのまま保持される
<br>
9007199254740991/1024 -> 8796093022207.999
<br>
ans*1024 -> 9007199254740991
<br>
9007199254740991/2^100 -> 7.105427357601001e-15
<br>
ans*2^100 -> 9007199254740991
<br>
9007199254740991/2^(-100) -> 1.1417981541647678e+46
<br>
ans*2^(-100) -> 9007199254740991
<br>
0.9999999999999999/1024 -> 0.0009765624999999999
<br>
ans*1024 -> 0.9999999999999999
<br>
0.9999999999999999/2^100 -> 7.888609052210117e-31
<br>
ans*2^100 -> 0.9999999999999999
<br>
0.9999999999999999/2^(-100) -> 1.2676506002282293e+30
<br>
ans*2^(-100) -> 0.9999999999999999
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Machine
<br>
epsilon
    </th>
    <td>
<span id="span-out-epsilon"></span>
浮動小数点演算のMachine epsilonについて記述する
<br>
<br>
仮数部の最下位bitの有効数字未満を丸める相対誤差をMachine epsilonと呼ぶ
<br>
・次のepsilonで定義する
<br>
epsilon || eps || pow(2,-52) -> 2.220446049250313e-16
<br>
・test caseを列挙する
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> 1
<br>
10+10epsilon -> 10.000000000000002
<br>
10+10epsilon/2 -> 10.000000000000002
<br>
10+10epsilon/4 -> 10
<br>
100+100epsilon/4 -> 100
<br>
1000+1000epsilon/4 -> 1000
<br>
1e4+1e4epsilon/4 -> 10000
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> 0.9999999999999999
<br>
1-epsilon/4 -> 1
<br>
10-10epsilon/4 -> 10
<br>
100-100epsilon/4 -> 100
<br>
1000-1000epsilon/4 -> 1000
<br>
1e4-1e4epsilon/4 -> 10000
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Number型
<br>
定数
    </th>
    <td>
<span id="span-out-number"></span>
JavaScriptのNumber型の定数について記述する
<br>
<br>
JavaScriptのNumber型の定数は<a href="#span-out-FN0">定数</a>として定義する
<br>
・test caseを列挙する
<br>
EPSILON -> 2.220446049250313e-16
<br>
MIN_SAFE_INTEGER || -(2^53-1) -> -9007199254740991
<br>
MAX_SAFE_INTEGER || +(2^53-1) -> 9007199254740991
<br>
MIN_VALUE -> 5e-324
<br>
MIN_VALUE/2 -> 0
<br>
MIN_VALUE*(1-EPSILON) -> 5e-324
<br>
MAX_VALUE -> 1.7976931348623157e+308
<br>
MAX_VALUE*2 -> Infinity
<br>
MAX_VALUE*(1+EPSILON) -> Infinity
<br>
・Nativeの場合
<br>
Math.pow(2,Math.pow(2,10)) || 2**(2**10) -> Infinity
<br>
・<a href="#span-out-ope">実数演算</a>の場合、Nativeに同義
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> Infinity
<br>
・<a href="#span-out-com">複素数</a>演算の場合、辛うじてMAX_VALUEに近い値が得られる
<br>
pow(2,pow(2,10)) || 2**(2**10) || 2^(2^10) -> 1.7976931348622732e+308
<br>
(1+106epsilon)2^(2^10) -> 1.7976931348623155e+308
<br>
(1+107epsilon)2^(2^10) -> Infinity
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
誤差の扱い
    </th>
    <td>
<span id="span-out-error"></span>
誤差の種類とその扱いについて記述する
<br>
<br>
本manualでは大きく分けて次の2種類に分類する
<br>
・丸め誤差: 計算機での数値表現由来の誤差
<br>
　・情報落ち（絶対値の大きく異なる2つの数値の差または和を取る場合）
<br>
　・桁落ち（丸め誤差を含む同符号の2つの近い数値の差を取る場合）
<br>
・数値誤差: 数学的な近似由来の誤差
<br>
　・離散化誤差（微分・積分の無限小を有限の幅で離散化する場合）
<br>
　・打切り誤差（絶対収束する無限級数を有限の次数で打切る場合）
<br>
<br>
丸め誤差は無理数等を仮数部の有効桁に丸める際の、
<br>
近似値の真値に対する絶対誤差または相対誤差と定義する
<br>
・円周率20桁の演算結果を一例に示す
<br>
3.14159265358979323846 -> 3.141592653589793
<br>
pi -> 3.141592653589793
<br>
・円周率20桁の絶対誤差は<a href="#span-out-epsilon">Machine epsilon</a>に相当する
<br>
0.00000000000000023846 -> 2.3846e-16
<br>
epsilon -> 2.220446049250313e-16
<br>
・円周率20桁の相対誤差
<br>
0.00000000000000023846/pi -> 7.590417545938672e-17
<br>
<br>
2つの数値の減算または加算で情報落ちが発生した場合、警告文を表示する
<br>
・警告文は前置のinfoLost[実部r虚部i]とする
<br>
1+1e-16 -> infoLost[r ] 1
<br>
(1-1e-16)i -> infoLost[r ] 0.9999999999999999i
<br>
i+1e-16i -> infoLost[ i] i
<br>
1-1e-16+i-1e-16i -> infoLost[ri] 0.9999999999999999+0.9999999999999999i
<br>
1+epsilon -> 1.0000000000000002
<br>
1+epsilon/2 -> infoLost[r ] 1
<br>
1-epsilon -> 0.9999999999999998
<br>
1-epsilon/2 -> infoLost[r ] 0.9999999999999999
<br>
<br>
虚数単位iを求める<a href="#span-out-com">複素数</a>演算を一例に誤差情報の特徴を示す
<br>
(-1)^0.5 -> 6.123233995736766e-17+i
<br>
・実部に<a href="#span-out-epsilon">Machine epsilon</a>が残るため、1を加算すると情報落ちが発生する
<br>
ans+1 -> infoLost[r ] 1+i
<br>
・さらに演算を繰り返すと、誤差情報は消えることなく伝播する
<br>
ans+1 -> infoLost[r ] 2+i
<br>
ans+1 -> infoLost[r ] 3+i
<br>
ans+1 -> infoLost[r ] 4+i
<br>
ans+1 -> infoLost[r ] 5+i
<br>
・真値が0との乗算では、本来、誤差情報も消えるが、
<br>
・逐次判定しないため、誤差情報が残る
<br>
ans*0 -> infoLost[r ] 0
<br>
<br>
桁落ちは判定困難で評価にかかる演算量を見積もれないため、評価しない
<br>
・整数演算を一例に示す
<br>
・丸め誤差を含む2つの整数を作る
<br>
・commentに有効桁のbitの並びを示す
<br>
255  // 11111111 -> 255
<br>
255&gt;&gt;2  // 111111 -> 63
<br>
ans&lt;&lt;2  // 11111100 -> 252
<br>
255&gt;&gt;3  // 11111 -> 31
<br>
ans&lt;&lt;3  // 11111000 -> 248
<br>
・2つの整数の差を取ると有効桁が減少して丸め誤差が拡大する
<br>
252-248  // 100 -> 4
<br>
<br>
数値誤差は無限を有限で数学的に近似する際の、
<br>
近似値の真値に対する絶対誤差または相対誤差、あるいは、
<br>
近似解の厳密解に対する絶対誤差または相対誤差、あるいは、
<br>
数値解の解析解に対する絶対誤差または相対誤差と定義する
<br>
<br>
数値誤差は目安の解析誤差（絶対誤差）のOrderを表示する
<br>
・Order表示は後置の+O(実部+虚部i)とする
<br>
・目安の解析誤差は当てにならないため、解の二重checkが必要
<br>
<br>
f(x)=x^2のx=1+iにおける1階微分の数値解
<br>
x=1+i; _dx(=&lt;{x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・上記微分の解析解
<br>
x=1+i; 2x -> 2+2i
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
ansn=1.9999999999996223+1.9999999999996223i;
<br>
ansa=2+2i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 3.7769787297747826e-13+3.7769787297747826e-13i
<br>
・絶対誤差のEuclidian norm
<br>
norm(erra) -> 5.341454544442203e-13
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 1.8884893648873913e-13+1.8884893648873913e-13i
<br>
・相対誤差のEuclidian norm
<br>
norm(errr) -> 2.6707272722211015e-13
<br>
<br>
f(x)=x^4の積分範囲[0,1+i]における定積分の数値解
<br>
a=0; b=1+i; _ix(=&lt;{x^4},a,b) || ab=[0,1+i]; _ix(=&lt;{x^4},ab)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・解析解
<br>
a=0; b=1+i; (b^5-a^5)/5 -> -0.8000000000000003-0.8000000000000002i
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
ansn=-0.8000000053333336-0.8000000053333334i;
<br>
ansa=-0.8000000000000003-0.8000000000000002i;
<br>
dans=ansn-ansa;
<br>
・絶対誤差
<br>
erra=abs(real(dans))+abs(imag(dans))i; erra
<br>
-> 5.333333330526102e-9+5.3333332195038e-9i
<br>
・絶対誤差のEuclidian norm
<br>
norm(erra) -> 7.54247225018186e-9
<br>
・相対誤差
<br>
errr=abs(real(erra)/real(ansa))+abs(imag(erra)/imag(ansa))i; errr
<br>
-> 6.666666663157625e-9+6.666666524379749e-9i
<br>
・相対誤差のEuclidian norm
<br>
norm(errr) -> 9.428090312727323e-9
<br>
<br>
数値誤差の特徴を示す
<br>
・数値誤差を含む演算結果に対して
<br>
x=1+i; _dx(=&lt;{x^2})
<br>
-> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
・演算すると目安の解析誤差も演算される
<br>
ans*1e3 -> 1999.9999999996223+1999.9999999996223i+O(1e-9+1e-9i)
<br>
ans/1e3 -> 1.9999999999996223+1.9999999999996223i+O(1e-12+1e-12i)
<br>
ans*ans -> 7.999999999996978i+O(8e-12i)
<br>
sinh(ans) -> 0.9893582466238214i+O(1e-12i)
<br>
・解析誤差は符号がないため、減算または加算では誤差の最大値を選択する
<br>
ans+2ans -> 2.968074739871464i+O(2e-12i)
<br>
ans-2ans -> -2.968074739871464i+O(5e-12i)
<br>
・真値が0との乗算では、目安の解析誤差も消える
<br>
ans*0 -> 0
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
裏設定
    </th>
    <td>
<span id="span-out-config"></span>
UIには表示しない裏設定について記述する
<br>
<br>
browser上部のURL入力欄のGET入力で<a href="#span-in-options">内部option</a>を変更可
<br>
・html直後の?に続けて&amp;区切りでparameterを渡す
<br>
index.html?param0=value0&amp;param1=value1&amp;param2=value2&amp;...
<br>
<br>
strict-modeで実行する場合
<br>
useStrict=true
<br>
・乗算記号*省略不可
<br>
　omitted multiplication sign(*) disabled
<br>
・<a href="#span-out-eqns">式読出し</a>記号=&gt;省略不可
<br>
　omitted equation call sign(=&gt;) disabled
<br>
・<a href="#span-out-substitution-equation">式渡し</a>の括弧{}省略不可
<br>
　omitted Call-by-Equation's bracket({}) disabled
<br>
<br>
情報落ちの発生や微分・積分の数値誤差を評価しない場合
<br>
checkError=false
<br>
・演算量が数倍軽くなる
<br>
<br>
<a href="#span-out-prec-ope">演算子のprecedence</a>を変更する場合
<br>
・演算子の<a href="#span-in-prec">tag名</a>を優先順にcomma,区切りで列挙する
<br>
precedence=
<br>
URi,URf,BRp,BRr,BRmo,BRdm,BRsa,BRbs,BRba,BRbx,BRbo,BRcn,BRrl
<br>
・別途、乗算記号*の省略を許容しない場合、tag名BRmoを削除する
<br>
　その場合、treeを全走査判定する無駄な演算量が減る
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算仕様
    </th>
    <td>
<span id="span-out-ope"></span>
演算量または演算速度に関係する演算仕様の概要について記述する
<br>
<br>
UI設定によって対応する用途を4種類示す
<br>
・有次元の<a href="#span-out-com">複素数</a>の<a href="#span-out-mat">行列</a>演算（complex&amp;matrix checked）
<br>
・有次元の実数の<a href="#span-out-mat">行列</a>演算（only matrix checked）
<br>
・無次元の<a href="#span-out-com">複素数</a>演算（only complex checked）
<br>
・無次元の実数演算（complex&amp;matrix unchecked）
<br>
<br>
次の2次の正方行列の積を一例に
<br>
(0,0:0,1+i)(1,0:0,1)
<br>
・上記の用途順に演算結果のみ示す
<br>
-> (0,0:0,1+i)
<br>
-> (0,0:0,1)
<br>
-> 1+i
<br>
-> 1
<br>
<br>
用途によらず、行列要素は左から右にすべて演算する
<br>
・行vectorをcolon:区切りで列挙
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
・列vectorをcolon:区切りで列挙
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
<br>
<br>
その上で、無次元の演算の場合、行列の最終要素を取り出して演算する
<br>
(x=1,x=2x:x=2x,x)1 || {x=1,x=2x:x=2x,x}1 || (0,0:0,4)1 || (4)*1 -> 4
<br>
・よって行列の積は次の乗算に変換される
<br>
(x=1,x=2x:x=2x,x){x=1,x=2x:x=2x,x} || (4)*{4} -> 16
<br>
<br>
以上より、n次の正方行列の積の演算量を用途順に概算して示す
<br>
4*(n*n)*(n*n)
<br>
(n*n)*(n*n)
<br>
4
<br>
1
<br>
<br>
演算単位の数値dataは内部で<a href="#span-out-com">複素数</a>の<a href="#span-out-mat">行列</a>として扱う
<br>
・これより用途をseamlessに切替えて上記の演算量を調整する
<br>
<br>
合わせて共通化する仕様について記述する
<br>
<br>
<a href="#span-out-FN">関数</a>の引数vector
<br>
・行列の最終行vectorを左から順に参照
<br>
max(1,2,3:-1,-2,-3) || max(-1,-2,-3) -> -1
<br>
sqrt(1,2,3:4,5,6) || sqrt(4,5,6) || sqrt(4) -> 2
<br>
<br>
定義できない<a href="#span-out-mat">行列</a>演算
<br>
・定義できない<a href="#span-out-mat-product">行列積</a>の場合、error終了
<br>
(1,2)(1,2) -> [MyErr]Invalid matrix operation
<br>
・行列sizeの一致しない差と和の場合、error終了
<br>
(1,2:3,4)-(-1) -> [MyErr]Invalid matrix operation
<br>
・無次元の演算の場合、行列の最終要素を演算・無次元化するのと同様に
<br>
(1,3)+(1) || (3)+(1) -> 4
<br>
・剰余等の演算を実行した場合、行列の最終要素を参照して演算・無次元化
<br>
(1,2)%2 || (2)%2 -> 0
<br>
<br>
詳細は<a href="#span-in-tree">単位tree構造</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
storage
    </th>
    <td>
<span id="span-out-storage"></span>
storageについて記述する
<br>
<br>
storageは<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を保存するobjectで次の3種類
<br>
・local storage
<br>
・global storage
<br>
・local buffer
<br>
<br>
local storage
<br>
・演算実行確定1回の各実行文の<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を保存する
<br>
・保存された変数をlocal変数と呼ぶ
<br>
・保存された式変数をlocal式変数と呼ぶ
<br>
<br>
global storage
<br>
・演算実行確定1回毎に返される<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>を累積保存する
<br>
・保存された変数をglobal変数と呼ぶ
<br>
・保存された式変数をglobal式変数と呼ぶ
<br>
<br>
local buffer
<br>
・local storageを一時的に記憶する
<br>
<br>
演算実行確定1回のstorageのflowを示す
<br>
・演算実行開始　global storage　⇒　local storageに復帰
<br>
・演算実行途中　local storageをread/write　⇔　local buffer
<br>
・演算実行終了　local storage　⇒　global storageに保存
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
演算flow
    </th>
    <td>
<span id="span-out-flow"></span>
演算実行確定1回の演算flowについて記述する
<br>
<br>
次の3関数による演算flowを示す
<br>
main関数　⇔　parse関数　⇔　operation関数
<br>
・main関数
<br>
　・入力dataを作ってparse関数に渡す
<br>
　・出力dataから演算結果を外部に表示する
<br>
・parse関数
<br>
　・入力dataから実行文を作ってoperation関数に渡す
<br>
　・演算結果から出力dataを作ってmain関数に返す
<br>
・operation関数
<br>
　・実行文から演算結果を作ってparse関数に返す
<br>
<br>
parse関数とoperation関数の役割分担を示す
<br>
<br>
parse関数の役割はcompiler
<br>
・<a href="#span-out-BT">括弧</a>のnestingを解析し、深さ方向にtree化する
<br>
・入力dataの字句を解析してtagを付ける
<br>
・逐次、入力dataを実行文のtreeに置換する
<br>
<br>
operation関数の役割はinterpreter
<br>
・<a href="#span-out-prec">演算のprecedence</a>に従って実行文を実行する
<br>
・逐次、実行文のtreeを演算結果に置換する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
開発環境
    </th>
    <td>
<span id="span-out-development"></span>
さらに、JavaScriptのinterpreterを介してbrowser上で演算を実行する
<br>
・よってNativeに近い言語で直接記述するよりthroughputは圧倒的に低いが、
<br>
・Google Chrome Developer Toolsによるcross-platform開発の容易さと、
<br>
・Github Pagesでのonline-test管理の容易さを選択
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
動作test環境
    </th>
    <td>
<span id="span-out-system"></span>
browserの動作test環境について記述する
<br>
<br>
offline/online-test環境
<br>
・latest Chrome
<br>
・latest Edge
<br>
・Internet Explorer 11（以降、IEと省略する）
<br>
・IE以外の互換性は高いため、Chrome DevTools-emulatorで動作確認
<br>
<br>
only online-test環境
<br>
・latest Amazon Silk
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
動作要件
    </th>
    <td>
<span id="span-out-requirements"></span>
browserの動作要件を列挙する
<br>
・ECMAScript5対応
<br>
・HTML5対応
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
仕様
    </th>
    <td>
<span id="span-out-plot2d"></span>
Graphing Calculator's plot2dの仕様について記述する
<br>
<br>
plot2dの演算は高速化のため、誤差を評価しない・logを作らない
<br>
・誤差を含めたlogを作る場合、別途、通常の演算が必要
<br>
<br>
csv/history出力のplot2d-command-logとoptions-logについて記述する
<br>
・整合性保証のため、plot2dの演算実行確定時のlogを表示する
<br>
・よって演算終了後に変更した現在のzをlogに残す場合、再演算が必要
<br>
<br>
semi-colon;区切りで行列の最終要素の数値をgraphに描画する
<br>
・命令文や代入文のみを各軸に入力した場合、0を返して描画する
<br>
・処理を列挙する場合、最終列挙の要素が最終要素とは限らない点、留意が必要
<br>
詳細はlast<a href="#span-out-FNm">行列関数</a>参照
<br>
<br>
tの範囲下限t0と範囲上限t1のlocal <a href="#span-out-storage">storage</a>は独立
<br>
・global <a href="#span-out-storage">storage</a>をreadonlyで共有する場合、shared storage checked
<br>
<br>
x軸とy軸のlocal <a href="#span-out-storage">storage</a>はx軸優先で共通
<br>
・global <a href="#span-out-storage">storage</a>をreadonlyで共有する場合、shared storage checked
<br>
<br>
tの演算をSingle-threadで実行後、x/yの演算をMulti-threadで実行
<br>
・tの演算中はstop中断不可
<br>
<br>
svg出力機能について記述する
<br>
・layer合成無効（source-overのみ）
<br>
・既定markerのdestination-outは背景色source-overで代替（透明の場合、白）
<br>
・canvas描画処理の継承互換性のため、group化等による最適化はしない
<br>
・z入力欄から入力不可のsemi-colon;等の特殊文字を直接file編集可
<br>
・その他、font-family等も直接file編集可
<br>
<br>
png||svg出力のbrowser間の相違について記述する
<br>
・browserによってtext幅のNative測定値が異なる
<br>
　var text = "x=t,x;x";
<br>
　ctx.font = "10px sans-serif";
<br>
　var w = ctx.measureText(text).width;
<br>
IE: w -> 29
<br>
Edge/Chrome: w -> 36.2841796875
<br>
　ctx.font = "12px sans-serif";
<br>
　var w = ctx.measureText(text).width;
<br>
IE: w -> 35
<br>
Edge/Chrome: w -> 43.541015625
<br>
・IEから出力したpngとsvgの表示が一致しない（Edge/Chromeは一致）
<br>
・IEはJScript-originの問題で真値の約0.8倍にtext幅を過小評価の可能性
<br>
　IEの開発終了とsupport縮小に伴い、補正係数導入等の一時的な対策はしない
<br>
・textを出力しなければbrowser間で大差はない
<br>
<br>
続けて演算結果の相違について記述する
<br>
・IEのJScript-originとそれ以外のJavaScriptで<a href="#span-out-epsilon">Machine epsilon</a>程度の相違がある
<br>
・NativeのMath.sin関数を一例に示す
<br>
IE: sin(5) -> -0.9589242746631384
<br>
else: sin(5) -> -0.9589242746631385
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
plot2d
<br>
-command
<br>
入力仕様
    </th>
    <td>
<span id="span-out-plot2d-command"></span>
Graphing Calculator's plot2d-commandの入力仕様について記述する
<br>
<br>
以下2種類のplot2d-commandは操作panel中段のtext入力欄から実行する
<br>
plot2d('t0','t1','xt','yt')
<br>
plot2d(xt,yt)
<br>
・plot2d-command最優先で他の実行文は破棄other sentences ignored
<br>
・plot-button実行中の割込み不可
<br>
<br>
csv/historyに記録されるlogからplot2d-commandを実行する場合
<br>
・plot2d-from-logのformatを次に示す
<br>
plot2d('t0','t1','xt','yt')
<br>
plot2d('t0','t1','xt','yt','N')
<br>
plot2d('t0','t1','xt','yt','N','z')
<br>
・Ver.2.25.12以降、第5引数Nにsingle quotation markを付与
<br>
・Ver.2.27.14以降、第6引数z&amp;comment入力に対応
<br>
・plot2d-commandの一例を示す
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;')
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;','50')
<br>
plot2d('-5','5','t;','SND=&lt;exp(-t^2/2)/sqrt(2pi),SND;','50','circle')
<br>
・N入力値はselect値が存在する場合のみ有効
<br>
・comment入力の一例を示す
<br>
・tokenを区切るsingle quotation markは使用不可
<br>
plot2d(
<br>
'1e-3(1+i)/*t0*/','1e2(1+i)/*t1*/',
<br>
'x=t,x/*xt*/;','x;2x;3x;4x;5x;6x;7x;8x;9x;10x/*yt*/;',
<br>
'10',
<br>
'circle/*marker*/;'
<br>
)
<br>
<br>
時系列dataからplot2d-commandを実行する場合
<br>
・plot2d-from-arrのformatを次に示す
<br>
plot2d
<br>
(
<br>
x(t)変数名symbol,
<br>
y(t)変数名symbol
<br>
)
<br>
・xt,ytの場合
<br>
plot2d(xt,yt)
<br>
・circleを描く時系列data作成の一例を示す
<br>
・<a href="#span-out-eqns">式変数</a>の式読出し記号=&gt;を省略する場合、変数名の重複に留意する
<br>
storage cleared
<br>
t0=0;
<br>
t1=2pi;
<br>
tn=&lt;t0+(t1-t0)n/N;
<br>
N=10;
<br>
/*init=&lt;last{xt=zeros(N+1,1),yt=zeros(N+1,1)};*/
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
stepn=&lt;last{xt[n]=cos(tn),yt[n]=sin(tn)};
<br>
evolutionN=&lt;_sn(=&lt;stepn,0,N);
<br>
init; evolutionN; xt,yt ->
<br>
・<a href="#span-out-config">strict-mode</a>に対応する場合
<br>
storage cleared
<br>
t0=0;
<br>
t1=2*pi;
<br>
tn=&lt;t0+(t1-t0)*n/N;
<br>
N=10;
<br>
/*init=&lt;last{xt=zeros(N+1,1),yt=zeros(N+1,1)};*/
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
stepn=&lt;last{xt[n]=cos(tn=&gt;tn),yt[n]=sin(tn)};
<br>
evolutionN=&lt;_sn(=&lt;{stepn=&gt;},0,N);
<br>
init=&gt;; evolutionN=&gt;; xt,yt ->
<br>
(
<br>
1,0:
<br>
0.8090169943749475,0.5877852522924731:
<br>
0.30901699437494745,0.9510565162951535:
<br>
-0.3090169943749471,0.9510565162951536:
<br>
-0.8090169943749473,0.5877852522924732:
<br>
-1,1.2246467991473532e-16:
<br>
-0.8090169943749478,-0.5877852522924727:
<br>
-0.30901699437494756,-0.9510565162951535:
<br>
0.30901699437494723,-0.9510565162951536:
<br>
0.8090169943749473,-0.5877852522924734:
<br>
1,-2.4492935982947064e-16
<br>
)
<br>
<br>
複数の時系列dataを作成してplot2d-commandを実行する一例を以下に示す
<br>
・上記xt,ytの元dataを結合して作る場合
<br>
xt4=(xt*0,xt*1,xt*2,xt*3); yt4=(yt*0,yt*1,yt*2,yt*3);
<br>
plot2d(xt4,yt4)
<br>
・同義
<br>
xt4=xt*(0,1,2,3); xt4 ->
<br>
(
<br>
0,1,2,3:
<br>
0,0.8090169943749475,1.618033988749895,2.4270509831248424:
<br>
0,0.30901699437494745,0.6180339887498949,0.9270509831248424:
<br>
0,-0.3090169943749471,-0.6180339887498942,-0.9270509831248414:
<br>
0,-0.8090169943749473,-1.6180339887498947,-2.427050983124842:
<br>
0,-1,-2,-3:
<br>
0,-0.8090169943749478,-1.6180339887498956,-2.4270509831248432:
<br>
0,-0.30901699437494756,-0.6180339887498951,-0.9270509831248427:
<br>
0,0.30901699437494723,0.6180339887498945,0.9270509831248417:
<br>
0,0.8090169943749473,1.6180339887498947,2.427050983124842:
<br>
0,1,2,3
<br>
)
<br>
yt4=yt*(0,1,2,3); yt4 ->
<br>
(
<br>
0,0,0,0:
<br>
0,0.5877852522924731,1.1755705045849463,1.7633557568774194:
<br>
0,0.9510565162951535,1.902113032590307,2.8531695488854605:
<br>
0,0.9510565162951536,1.9021130325903073,2.853169548885461:
<br>
0,0.5877852522924732,1.1755705045849465,1.7633557568774196:
<br>
0,1.2246467991473532e-16,2.4492935982947064e-16,3.6739403974420594e-16:
<br>
0,-0.5877852522924727,-1.1755705045849454,-1.763355756877418:
<br>
0,-0.9510565162951535,-1.902113032590307,-2.8531695488854605:
<br>
0,-0.9510565162951536,-1.9021130325903073,-2.853169548885461:
<br>
0,-0.5877852522924734,-1.1755705045849467,-1.76335575687742:
<br>
0,-2.4492935982947064e-16,-4.898587196589413e-16,-7.347880794884119e-16
<br>
)
<br>
・case違いの演算を繰り返してxt,ytを作り直す場合
<br>
・<a href="#span-out-config">strict-mode</a>に対応する場合
<br>
storage cleared
<br>
t0=0;
<br>
t1=2*pi;
<br>
tn=&lt;t0+(t1-t0)*n/N;
<br>
N=10;
<br>
M=3;
<br>
init=&lt;last{xt=zeros(N+1,M+1),yt=zeros(N+1,M+1)};
<br>
stepnm=&lt;last{xt[n][m]=cos(tn=&gt;tn)*m,yt[n][m]=sin(tn)*m};
<br>
evolutionN=&lt;_sn(=&lt;{casesM=&gt;},0,N);
<br>
casesM=&lt;_sm(=&lt;{stepnm=&gt;},0,M);
<br>
init=&gt;; evolutionN=&gt;;
<br>
xt4=xt; xt4 ->
<br>
(
<br>
0,1,2,3:
<br>
0,0.8090169943749475,1.618033988749895,2.4270509831248424:
<br>
0,0.30901699437494745,0.6180339887498949,0.9270509831248424:
<br>
0,-0.3090169943749471,-0.6180339887498942,-0.9270509831248414:
<br>
0,-0.8090169943749473,-1.6180339887498947,-2.427050983124842:
<br>
0,-1,-2,-3:
<br>
0,-0.8090169943749478,-1.6180339887498956,-2.4270509831248432:
<br>
0,-0.30901699437494756,-0.6180339887498951,-0.9270509831248427:
<br>
0,0.30901699437494723,0.6180339887498945,0.9270509831248417:
<br>
0,0.8090169943749473,1.6180339887498947,2.427050983124842:
<br>
0,1,2,3
<br>
)
<br>
yt4=yt; yt4 ->
<br>
(
<br>
0,0,0,0:
<br>
0,0.5877852522924731,1.1755705045849463,1.7633557568774194:
<br>
0,0.9510565162951535,1.902113032590307,2.8531695488854605:
<br>
0,0.9510565162951536,1.9021130325903073,2.853169548885461:
<br>
0,0.5877852522924732,1.1755705045849465,1.7633557568774196:
<br>
0,1.2246467991473532e-16,2.4492935982947064e-16,3.6739403974420594e-16:
<br>
0,-0.5877852522924727,-1.1755705045849454,-1.763355756877418:
<br>
0,-0.9510565162951535,-1.902113032590307,-2.8531695488854605:
<br>
0,-0.9510565162951536,-1.9021130325903073,-2.853169548885461:
<br>
0,-0.5877852522924734,-1.1755705045849467,-1.76335575687742:
<br>
0,-2.4492935982947064e-16,-4.898587196589413e-16,-7.347880794884119e-16
<br>
)
<br>
<br>
<a href="#span-out-evolution">時間発展の解法</a>を使用して時系列dataを作成する一例を以下に示す
<br>
・total時間積分回数がplot2d-buttonのN回に対して1回で済むため、圧倒的に速い
<br>
・時間刻みを次の<a href="#span-out-eqns">式変数</a>dtnで定義してevolutionNで時間発展する
<br>
dtn=&lt;switch(n&lt;=0,0:1,dt);
<br>
・<a href="#span-out-config">strict-mode</a>に対応する場合
<br>
storage cleared
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v};
<br>
step=&lt;{x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,tdummy=0,dtn=&gt;)};
<br>
/*{$z_x,$z_v}=x_initial=&gt;;*/
<br>
t0=0;
<br>
t1=5;
<br>
dtn=&lt;switch(n&lt;=0,0:1,dt);
<br>
N=round((t1-t0)/dt);
<br>
init=&lt;last{xt=vectorc(N+1),yt=vectorc(N+1)};
<br>
stepn=&lt;last{step=&gt;,xt[n]=real(z_x),yt[n]=imag(z_x)};
<br>
evolutionN=&lt;_sn(=&lt;{stepn=&gt;},0,N);
<br>
init=&gt;; evolutionN=&gt;; xt,yt ->
<br>
・<a href="#span-out-evolution">時間発展の解法</a>に示す位置z_x=xt+yt*iの近似解に一致する
<br>
(
<br>
0,0:
<br>
7.864583333333332+O(6e-2),6.818229166666667:
<br>
12.636583116319443+O(6e-2),9.028508843315972:
<br>
15.532093401308412+O(6e-2),8.442819167949535:
<br>
17.289004589856408+O(6e-2),6.160616838886046:
<br>
18.355047055824333+O(6e-2),2.849020113178252:
<br>
19.001890531268412+O(6e-2),-1.0871831084100707:
<br>
19.394376285899845+O(6e-2),-5.402379334009235:
<br>
19.63252519430902+O(6e-2),-9.947537460479563:
<br>
19.77702700592188+O(6e-2),-14.6322297611764:
<br>
19.86470649057239+O(6e-2),-19.40158732904714
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
comment文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-comment"></span>
comment文の入力仕様と付随する留意事項について記述する
<br>
<br>
次のcomment文2種類は実行文に含まれない
<br>
// line comment
<br>
/* block comment */
<br>
<br>
test caseを示す
<br>
x=-0xff; /*x:16進数値*/ x&gt;&gt;3 // 右shift3回
<br>
-> -32
<br>
・parse後の実行文を示す
<br>
x=-0xff; x&gt;&gt;3 -> -32
<br>
・以下の演算に同義
<br>
x=-255; floor(x/(2^3)) -> -32
<br>
x=-255; int(x/(2^3)) -> -32
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
命令文
<br>
入力仕様
    </th>
    <td>
<span id="span-out-command"></span>
命令文の入力仕様と付随する留意事項について記述する
<br>
<br>
命令文は上位の実行文に相当する
<br>
・semi-colon;以外で区切った場合、error終了
<br>
clear || clear; -> local storage cleared
<br>
clear, || clear: -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-BT">括弧</a>の中で呼出した場合、error終了
<br>
(clear) || {clear} -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-substitution">変数への代入</a>不可
<br>
clear; x=clear -> [MyErr]Invalid clear called
<br>
・<a href="#span-out-substitution-equation">式変数への代入</a>不可
<br>
f=&lt;clear -> [MyErr]Invalid clear called
<br>
<br>
命令文を以下に示す
<br>
<br>
clear
<br>
・呼出し時点までのlocal <a href="#span-out-storage">storage</a>をclearする
<br>
x=3; x -> 3
<br>
clear -> local storage cleared
<br>
x -> 3
<br>
clear; x -> [MyErr]Invalid REv(x)
<br>
x -> 3
<br>
clear; ans -> [MyErr]Invalid REv(ans)
<br>
ans -> 3
<br>
・続けてglobal <a href="#span-out-storage">storage</a>をclearする場合
<br>
Clear実行確定 ->
<br>
storage cleared
<br>
x -> [MyErr]Invalid REv(x)
<br>
ans -> [MyErr]Invalid REv(ans)
<br>
・global <a href="#span-out-storage">storage</a>に一切の変数を残さない場合
<br>
x=3; y=3x; y; clear -> local storage cleared
<br>
x -> [MyErr]Invalid REv(x)
<br>
y -> [MyErr]Invalid REv(y)
<br>
ans -> [MyErr]Invalid REv(ans)
<br>
<br>
store
<br>
・呼出し時点までのlocal <a href="#span-out-storage">storage</a>をlocal <a href="#span-out-storage">buffer</a>に保存する
<br>
・元objectを新規objectに複製する
<br>
restore
<br>
・local <a href="#span-out-storage">buffer</a>に保存されたlocal <a href="#span-out-storage">storage</a>を復帰する
<br>
・複製した新規objectをそのまま復帰する（元objectの参照を切る仕様）
<br>
clear; x=2; store; x=3; restore; x -> 2
<br>
clear; x=2; store; clear; restore; x -> 2
<br>
・store~restore間に新規に定義された<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は参照不可
<br>
clear; x=2; store; y=3; clear; restore; x+y -> [MyErr]Invalid binary operation
<br>
clear; x=2; store; y=3; store; clear; restore; x+y -> 5
<br>
・演算実行確定1回毎にlocal <a href="#span-out-storage">buffer</a>は消去される
<br>
storage cleared
<br>
restore -> null buffer
<br>
x=2; store -> local storage stored
<br>
restore -> null buffer
<br>
restore; x -> [MyErr]Invalid REv(x)
<br>
<br>
stop
<br>
・呼出し時点以降の演算を中断する
<br>
x=3; 3x; stop; x -> operation stopped
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
区切り文字
<br>
入力仕様
    </th>
    <td>
<span id="span-out-SR"></span>
区切り文字の入力仕様と付随する留意事項について記述する
<br>
<br>
区切り文字を優先順に列挙する
<br>
・各実行文を区切るsemi-colon;
<br>
実行文; 実行文; ...
<br>
・<a href="#span-out-mat">行列</a>の各vectorを区切るcolon:
<br>
vector: vector: ...
<br>
・vectorの各要素または<a href="#span-out-FN">関数</a>の引数を区切るcomma,
<br>
要素, 要素, ... || 引数, 引数, ...
<br>
<br>
区切り文字は2項の<a href="#span-out-associativity">associativity</a>や深さとは関係なく左から順に演算する
<br>
・区切り文字のprecedenceは最優先
<br>
x=3,(x=9),2x -> (0,0,18)
<br>
x -> 9
<br>
・よって<a href="#span-out-vars">変数</a>は実行直前ではなく列挙直前の代入値を参照する
<br>
x=3; x=2:3x -> (0:6)
<br>
<br>
区切り文字はNativeのcomma演算子同様に働くが、<a href="#span-out-mat">行列</a>の次元は残る
<br>
(x=1,x=2x:x=2x,x) -> (0,0:0,4)
<br>
{x=1,x=2x:x=2x,x} -> (0,0:0,4)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
括弧
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BT"></span>
括弧の入力仕様と付随する留意事項について記述する
<br>
<br>
実行文の一部を括る括弧は3種類使用可
<br>
<br>
優先順に列挙する
<br>
・波括弧{}
<br>
・丸括弧()
<br>
・角括弧[]
<br>
<br>
括弧は<a href="#span-out-SR">区切り文字</a>に含める
<br>
・実行文を区切るsemi-colon;を括弧の中で使用した場合、error終了
<br>
(;) -> [MyErr]Invalid {([])}
<br>
・対応関係が取れない括弧のnestingが見つかった場合、error終了
<br>
[(0]) -> [MyErr]Invalid {([])}
<br>
<br>
丸括弧()は行vectorをcolon:区切りで列挙する
<br>
・角括弧[]は丸括弧()に準ずる
<br>
(行vector: 行vector: ...) || [行vector: 行vector: ...]
<br>
<br>
波括弧{}は列vectorをcolon:区切りで列挙する
<br>
{列vector: 列vector: ...}
<br>
<br>
<a href="#span-out-ope">無次元</a>の演算の場合、要素を括る丸括弧()と波括弧{}は区別しない
<br>
・列挙しなければ括弧の種類は区別しない
<br>
<br>
<a href="#span-out-ope">有次元</a>の場合、vectorを括る丸括弧()と波括弧{}は互いに転置の関係
<br>
(1,2:3,4) -> (1,2:3,4)
<br>
{1,2:3,4} -> (1,3:2,4)
<br>
・転置の<a href="#span-out-FNm">行列関数</a>を使用
<br>
transpose({1,2:3,4}) || trans({1,2:3,4}) -> (1,2:3,4)
<br>
<br>
<a href="#span-out-FN">関数</a>の引数を括る括弧は丸括弧()で統一する
<br>
・波括弧{}を使用した場合、引数も転置される
<br>
trans(1,2:3,4) -> (1,3:2,4)
<br>
trans{1,2:3,4} -> (1,2:3,4)
<br>
<br>
1重列挙の場合、外側の括弧は上記の結合性が存在しない
<br>
(1,2) || {(1,2)} || ({(1,2)}) || {({(1,2)})} -> (1,2)
<br>
{1,2} || ({1,2}) || {({1,2})} || ({({1,2})}) -> (1:2)
<br>
・よって上流で列挙しない限り、<a href="#span-out-vars">変数</a>・<a href="#span-out-eqns">式変数</a>は任意の括弧で括れる
<br>
x=(1,2); y={1,2}; x*y || (x)(y) || {x}{y} || ({x}{y}) || {{x}{y}}  -> 5
<br>
x=&lt;(1,2); y=&lt;{1,2}; x*y || (x)(y) || {x}{y} || ({x}{y}) || {{x}{y}}  -> 5
<br>
<br>
2重列挙の場合
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
x=(1,2); y={3,4}; (x,y) -> (1,2,3:0,0,4)
<br>
x=(1,2); y={3,4}; (x:y) -> (1,2:3:4)
<br>
x=(1,2); y={3,4}; {x,y} -> (1,2:3:4)
<br>
x=(1,2); y={3,4}; {x:y} -> (1,2,3:0,0,4)
<br>
・<a href="#span-out-eqns">式変数</a>も同様
<br>
x=&lt;(1,2); y=&lt;{3,4}; (x,y) -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; (x:y) -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; {x,y} -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; {x:y} -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;(x,y); z -> (1,2,3:0,0,4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;(x:y); z -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;{x,y}; z -> (1,2:3:4)
<br>
x=&lt;(1,2); y=&lt;{3,4}; z=&lt;{x:y}; z -> (1,2,3:0,0,4)
<br>
・抜け要素は0として演算する
<br>
trans(trans((1,2:3:4))) -> (1,2:3,0:4,0)
<br>
trans(trans{(1,2:3:4)}) -> (1,2:3,0:4,0)
<br>
trans{trans{(1,2:3:4)}} -> (1,2:3,0:4,0)
<br>
x=(1,2); y={3,4}; trans(trans((x:y))) -> (1,2:3,0:4,0)
<br>
<br>
括弧無しで要素を列挙した場合、行vector扱いの丸括弧()で括られる
<br>
1,2,3 -> (1,2,3)
<br>
<br>
演算結果のlog表示は丸括弧()
<br>
{1,2:3,4} || [1,3:2,4] -> (1,3:2,4)
<br>
<br>
角括弧[]は直前の行列要素の参照位置を指定する
<br>
・よって括弧の中で最下位のprecedence
<br>
・唯一の右結合（右から左を参照）
<br>
A=(1,2:3,4); A[0][0] || (1,2:3,4)[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] || (1,2:3,4)[1][1] -> 4
<br>
・複数の要素を持つ場合のみ、行列として使用可
<br>
A=(1,2:3,4); A[1,2:3,4] -> (7,10:15,22)
<br>
[1,2][0][0] -> 1
<br>
[1,2:3,4][0] -> (1,2)
<br>
[1,2:3,4][1] -> (3,4)
<br>
<br>
詳細は<a href="#span-out-concat">行列操作入力仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
予約語
<br>
入力仕様
    </th>
    <td>
<span id="span-out-RW"></span>
予約語の入力仕様と付随する留意事項について記述する
<br>
<br>
予約語の種類を列挙する
<br>
・Graphing Calculator's <a href="#span-out-plot2d-command">plot2d-command</a>
<br>
・<a href="#span-out-comment">comment文</a>
<br>
・<a href="#span-out-command">命令文</a>
<br>
・<a href="#span-out-SR">区切り文字</a>・<a href="#span-out-BT">括弧</a>
<br>
・<a href="#span-out-FN0">定数</a>含む<a href="#span-out-FN">関数</a>名
<br>
・<a href="#span-out-prec-ope">演算子</a>記号
<br>
・被演算子記号
<br>
　・<a href="#span-out-ans">予約変数</a>
<br>
　・10進数値小数
<br>
　・10進数値指数
<br>
　・16進数値0x
<br>
<br>
予約語の規則を列挙する
<br>
・大文字・小文字・全角・半角を区別しない
<br>
・<a href="#span-out-vars">式変数</a>名・<a href="#span-out-eqns">式変数</a>名に使用不可
<br>
stop=3 -> [MyErr]Invalid stop called
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
max=&lt;3 -> [MyErr]Invalid BTe([object Object])
<br>
ＭＡＸ=3 -> [MyErr]Invalid ans isFound
<br>
<br>
予約語の一覧は<a href="#span-in-FN">内部仕様</a>参照
   </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN0"></span>
定数の入力仕様と付随する留意事項について記述する
<br>
<br>
定数は引数<a href="#span-out-BT">括弧</a>無しで厳密には<a href="#span-out-FN">関数</a>に含めない
<br>
・実行文を作るparse段階で数値に変換する
<br>
・Excel同様に空括弧()付を許容する
<br>
・空括弧()はparse段階で除去する
<br>
<br>
関数を使用して円周率piとNapier数eを一例に示す
<br>
PI() || pi || 2acos(0) || 2asin(1) || 4atan(1) -> 3.141592653589793
<br>
E() || e || e^1 || exp(1) ||  -> 2.718281828459045
<br>
<br>
eは指数と区別するために空括弧()を付ける方が間違いが少ない
<br>
2e-1 || 2E-1 -> 0.2
<br>
2e()-1 || 2E()-1 -> 4.43656365691809
<br>
・<a href="#span-out-BRmo">記号省略乗算</a>を許容した弊害への対策
<br>
<br>
定数に限らず、空括弧()はparse段階ですべて除去する
<br>
()3()3() || 3*3 -> 9
<br>
()3()/()3() || 3/3 -> 1
<br>
() ->
<br>
(()) -> 0
<br>
(({})) -> 0
<br>
・乱数
<br>
random() || random || rand -> 0.7479324154774045
<br>
・本来、<a href="#span-out-FN">関数</a>の呼出し時に空括弧を含めて判別するが、
<br>
・定数の引数<a href="#span-out-BT">括弧</a>の有無と<a href="#span-out-BRmo">記号省略乗算</a>を同時に許容した弊害への対策
<br>
<br>
次の場合、代入errorとは判別されず、右辺に移項して演算される
<br>
pi=3 || pi()=3 || =3-pi -> -0.14159265358979312
<br>
・parse後の実行文を示す
<br>
3.141592653589793=3 || =3-3.141592653589793 -> -0.14159265358979312
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
記号省略乗算
<br>
入力仕様
    </th>
    <td>
<span id="span-out-BRmo"></span>
記号省略乗算入力仕様と付随する留意事項について記述する
<br>
<br>
2πの演算方法を円周率piを使用して次に示す
<br>
2pi || 2*pi -> 6.283185307179586
<br>
・pi2と入力した場合、<a href="#span-out-vars">変数</a>と判別される
<br>
pi2 -> [MyErr]Invalid REv(pi2)
<br>
・piの後に続ける場合、<a href="#span-out-BT">括弧</a>で区切るか乗算記号*を明示する
<br>
pi(2) || pi*2 -> 6.283185307179586
<br>
<br>
角<a href="#span-out-BT">括弧</a>[]は使用不可
<br>
pi[2] -> [MyErr]Invalid reference of array
<br>
[2]pi -> [MyErr]Invalid reference
<br>
x=2; x[0] -> 2
<br>
x=2; x[2] -> [MyErr]Invalid reference of array
<br>
x=2; [2]x -> [MyErr]Invalid reference
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
複素数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-com"></span>
複素数の入力仕様と付随する留意事項について記述する
<br>
<br>
虚数単位iは後置の単項演算子とする
<br>
(+1)i || +(1)i || +1(i) || +(i) -> i
<br>
(-1)i || -(1)i || -1(i) || -(i) -> -i
<br>
3i/2 -> 1.5i
<br>
1/2i || 1/(2i) -> -0.5i
<br>
<br>
複素数を宣言する関数を示す
<br>
complex(1,-1) || comp(1,-1) -> 1-i
<br>
<br>
複素数を実部と虚部に分離する関数を示す
<br>
real(3+i) -> 3
<br>
imag(3+i) -> 1
<br>
<br>
iの2乗の演算方法を2項演算子または関数を使用して3種類示す
<br>
(i)^2 || (i)**2 || pow(i,2) -> -1+1.2246467991473532e-16i
<br>
・<a href="#span-out-float">浮動小数点演算</a>では、次のepsilonに相当する<a href="#span-out-epsilon">Machine epsilon</a>が残る
<br>
epsilon || eps -> 2.220446049250313e-16
<br>
・この傾向は演算量に応じて<a href="#span-out-ope">実数演算</a>よりも顕著に現れる
<br>
<br>
-1の平方根の演算方法を3種類示す
<br>
(-1)^0.5 || pow(-1,0.5) || sqrt(-1) -> 6.123233995736766e-17+i
<br>
・先頭の丸括弧()を省略した場合、次のように演算される
<br>
-1^0.5 || -(1^0.5) -> -1
<br>
・符号付の分母の丸括弧()を省略した場合、error終了
<br>
1/-i || (1/)(-i) -> [MyErr]Invalid binary operation
<br>
1/(-i) -> i
<br>
<br>
Napier数eの空括弧()を省略してEulerの公式より極形式の複素数を示す
<br>
(sqrt2)e^(i{pi/4}) || sqrt2()ecomp(pi/4) -> 1.0000000000000002+i
<br>
sqrt2 || sqrt2() -> 1.4142135623730951
<br>
<br>
<a href="#span-out-vars">変数</a>を使用
<br>
・複素数zの偏角/piを示す
<br>
z=e^(i{pi/4}); arg(z)/pi -> 0.25
<br>
・複素数zの絶対値を示す
<br>
z=e^(i{pi/4}); abs(z) -> 1
<br>
<br>
以上より、次の複素数演算をtest caseとして初期表示する
<br>
e^(-i(1pi()2/2i(5-3-1)i/(-4)))
<br>
・既定ではleft-<a href="#span-out-associativity">associativity</a>の2項演算で除算より<a href="#span-out-BRmo">記号省略乗算</a>を優先する
<br>
e^(-i(1pi(){2/{2i({5-3}-1)i}}/(-4)))
<br>
<br>
2項の<a href="#span-out-associativity">associativity</a>や<a href="#span-out-prec-ope">演算子のprecedence</a>によって解が異なる場合、入力を見直す
<br>
<br>
具体的には次のように対策する
<br>
a={5-3}-1; b=2/{2i(a)i}; e^(-i(1pi()b/(-4)))
<br>
・一部分を変数に代入し、semi-colon;区切りで演算順序を明確化する
<br>
・2項演算子が連続する場合、<a href="#span-out-BT">括弧</a>を明示する
<br>
<br>
<a href="#span-out-ope">実数演算</a>の場合、虚数は0のため、次の極形式は使用不可
<br>
t=pi/4; e^(i{t}) || e^(real(i)t) || e^(0)  // NG -> 1
<br>
・極形式の関数を使用
<br>
pcomp(1,t) || ecomp(t) || cos(t)+real(i)sin(t) || cos(t) -> 0.7071067811865476
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FN"></span>
関数の入力仕様と付随する留意事項について記述する
<br>
<br>
関数の引数を括る<a href="#span-out-BT">括弧</a>は丸括弧()で統一する
<br>
<br>
leftとrightの数値の関係や大小を比較する関数を列挙する
<br>
・被演算子が複素数の場合
<br>
　・equal判定関数: ceq(left, right)
<br>
　・not equal判定関数: cne(left, right)
<br>
・被演算子が実数の場合、中置の演算子を代替可
<br>
　・left==rightを代替するequal判定関数: eq(left, right)
<br>
　・left&lt;&gt;rightを代替するnot equal判定関数: ne(left, right)
<br>
　・left&lt;rightを代替するless than判定関数: lt(left, right)
<br>
　・left&lt;=rightを代替するless or equal判定関数: le(left, right)
<br>
　・left&gt;rightを代替するgreater than判定関数: gt(left, right)
<br>
　・left&gt;=rightを代替するgreater or equal判定関数: ge(left, right)
<br>
・引数
<br>
　・第1引数: leftの数値を値渡し
<br>
　・第2引数: rightの数値を値渡し
<br>
・返値
<br>
　・成立時: 1を返す
<br>
　・不成立時: 0を返す
<br>
・test caseを列挙する
<br>
ceq(2+3i,3*i-(-2)) -> 1
<br>
cne(2+3i,3*i-(-2)) -> 0
<br>
eq(2+3i,2-3i) || eq(2,2) -> 1
<br>
ne(5,-5) -> 1
<br>
lt(1,2)&amp;lt(3,4) || 1&amp;1  // AND -> 1
<br>
lt(1,2)&amp;gt(3,4) || 1&amp;0  // AND -> 0
<br>
lt(1,2)@lt(3,4) || 1@1  // XOR -> 0
<br>
lt(1,2)@gt(3,4) || 1@0  // XOR -> 1
<br>
lt(1,2)|lt(3,4) || 1|1  // OR -> 1
<br>
lt(1,2)|gt(3,4) || 1|0  // OR -> 1
<br>
le(1,1)*ge(1,1) || 1*1 -> 1
<br>
le(1,1)*ge(1,2) || 1*0 -> 0
<br>
<br>
関数の引数に行列を指定した場合、最終行vectorの左から順に参照する
<br>
・引数1個の関数の場合
<br>
x=(1,2,3:4,5,6); log(x) || log(4,5,6) || log(4) -> 1.3862943611198906
<br>
・引数1個か2個の関数の場合
<br>
x=(1,2,3:4,5,6); log_ex(x) || log_ex(4,5,6) || log_ex(4,5) -> 0.8613531161467861
<br>
・引数2個の関数の場合
<br>
x=(1,2,3:4,5,6); atan2(x) || atan2(4,5,6) || atan2(4,5) -> 0.6747409422235527
<br>
x=(1,2,3:4); atan2(x) || atan2(4) -> [MyErr]FN isNaN
<br>
・引数不定の関数の場合
<br>
x=(1,2,3:4,5,6); max(x) || max(4,5,6) -> 6
<br>
<br>
log関数の仕様はJavaScript準拠の自然対数とする
<br>
ln(e) || log(e) -> 1
<br>
ln(10) || ln10() -> 2.302585092994046
<br>
ln(2) || ln2() -> 0.6931471805599453
<br>
<br>
常用対数
<br>
log10(10) -> 1
<br>
x=10; log(x)log10e() -> 1
<br>
x=100; log(x)log10e() -> 2
<br>
<br>
Excel準拠の引数(値,底||10)は次のlog_exを使用する
<br>
log_ex(10) || log_ex(10,10) -> 1
<br>
log_ex(e) || log10e() -> 0.43429448190325176
<br>
log_ex(e,2) || log2e() -> 1.4426950408889634
<br>
<br>
atan2関数の仕様はJavaScript準拠の引数(y,x)とする
<br>
atan2(1,0)/pi -> 0.5
<br>
deg_atan2(1,0) || degrees(atan2(1,0)) -> 90
<br>
<br>
<a href="#span-out-vars">変数</a>を使用
<br>
・実軸と虚軸の複素数平面から弧度数radに変換する場合
<br>
z=e^(i{pi/6}); atan2(imag(z),real(z)) -> 0.5235987755982987
<br>
z=e^(i{pi/6}); arg(z) -> 0.5235987755982987
<br>
・さらに、度数degに変換する場合
<br>
degrees(ans) || deg_atan2(imag(z),real(z)) -> 29.999999999999993
<br>
・再度、弧度数radに変換
<br>
radians(ans) -> 0.5235987755982987
<br>
<br>
Excel準拠の引数(x,y)は次のatan2_exを使用する
<br>
atan2_ex(0,1)/pi -> 0.5
<br>
deg_atan2_ex(0,1) || degrees(atan2_ex(0,1)) -> 90
<br>
<br>
一部の実装関数において引数不足の場合、予期せぬerror終了が発生する
<br>
・pow関数を一例に示す
<br>
・<a href="#span-out-ope">実数演算</a>の場合、Nativeに同義
<br>
pow(2) -> [MyErr]FN isNaN
<br>
・<a href="#span-out-com">複素数</a>演算の場合、逐次引数不足を判定しないため、予期せぬerror終了
<br>
pow(2) -> Unexpected error
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNspecial"></span>
特殊関数の入力仕様と付随する留意事項について記述する
<br>
<br>
特殊関数（非初等関数）は<a href="#span-out-eqns">式変数</a>と<a href="#span-out-FNh">高階関数</a>を使用して定義する
<br>
・標準正規分布SNDの区間確率P(x)
<br>
SND=&lt;exp(-t^2/2)/sqrt(2pi);
<br>
Px=&lt;_it(=&lt;SND,0,x)2;
<br>
・誤差関数erf(x)
<br>
erfx=&lt;_it(=&lt;SND,0,x(sqrt2))2;
<br>
・同義
<br>
erfx=&lt;_it(=&lt;{exp(-t^2)},0,x)(2/sqrt(pi));
<br>
・相補誤差関数erfc(x)
<br>
erfcx=&lt;1-erfx;
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-mat"></span>
行列の入力仕様と付随する留意事項について記述する
<br>
<br>
vectorの入力方法2種類
<br>
・各vectorの要素はcomma,で区切る
<br>
行vector(1,2) || [1,2] -> (1,2)
<br>
列vector{1,3} -> (1:3)
<br>
<br>
2行2列の行列の入力方法
<br>
1　2
<br>
3　4
<br>
・各vectorはcolon:で区切る
<br>
(1,2:3,4) || [1,2:3,4] || {1,3:2,4} -> (1,2:3,4)
<br>
<br>
行vector列挙指定の行列（以降、行指定の行列と呼ぶ）
<br>
((1,2):(3,4)) -> (1,2:3,4)
<br>
((1:2):(3:4)) -> (1:2:3:4)
<br>
<br>
列vector列挙指定の行列（以降、列指定の行列と呼ぶ）
<br>
{{1,2}:{3,4}} || {1,2:3,4} -> (1,3:2,4)
<br>
{{1:2}:{3:4}} || {1:2:3:4} -> (1,2,3,4)
<br>
<br>
行指定の行列と列指定の行列は互いに転置の関係
<br>
(1,2:3,4) -> (1,2:3,4)
<br>
{1,2:3,4} -> (1,3:2,4)
<br>
・転置の<a href="#span-out-FNm">行列関数</a>を使用
<br>
transpose({1,2:3,4}) || trans({1,2:3,4}) || trans{1,2:3,4} -> (1,2:3,4)
<br>
({1,2},{3:4}) || (trans(1,2),trans(3:4)) -> (1,3,4:2)
<br>
・1重列挙の場合、外側の<a href="#span-out-BT">括弧</a>に結合性は存在しない
<br>
(1,2) || {(1,2)} || ({(1,2)}) || {({(1,2)})} -> (1,2)
<br>
{1,2} || ({1,2}) || {({1,2})} || ({({1,2})}) -> (1:2)
<br>
・多重列挙の場合、vectorを括る<a href="#span-out-BT">括弧</a>の結合性に依存する
<br>
{(1,2),(3:4)} -> (1,2:3:4)
<br>
({1,2}:{3:4}) || (trans(1,2):trans(3:4)) -> (1:2:3,4)
<br>
{(1,2):(3:4)} -> (1,2,3:0,0,4)
<br>
(1,{2,(3,{4,5})}) -> (1,2:0,3,4:0,0,5)
<br>
(1,(2:3),4) -> (1,2,4:0,3)
<br>
(1,{2:3},4) -> (1,2,3,4)
<br>
{1,{2:3},4} -> (1:2,3:4)
<br>
{1,(2:3),4} -> (1:2:3:4)
<br>
<br>
定義できる行列演算
<br>
・<a href="#span-out-mat-product">行列積</a>
<br>
・乗算記号*同様に積の記号*は省略可
<br>
(1,2:3,4)(1,2:3,4) -> (7,10:15,22)
<br>
・標準内積
<br>
(1,2,3){1,2,3} -> 14
<br>
・標準cross積
<br>
{1,2,3}(1,2,3) -> (1,2,3:2,4,6:3,6,9)
<br>
{1,2,3}(1,2) -> (1,2:2,4:3,6)
<br>
・Hermit内積
<br>
(1+i,1){1-i,1} -> 3
<br>
・Hermitian cross積
<br>
{1-i,1}(1+i,1) -> (2,1-i:1+i,1)
<br>
・空要素は0
<br>
(()) -> 0
<br>
(,) -> (0,0)
<br>
(2,:)(1,2:3,4) || (2,:,)(1,2:3,4) -> (2,4:0,0)
<br>
(1,2:3,4)(2,:) || (1,2:3,4)(2,:,) -> (2,0:6,0)
<br>
・抜け要素は0
<br>
(1,2,3:){1,2,3:} || (1,2,3:,,){1,2,3:,,} -> (14,0:0,0)
<br>
・単位行列
<br>
k=1; (k,:,k) -> (1,0:0,1)
<br>
・Scalar行列
<br>
k=-3; (k,:,k) -> (-3,0:0,-3)
<br>
・左右可換のScalar倍（同sizeのScalar行列との積）
<br>
k=-3; (k,:,k)(1,2:3,4) || (1,2:3,4)(k,:,k) -> (-3,-6:-9,-12)
<br>
k=-3; k(1,2:3,4)  // NG -> [MyErr]Invalid matrix operation
<br>
・符号
<br>
-(1,2:3,4) || (,:,)-(1,2:3,4) || (-1,:,-1)(1,2:3,4) -> (-1,-2:-3,-4)
<br>
・差
<br>
(1,2:3,4)-(1,2:3,4) -> (0,0:0,0)
<br>
・和
<br>
(1,2:3,4)+(1,2:3,4) -> (2,4:6,8)
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
x=1; y=(x,2x:3x,4x); y*y-y || (7,10:15,22)-(1,2:3,4) -> (6,8:12,18)
<br>
t=pi/4; (cos(t),sin(t):,){i(sin(t)),i(cos(t)):,} -> (i,0:0,0)
<br>
<br>
列指定の不規則行列
<br>
{1:2:3,4} -> (1,2,3:0,0,4)
<br>
{1:2,3} -> (1,2:0,3)
<br>
{1:2,,3} -> (1,2:0,0:0,3)
<br>
{1,2:3,,,4} -> (1,3:2,0:0,0:0,4)
<br>
{1,,,2:3,4:5,,,,,6} -> (1,3,5:0,4,0:0,0,0:2,0,0:0,0,0:0,0,6)
<br>
<br>
行指定の不規則行列
<br>
A=(11:21,22:31,32,33,34); A -> (11:21,22:31,32,33,34)
<br>
tA={11:21,22:31,32,33,34}; tA -> (11,21,31:0,22,32:0,0,33:0,0,34)
<br>
・行指定の行列で抜け要素がある場合、転置の<a href="#span-out-FNm">行列関数</a>を使用
<br>
A=(11:21,22:31,32,33,34); trans(trans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
A=(11:21,22:31,32,33,34); htrans(htrans(A)) -> (11,0,0,0:21,22,0,0:31,32,33,34)
<br>
・結合処理が重くなるため、行指定の行列は抜け要素を自動で埋めない
<br>
<br>
定義できない<a href="#span-out-mat-product">行列積</a>の場合、error終了
<br>
(1,2)(1,2) -> [MyErr]Invalid matrix operation
<br>
<br>
行列sizeの一致しない差と和の場合、error終了
<br>
(1,2:3,4)-(-1) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)-(-1,2) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)+(-1:) -> [MyErr]Invalid matrix operation
<br>
(1,2:3,4)+(-1,2:,,) -> [MyErr]Invalid matrix operation
<br>
<br>
抜け要素を埋めて行列sizeが一致する場合、差と和の演算を許容する
<br>
(1,2:3,4)-(-1,:) || (1,2:3,4)-(-1,:,) || (1,2:3,4)-(-1,0:0,0) -> (2,2:3,4)
<br>
(1,2:3,4)-(-1,2:) || (1,2:3,4)-(-1,2:,) || (1,2:3,4)-(-1,2:0,0) -> (2,0:3,4)
<br>
(1,2:3,4)+(-1,:) || (1,2:3,4)+(-1,:,) || (1,2:3,4)+(-1,0:0,0) -> (0,2:3,4)
<br>
(1,2:3,4)+(-1,2:) || (1,2:3,4)+(-1,2:,) || (1,2:3,4)+(-1,2:0,0) -> (0,4:3,4)
<br>
<br>
<a href="#span-out-ope">無次元</a>の演算の場合、行列の演算規則とは関係なく最終要素を演算する
<br>
(1,2:3)1 || (3)*1 -> 3
<br>
(1,2)/(3,4) || (2)/(4) -> 0.5
<br>
(1,2,3)+(4,5) || (3)+(5) -> 8
<br>
(1,2:3)-(4,5:6:7) || (3)-(7) -> -4
<br>
<br>
行列に対して明確に定義できない2項演算を実行した場合も同様とする
<br>
(5,3,1)/(3i,i) || (1)/(i) -> -i
<br>
(1,2,3)^(1.5,0.5) || (3)^(0.5) -> 1.7320508075688772
<br>
(3,5,7)%(1,5) || (7)%(5) -> 2
<br>
(2,4,8)&gt;&gt;(3,1) || (8)&gt;&gt;(1) -> 4
<br>
<br>
行列に対して後置の単項演算を実行した場合も無次元確定とする
<br>
(5,3)i || (3)i -> 3i
<br>
(10,5:,)! || (0)! -> 1
<br>
・次の場合、扱いが異なる
<br>
(5,3)(i) || (5,3)*(i) -> [MyErr]Invalid matrix operation
<br>
(5,3)(!) || (5,3)*(1) -> [MyErr]Invalid matrix operation
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定数扱いの
<br>
行列
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm0"></span>
定数扱いの行列の入力仕様と付随する留意事項について記述する
<br>
<br>
<a href="#span-out-FN0">定数</a>同様に扱う行列を列挙する
<br>
vector2r || vector2r() -> (0,0)
<br>
vector3r -> (0,0,0)
<br>
vector4r -> (0,0,0,0)
<br>
vector2c -> (0:0)
<br>
vector3c -> (0:0:0)
<br>
vector4c -> (0:0:0:0)
<br>
zeros2 -> (0,0:0,0)
<br>
zeros3 -> (0,0,0:0,0,0:0,0,0)
<br>
zeros4 -> (0,0,0,0:0,0,0,0:0,0,0,0:0,0,0,0)
<br>
ones2 -> (1,1:1,1)
<br>
ones3 -> (1,1,1:1,1,1:1,1,1)
<br>
ones4 -> (1,1,1,1:1,1,1,1:1,1,1,1:1,1,1,1)
<br>
identity2 -> (1,0:0,1)
<br>
identity3 -> (1,0,0:0,1,0:0,0,1)
<br>
identity4 -> (1,0,0,0:0,1,0,0:0,0,1,0:0,0,0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNm"></span>
行列関数の入力仕様と付随する留意事項について記述する
<br>
<br>
行vector
<br>
vectorr(3.3) || vectorr(3) || vector3r -> (0,0,0)
<br>
vectorr(6) -> (0,0,0,0,0,0)
<br>
vectorr(9) -> (0,0,0,0,0,0,0,0,0)
<br>
vectorr(0) || vectorr(-1) -> [MyErr]Invalid matrix size
<br>
vectorr(1001) -> [MyErr]Invalid matSizeMax over
<br>
<br>
列vector
<br>
vectorc(3) || vector3c -> (0:0:0)
<br>
vectorc(6) -> (0:0:0:0:0:0)
<br>
vectorc(9) -> (0:0:0:0:0:0:0:0:0)
<br>
<br>
単位行列
<br>
identity(3) -> (1,0,0:0,1,0:0,0,1)
<br>
identity(5) -> (1,0,0,0,0:0,1,0,0,0:0,0,1,0,0:0,0,0,1,0:0,0,0,0,1)
<br>
・行列sizeは正の整数にfloor
<br>
identity(3.3) || identity(3) -> (1,0,0:0,1,0:0,0,1)
<br>
・行列sizeが0以下の場合、error終了
<br>
identity(0) || identity(-1)  -> [MyErr]Invalid matrix size
<br>
・<a href="#span-in-options">内部option</a>のmatSizeMax既定値1000を超過の場合、error終了
<br>
identity(1001) -> [MyErr]Invalid matSizeMax over
<br>
・出力logの文字数制限log.length&lt;5000
<br>
identity(100) -> (1,0,0,...,0,0,0,...
<br>
・log表示負荷を下げる場合、変数に代入して<a href="#span-out-BT">括弧</a>で括る
<br>
(A=identity(100),A2=A*A) -> (0,0)
<br>
<br>
Scalar行列
<br>
scalars(2,-3) -> (-3,0:0,-3)
<br>
scalars(3,i) -> (i,0,0:0,i,0:0,0,i)
<br>
Scalars(4,3-5i) -> (3-5i,0,0,0:0,3-5i,0,0:0,0,3-5i,0:0,0,0,3-5i)
<br>
N=10; z=1+i; A=htrans(scalars(N,z))identity(N)scalars(N,z); A ||
<br>
N=10; z=1+i; A=scalars(N,z)identity(N)htrans(scalars(N,z)); A ->
<br>
(
<br>
2,0,0,0,0,0,0,0,0,0:
<br>
0,2,0,0,0,0,0,0,0,0:
<br>
0,0,2,0,0,0,0,0,0,0:
<br>
0,0,0,2,0,0,0,0,0,0:
<br>
0,0,0,0,2,0,0,0,0,0:
<br>
0,0,0,0,0,2,0,0,0,0:
<br>
0,0,0,0,0,0,2,0,0,0:
<br>
0,0,0,0,0,0,0,2,0,0:
<br>
0,0,0,0,0,0,0,0,2,0:
<br>
0,0,0,0,0,0,0,0,0,2
<br>
)
<br>
<br>
zeros行列
<br>
zeros(2,2) -> (0,0:0,0)
<br>
zeros(3,5) -> (0,0,0,0,0:0,0,0,0,0:0,0,0,0,0)
<br>
zeros(0,1) || zeros(-1,1)  -> [MyErr]Invalid matrix size
<br>
zeros(1001,1) -> [MyErr]Invalid matSizeMax over
<br>
<br>
ones行列
<br>
ones(2,2) -> (1,1:1,1)
<br>
ones(5,3) -> (1,1,1:1,1,1:1,1,1:1,1,1:1,1,1)
<br>
<br>
行列の転置
<br>
trans(1,2:3,4) -> (1,3:2,4)
<br>
・行vectorを列vectorに変換
<br>
transpose(1,2,3) || trans(1,2,3) -> (1:2:3)
<br>
・列vectorを行vectorに変換
<br>
trans({1,2,3}) || trans{1,2,3} -> (1,2,3)
<br>
<br>
<a href="#span-out-com">複素数</a>の行列のHermit転置
<br>
htrans(1-i,1-2i:1-3i,1-4i) || hermitian(1-i,1-2i:1-3i,1-4i) -> (1+i,1+3i:1+2i,1+4i)
<br>
<br>
列vectorのEuclidian norm（vectorの長さ）
<br>
norm(1:2:3) || norm{1,2,3} -> 3.7416573867739413
<br>
norm(-i:2i:-3i) || norm{-i,2i,-3i} -> 3.7416573867739413
<br>
norm((1-i)/sqrt2:2i:-3i) || norm{(1-i)/sqrt2,2i,-3i} -> 3.7416573867739413
<br>
・<a href="#span-out-ope">有次元</a>の場合、同義
<br>
x={(1-i)/sqrt2,2i,-3i}; sqrt(htrans(x)x) -> 3.7416573867739413
<br>
・Hermit内積
<br>
x={(1-i)/sqrt2,2i,-3i}; htrans(x)x -> 14
<br>
・標準内積
<br>
x={(1-i)/sqrt2,2i,-3i}; trans(x)x -> -13-0.9999999999999998i
<br>
・よって<a href="#span-out-com">複素数</a>の場合、非同義
<br>
x={(1-i)/sqrt2,2i,-3i}; abs(sqrt(trans(x)x))  // NG -> 3.6108731368472777
<br>
・行vectorを誤入力した場合
<br>
norm((1-i)/sqrt2,2i,-3i) || norm(-3i)  // NG -> 3
<br>
<br>
行列size
<br>
・行size
<br>
sizer(1,2:3,4) -> 2
<br>
sizer(1,2:3,4)[0] || sizer(1,2) -> 1
<br>
sizer(1:3,4) -> 2
<br>
sizer(1:3,4:) -> 3
<br>
・列size
<br>
size(1,2:3,4) || sizec(1,2:3,4) -> 2
<br>
sizec(1,2:3,4)[0] || sizec(1,2) -> 2
<br>
sizec(1,2:3) -> 2
<br>
sizec(1,2:3:4,5,) -> 3
<br>
<br>
vectorの正規化
<br>
・行vectorを正規化する場合
<br>
vr=(1,i,-i); vr -> (1,i,-i)
<br>
normalizer(vr) ->
<br>
(0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・同義
<br>
・行vectorの左からnormの逆数を積
<br>
vr=(1,i,-i); (1/norm(trans(vr)))vr ->
<br>
(0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・列vectorを正規化する場合
<br>
vc={1,i,-i}; vc -> (1:i:-i)
<br>
normalize(vc) || normalizec(vc) -> 
<br>
(0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
・同義
<br>
・列vectorの右からnormの逆数を積
<br>
vc={1,i,-i}; vc(1/norm(vc)) ->
<br>
(0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
・行vectorを誤入力した場合
<br>
vr=(1,i,-i); normalizec(vr)  // NG -> (1,i,-i)
<br>
・zeros-vectorの場合
<br>
normalize({0,0,0})  // NG -> [MyErr]FN isNaN
<br>
<br>
行列の正規化
<br>
・すべての行vectorを正規化する場合
<br>
A=(1:1,i:1,i,-i); A -> (1:1,i:1,i,-i)
<br>
normalizer(A) ->
<br>
(1,0,0:
<br>
0.7071067811865475,0.7071067811865475i,0:
<br>
0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・各行vectorを行列操作で正規化する場合
<br>
(1/norm(trans(A[0])))A[0] -> 1
<br>
(1/norm(trans(A[1])))A[1]
<br>
-> (0.7071067811865475,0.7071067811865475i)
<br>
(1/norm(trans(A[2])))A[2]
<br>
-> (0.5773502691896258,0.5773502691896258i,-0.5773502691896258i)
<br>
・すべての列vectorを正規化する場合
<br>
tA={1:1,i:1,i,-i}; tA -> (1,1,1:0,i,i:0,0,-i)
<br>
normalizec(tA) ->
<br>
(1,0.7071067811865475,0.5773502691896258:
<br>
0,0.7071067811865475i,0.5773502691896258i:
<br>
0,0,-0.5773502691896258i)
<br>
・各列vectorを行列操作で正規化する場合
<br>
tA={1:1,i:1,i,-i}; A=trans(tA); A -> (1,0,0:1,i,0:1,i,-i)
<br>
trans((1/norm(trans(A[0])))A[0]) -> (1:0:0)
<br>
trans((1/norm(trans(A[1])))A[1])
<br>
-> (0.7071067811865475:0.7071067811865475i:0)
<br>
trans((1/norm(trans(A[2])))A[2])
<br>
-> (0.5773502691896258:0.5773502691896258i:-0.5773502691896258i)
<br>
<br>
行列要素を取得
<br>
・最初要素（行列の最初行の最初列の要素）
<br>
first(1,2:3,4) -> 1
<br>
first{1,2:3,4} -> 1
<br>
・最終要素（行列の最終行の最終列の要素）
<br>
last(1,2:3,4) -> 4
<br>
last{1,2:3,4} -> 4
<br>
・同じ<a href="#span-out-BT">括弧</a>でcomma,を括る限り、last行列関数はcomma演算子同様に働く
<br>
last((1,2):(3,4)) -> 4
<br>
last{{1,2}:{3,4}} -> 4
<br>
・colon:を含めて括る場合、意図とは異なる可能性
<br>
・最終列挙の要素が最終要素とは限らない
<br>
(1,(2:3),4) ->
<br>
(
<br>
1,2,4:
<br>
0,3
<br>
)
<br>
last(1,(2:3),4) -> 3
<br>
・<a href="#span-out-BT">括弧</a>を統一しない場合、意図とは異なる可能性
<br>
({1,2},3,4) ->
<br>
(
<br>
1,3,4:
<br>
2
<br>
)
<br>
last({1,2},3,4) -> 2
<br>
・最終列挙の要素を取り出す場合の対策
<br>
・常にlast行列関数で<a href="#span-out-BT">括弧</a>の中身を無次元化する
<br>
last(1,last(2:3),4) -> 4
<br>
last(last{1,2},3,4) -> 4
<br>
last(last(last{1,2},3),4) -> 4
<br>
last(last(1,2),last(3,4)) -> 4
<br>
last(last(1,2),last(3:4)) -> 4
<br>
last(last(1,2),last{3:4}) -> 4
<br>
last(last{1,2},last(3:4)) -> 4
<br>
last(last{1,2},last{3:4}) -> 4
<br>
last(last{1,2}:last{3:4}) -> 4
<br>
・仕様上、代入は次元を残さず、無次元の0を返す
<br>
(vc={1,2,3},vr=(1,2,3),norm(vc)) -> (0,0,3.7416573867739413)
<br>
last(ans) -> 3.7416573867739413
<br>
・次元を残した場合（参考）
<br>
({0,0,0},(0,0,0),1) -> (0,0,0,0,1:0:0)
<br>
(last{0,0,0},last(0,0,0),1) -> (0,0,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列操作
<br>
入力仕様
    </th>
    <td>
<span id="span-out-concat"></span>
行列操作の入力仕様と付随する留意事項について記述する
<br>
<br>
任意要素を取得
<br>
A=(1,2:3,4); A[0][0] -> 1
<br>
A=(1,2:3,4); A[1][1] -> 4
<br>
A=(1:1,i:1,i,-i); A[0][1] -> [MyErr]Invalid reference of array
<br>
・<a href="#span-out-eqns">式変数</a>を使用
<br>
clear; n=2; xn=&lt;(n,2n); xn[0][1] || (xn=&gt;)[0][1] -> 4
<br>
clear; n=2; xn=&lt;(n,2n); xn=&gt;[0][1] -> [MyErr]Invalid REe(=&gt;)
<br>
clear; n=2; xn=&lt;(n,2n)[0][1]; xn=&gt; -> 4
<br>
<br>
任意要素を演算
<br>
(1,2:3,4)[0][0]3 || 1*3 -> 3
<br>
(1)[0][0]3=(x=3) || 1*3=0 -> -3
<br>
<br>
行vectorを取得
<br>
A=(1,2:3,4); A[1] -> (3,4)
<br>
clear; (1,2:3,4)[x] -> [MyErr]Invalid REv(x)
<br>
<br>
列vectorを取得
<br>
・転置の<a href="#span-out-FNm">行列関数</a>を使用
<br>
A=(1,2:3,4); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2:4)
<br>
A=(i,2i:3i,4i); trans((trans(A))[1]) || htrans((htrans(A))[1]) -> (2i:4i)
<br>
trans((trans(1,2:3,4))[1]) || htrans((htrans(1,2:3,4))[1]) -> (2:4)
<br>
trans((trans(i,2i:3i,4i))[1]) || htrans((htrans(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
・<a href="#span-out-BT">括弧</a>は<a href="#span-out-FNm">関数</a>より優先するため、関数の外側を上位の括弧で括る
<br>
A=(1,2:3,4); (trans(A))[1]  // OK -> (2,4)
<br>
(trans(1,2:3,4))[1]  // OK -> (2,4)
<br>
A=(1,2:3,4); trans(A)[1] || trans((A)[1])  // NG -> (3:4)
<br>
trans(1,2:3,4)[1] || trans((1,2:3,4)[1])  // NG -> (3:4)
<br>
<br>
定義済みの行列要素のみ代入可
<br>
・要素指定の代入
<br>
A=(1,2:3,4); A[0][0]=-1; A -> (-1,2:3,4)
<br>
A=(1,2:3,4); ii=1; A[ii][ii]=-1; A -> (1,2:3,-1)
<br>
A=(1,2:3,4); A[1][1]=(x=2); A -> (1,2:3,0)
<br>
・行列を代入した場合、最終要素を代入
<br>
A=(1,2:3,4); A[0][0]=A; A -> (4,2:3,4)
<br>
A=(1,2:3,4); A[1][1]=(x=2,-2x); A -> (1,2:3,-4)
<br>
・行指定の代入
<br>
A=(1,2:3,4); A[1]=A[0]; A -> (1,2:1,2)
<br>
A=(1,2:3,4); A[1]=-A[1]; A -> (1,2:-3,-4)
<br>
A=(1,2:3,4); A[1]=-2A[1]; A -> (1,2:-6,-8)
<br>
A=(1,2:3,4); A[1]=(,); A -> (1,2:0,0)
<br>
A=(1,2:3,4); w=A[1]; A[1]=A[0]; A[0]=w; A -> (3,4:1,2)
<br>
・行列を代入した場合、最終行vectorを代入
<br>
A=(1,2:3,4); A[0]=A; A -> (3,4:3,4)
<br>
A=(1,2:3,4); A[0]=(A:A(2,:,2)); A -> (6,8:3,4)
<br>
・列指定で代入する場合、転置の<a href="#span-out-FNm">行列関数</a>を使用
<br>
A=(1,2:3,4); tA=trans(A); tA[0]=-tA[0]; A=trans(tA); A -> (-1,2:-3,4)
<br>
・列sizeの異なる代入不可
<br>
A=(1,2:3,4); A[1]=0 || A[1]=(1) || A[1]=(,,) || A[1]={,} -> [MyErr]Invalid store array
<br>
・未定義の行列要素への代入不可
<br>
A=(1,2:3,4); A[2]=A[1] -> [MyErr]Invalid reference of array
<br>
A=(1,2:3,4); A[1]=-1 || A[2][0]=5 -> [MyErr]Invalid substitution
<br>
A=(1,2:3,4); A[0.5][0]=-1 -> [MyErr]Invalid reference of array
<br>
・<a href="#span-out-eqns">式変数</a>への要素指定・行指定の代入不可
<br>
clear; A=&lt;(1,2:3,4); A[1][1]=0 -> [MyErr]Undef var(A)
<br>
clear; A=&lt;(1,2:3,4); A[1]=(,) -> [MyErr]Undef var(A)
<br>
clear; A=&lt;(1,2:3,4); (A=&gt;)[1][1]=0 || =0-4 -> -4
<br>
clear; A=&lt;(1,2:3,4); (A=&gt;)[1]=(,) || =(,)-(A=&gt;)[1] -> (-3,-4)
<br>
<br>
vectorの結合
<br>
((1,2),(3,4)) -> (1,2,3,4)
<br>
x=(1,2); y=(3,4); (x,y) -> (1,2,3,4)
<br>
A=(1,2:3,4); (A[0],A[1]) -> (1,2,3,4)
<br>
(vector4c,vector4c,vector4c) -> (0,0,0:0,0,0:0,0,0:0,0,0)
<br>
・<a href="#span-out-SR">区切り文字</a>の左から順に結合する
<br>
((1,2),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
((1,2:,:,),{3,4,},{3,4,5}) -> (1,2,3,3:0,0,4,4:0,0,0,5)
<br>
<br>
行列の結合
<br>
((1,2:5,6),(3,4:7,8):{-1,-5:-2,-6},{-3,-7:-4,-8})
<br>
-> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
<br>
(zeros2,zeros2:zeros2,zeros2) -> (0,0,0,0:0,0,0,0:0,0,0,0:0,0,0,0)
<br>
・<a href="#span-out-vars">変数</a>を使用
<br>
mat00=(1,2:5,6);
<br>
mat01=(3,4:7,8);
<br>
mat10={-1,-5:-2,-6};
<br>
mat11={-3,-7:-4,-8};
<br>
mat=(mat00,mat01:mat10,mat11);
<br>
mat -> (1,2,3,4:5,6,7,8:-1,-2,-3,-4:-5,-6,-7,-8)
<br>
・不規則行列
<br>
(1,2),{3,4:5:6,7:8} -> (1,2,3,5,6,8:0,0,4,0,7)
<br>
(1,2),{3,4:5:6,7:8,9,10} -> (1,2,3,5,6,8:0,0,4,0,7,9:0,0,0,0,0,10)
<br>
(1,2),{3,4:5:6,7:8,(9,10)} -> (1,2,3,5,6,8:0,0,4,0,7,9,10)
<br>
(1,(2,3):({4,5}),6,{7,8,(9,10)}) ->
<br>
(
<br>
1,2,3:
<br>
4,6,7:
<br>
5,0,8:
<br>
0,0,9,10
<br>
)
<br>
・複雑なnestingは意図とは異なる可能性
<br>
A=(1,{2,3,4,5},(6,7,{8,9}):({10,11}),12,{13,14,(15,16,{17,18})}); A ->
<br>
(
<br>
1,2,6,7,8:
<br>
0,3,0,0,9:
<br>
0,4:
<br>
0,5:
<br>
10,12,13:
<br>
11,0,14:
<br>
0,0,15,16,17:
<br>
0,0,0,0,18
<br>
)
<br>
ttA=trans(trans(A)); ttA ->
<br>
(
<br>
1,2,6,7,8:
<br>
0,3,0,0,9:
<br>
0,4,0,0,0:
<br>
0,5,0,0,0:
<br>
10,12,13,0,0:
<br>
11,0,14,0,0:
<br>
0,0,15,16,17:
<br>
0,0,0,0,18
<br>
)
<br>
A-ttA ->
<br>
(
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0:
<br>
0,0,0,0,0
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊
<br>
行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmspecial"></span>
特殊行列関数の入力仕様と付随する留意事項について記述する
<hr>
<br>
特殊行列関数は通常の<a href="#span-out-FNspecial">特殊関数</a>と異なり、特殊な演算仕様を意味する
<br>
<br>
回転行列
<br>
・3次元Euclid実空間の右手系直交座標系各軸周りの回転行列を演算して返す
<br>
・代数学に準ずる右手系直交座標系
<br>
　紙面x-y平面に対して鉛直上向きをz軸の正とする（左手系はその逆）
<br>
　x軸を親指、y軸を人差し指、z軸を中指とする
<br>
　回転方向は、x⇒y⇒z⇒x軸の正循環で各軸に向ける方向を正とする
<br>
・返値の回転行列は引数の誤差情報を継承しない
<br>
<br>
rotationx(第1引数)
<br>
rotationy(第1引数)
<br>
rotationz(第1引数)
<br>
・第1引数: Euler角の弧度数実数値radを値渡し
<br>
<br>
test caseを列挙する
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,-1:
<br>
0,1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(-pi/4) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000002,1:
<br>
0,-1,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(pi/4) ->
<br>
(1.0000000000000002,0,1:
<br>
0,1.4142135623730951,0:
<br>
-1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationy(-pi/4) ->
<br>
(1.0000000000000002,0,-1:
<br>
0,1.4142135623730951,0:
<br>
1,0,1.0000000000000002)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(pi/4) ->
<br>
(1.0000000000000002,-1,0:
<br>
1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationz(-pi/4) ->
<br>
(1.0000000000000002,1,0:
<br>
-1,1.0000000000000002,0:
<br>
0,0,1.4142135623730951)
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i; t
<br>
-> infoLost[ i] 0.7853981633974194+1000i+O(8e-13+8e-13i)
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotationx(t) ->
<br>
(1.4142135623730951,0,0:
<br>
0,1.0000000000000289,-0.9999999999999711:
<br>
0,0.9999999999999711,1.0000000000000289)
<br>
<br>
回転行列の引数の誤差情報を継承する場合
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i;
<br>
rt=real(t); rt -> infoLost[ i] 0.7853981633974194+O(8e-13)
<br>
rotx=&lt;(1,0,0:0,cos(rt),-sin(rt):0,sin(rt),cos(rt));
<br>
rotx ->
<br>
(1,0,0:
<br>
0,infoLost[ i] 0.7071067811865679+O(6e-13),
<br>
infoLost[ i] -0.707106781186527+O(6e-13):
<br>
0,infoLost[ i] 0.707106781186527+O(6e-13),
<br>
infoLost[ i] 0.7071067811865679+O(6e-13))
<br>
・一続きにまとめる場合
<br>
t=_dx(=&lt;{x},1,1)pi/4+1000i;
<br>
rotx=&lt;{rt=real(t),=&lt;(1,0,0:0,cos(rt),-sin(rt):0,sin(rt),cos(rt))}=&gt;;
<br>
(sqrt2,,:,sqrt2,:,,sqrt2)rotx ->
<br>
(1.4142135623730951,infoLost[ i] 0,infoLost[ i] 0:
<br>
0,infoLost[ i] 1.0000000000000289+O(8e-13),
<br>
infoLost[ i] -0.9999999999999711+O(8e-13):
<br>
0,infoLost[ i] 0.9999999999999711+O(8e-13),
<br>
infoLost[ i] 1.0000000000000289+O(8e-13))
<br>
<br>
回転行列を<a href="#span-out-eqns">式変数</a>で定義する場合
<br>
・x/y/zに対するEuler角をphi/theta/psiとする
<br>
rotx=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),-sin(rt):,sin(rt),cos(rt))}=&gt;;
<br>
roty=&lt;{rt=real(theta),=&lt;(cos(rt),,sin(rt):,1,:-sin(rt),,cos(rt))}=&gt;;
<br>
rotz=&lt;{rt=real(psi),=&lt;(cos(rt),-sin(rt),:sin(rt),cos(rt),:,,1)}=&gt;;
<br>
phi=pi/5; rotx-rotationx(phi) -> (0,0,0:0,0,0:0,0,0)
<br>
theta=pi/5; roty-rotationy(theta) -> (0,0,0:0,0,0:0,0,0)
<br>
psi=pi/5; rotz-rotationz(psi) -> (0,0,0:0,0,0:0,0,0)
<br>
<br>
回転行列を一般化する場合
<br>
・関数を使用する場合
<br>
rotx=&lt;{rotationx(phi)};
<br>
roty=&lt;{rotationy(theta)};
<br>
rotz=&lt;{rotationz(psi)};
<br>
・<a href="#span-out-eqns">式変数</a>で定義する場合
<br>
rotx=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),-sin(rt):,sin(rt),cos(rt))}=&gt;;
<br>
roty=&lt;{rt=real(theta),=&lt;(cos(rt),,sin(rt):,1,:-sin(rt),,cos(rt))}=&gt;;
<br>
rotz=&lt;{rt=real(psi),=&lt;(cos(rt),-sin(rt),:sin(rt),cos(rt),:,,1)}=&gt;;
<br>
・一般化した回転行列rot_は対象行列matの左から演算する
<br>
mat_after=rot_*mat_before
<br>
・よって回転順序は回転行列並び順の逆順となる
<br>
・回転順序x⇒y⇒z
<br>
rot_zyx=&lt;{rotz*roty*rotx};
<br>
phi=pi/4; theta=3pi/4; psi=-3pi/4;
<br>
ans_zyx=rot_zyx; ans_zyx ->
<br>
(0.4999999999999999,0.14644660940672638,-0.8535533905932737:
<br>
0.5,-0.8535533905932737,0.14644660940672605:
<br>
-0.7071067811865476,-0.4999999999999999,-0.5)
<br>
・回転順序z⇒y⇒x
<br>
rot_xyz=&lt;{rotx*roty*rotz};
<br>
phi=-pi/4; theta=-3pi/4; psi=3pi/4;
<br>
ans_xyz=rot_xyz; ans_xyz ->
<br>
(0.4999999999999999,0.5,-0.7071067811865476:
<br>
0.14644660940672638,-0.8535533905932737,-0.4999999999999999:
<br>
-0.8535533905932737,0.14644660940672605,-0.5)
<br>
・回転の逆回転を順序通りに記憶して演算すると単位行列に戻る
<br>
rot_xyz*rot_zyx  // NG -> ...
<br>
ans_xyz*ans_zyx ->
<br>
(1,5.551115123125783e-17,5.551115123125783e-17:
<br>
5.551115123125783e-17,0.9999999999999999,0:
<br>
5.551115123125783e-17,0,0.9999999999999999)
<br>
ans_zyx*ans_xyz ->
<br>
(0.9999999999999999,0,-5.551115123125783e-17:
<br>
0,0.9999999999999999,-5.551115123125783e-17:
<br>
-5.551115123125783e-17,-5.551115123125783e-17,1)
<br>
・回転順序y⇒x⇒z
<br>
rot_zxy=&lt;{rotz*rotx*roty};
<br>
phi=pi/4; theta=3pi/4; psi=-3pi/4;
<br>
ans_zxy=rot_zxy; ans_zxy ->
<br>
(0.8535533905932737,0.5000000000000001,-0.14644660940672627:
<br>
0.14644660940672627,-0.5,-0.8535533905932737:
<br>
-0.5000000000000001,0.7071067811865475,-0.5)
<br>
・回転順序z⇒x⇒y
<br>
rot_yxz=&lt;{roty*rotx*rotz};
<br>
phi=-pi/4; theta=-3pi/4; psi=3pi/4;
<br>
ans_yxz=rot_yxz; ans_yxz ->
<br>
(0.8535533905932737,0.14644660940672627,-0.5000000000000001:
<br>
0.5000000000000001,-0.5,0.7071067811865475:
<br>
-0.14644660940672627,-0.8535533905932737,-0.5)
<br>
・同じく回転の逆回転を順序通りに記憶して演算すると単位行列に戻る
<br>
ans_yxz*ans_zxy ->
<br>
(1,5.551115123125783e-17,0:5.551115123125783e-17,1,0:0,0,1)
<br>
ans_zxy*ans_yxz ->
<br>
(1,0,-5.551115123125783e-17:0,1,0:-5.551115123125783e-17,0,1)
<br>
<br>
3D-graphicsで主流の左手系の場合
<br>
rotx_LHS=&lt;{rt=real(phi),=&lt;(1,,:,cos(rt),sin(rt):,-sin(rt),cos(rt))}=&gt;;
<br>
roty_LHS=&lt;{rt=real(theta),=&lt;(cos(rt),,-sin(rt):,1,:sin(rt),,cos(rt))}=&gt;;
<br>
rotz_LHS=&lt;{rt=real(psi),=&lt;(cos(rt),sin(rt),:-sin(rt),cos(rt),:,,1)}=&gt;;
<br>
・同義
<br>
rotx_LHS=&lt;{w=phi,phi=-phi,ret=rotx,phi=w,=&lt;ret}=&gt;;
<br>
roty_LHS=&lt;{w=theta,theta=-theta,ret=roty,theta=w,=&lt;ret}=&gt;;
<br>
rotz_LHS=&lt;{w=psi,psi=-psi,ret=rotz,psi=w,=&lt;ret}=&gt;;
<br>
・test caseを示す
<br>
phi=pi/4;
<br>
rotx ->
<br>
(
<br>
1,0,0:
<br>
0,0.7071067811865476,-0.7071067811865475:
<br>
0,0.7071067811865475,0.7071067811865476
<br>
)
<br>
rotx_LHS ->
<br>
(
<br>
1,0,0:
<br>
0,0.7071067811865476,0.7071067811865475:
<br>
0,-0.7071067811865475,0.7071067811865476
<br>
)
<br>
<br>
2Dの描画canvasも同様にz-index含めて左手系
<br>
・左上基準のclient座標系に対して手前方向をz-indexの正とする
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-vars"></span>
変数の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への代入・再代入方法は、変数名=代入値とする
<br>
x=2; x -> 2
<br>
x=2; x=4; x -> 4
<br>
x=2; x=2x; x -> 4
<br>
<br>
変数の命名規則を列挙する
<br>
・大文字と小文字を区別する
<br>
x=1; X=2; x+X -> 3
<br>
・変数名の後に続く数字は変数名に含まれる
<br>
x0=1; x1=2; x0+x1 -> 3
<br>
・binary文字の全角は半角に変換される
<br>
Ｘ＝３；X -> 3
<br>
・Multi-Byte文字を使用可
<br>
番号=1; 番号 -> 1
<br>
・<a href="#span-out-RW">予約語</a>は使用不可
<br>
max=3 -> [MyErr]Invalid ans isFound
<br>
・数字から開始不可
<br>
clear; 2x=4 -> [MyErr]Invalid ans isFound
<br>
・single||double quotation mark使用不可
<br>
' || " || '' || "" -> [MyErr]Invalid null string
<br>
"x"=2; "x" || x -> 2
<br>
""=2 || =2 -> 2
<br>
<br>
変数名を関数に渡す場合、変数名symbolと表記する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
予約変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-ans"></span>
予約変数の入力仕様と付随する留意事項について記述する
<br>
<br>
予約変数ans
<br>
・直前の実行文の演算結果を保持する
<br>
2; ans*2; ans*2; ans -> 8
<br>
2; (ans*2,ans*3); ans -> (4,6)
<br>
・代入ではansは更新されない
<br>
2; x=3; ans -> 2
<br>
・error終了時はansは更新されない
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数への
<br>
代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution"></span>
変数への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
変数への値の代入規則を列挙する
<br>
・代入する変数の左側に数値や演算子を置けない
<br>
clear; 2x=3 -> [MyErr]Invalid ans isFound
<br>
clear; 3+x=4 -> [MyErr]Invalid binary operation
<br>
・未定義変数の代入不可
<br>
clear; x=y(z) -> [MyErr]Invalid ans isFound
<br>
・このような場合、<a href="#span-out-eqns">式変数</a>を使用する
<br>
<br>
代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) -> 0
<br>
<br>
代入をcomma,またはcolon:で区切った場合、0を返す
<br>
clear; x=2,3x -> (0,6)
<br>
clear; x=2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
<br>
<br>
代入のnestingを許容する
<br>
clear; (a=(b=1),{c=2}) -> (0,0)
<br>
a,b,c -> (0,1,2)
<br>
clear; {a=((b=1),{c=2})}=(d=3)+1 -> 1
<br>
a,b,c,d -> (0,0,1,2,3)
<br>
clear; ({a=((b=1),{c=b+1})}=(d=c+1)+d) -> 3
<br>
a,b,c,d -> (0,0,1,2,3)
<br>
clear; d={a={(b=1),{c=2}}}; d -> 0
<br>
a,b,c,d -> (0,1,2,0:0)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列要素
<br>
pattern
<br>
matching
<br>
入力仕様
    </th>
    <td>
<span id="span-out-matching"></span>
行列要素pattern matchingの入力仕様と付随する留意事項について記述する
<br>
<br>
行列要素pattern matchingの定義
<br>
・<a href="#span-out-BT">括弧</a>のnestingを解決後、左辺と右辺の対応する各行列要素を比較
<br>
<br>
行列要素pattern matchingによる変数への値の代入規則を列挙する
<br>
・変数は無次元
<br>
・変数名symbolを$でescapeして右辺または左辺の値を代入
<br>
clear; ($a,{$b,3})=(1,{2,$c}); (a,{b,c}) -> (1,2:0,3)
<br>
・再代入も同様
<br>
($a,$b)=1(1,2); (a,b) -> (1,2)
<br>
・代入に無関係の要素は変化しない
<br>
($a,(a,c))=(b,{$b,c},4); (a,{b,c}) -> (2,1:0,3)
<br>
・変数$aが定義済みの場合、変数aへの代入不可
<br>
clear; $a=-1; ($a)=1 || (-1)=1 || =1-(-1) -> 2
<br>
clear; ($a)=1; a -> 1
<br>
・$でescapeしない場合、error終了
<br>
clear; (a)=1 -> [MyErr]Invalid REv(a)
<br>
・変数に代入する値が存在しない場合、error終了
<br>
clear; ($a,$b)=(1,$b) -> [MyErr]Invalid matching
<br>
clear; ($a,$b)=(1) -> [MyErr]Invalid matching(vars)
<br>
・<a href="#span-out-substitution">変数への代入</a>と異なり、nesting不可
<br>
clear; ($a,(($b)=3))=(1,2) -> [MyErr]Invalid matching(vars)
<br>
・変数を含む演算不可
<br>
clear; ($a,2)=2(1,$b) -> [MyErr]Invalid FN operation
<br>
・<a href="#span-out-substitution">変数への代入</a>と判別される場合、左右交換不可
<br>
clear; c=&lt;(1,2); ($a,$b)=c; a,b -> (1,2)
<br>
clear; c=&lt;(1,2); c=($a,$b) -> [MyErr]Invalid REv($a)
<br>
・1重列挙の場合
<br>
clear; c=&lt;(1,2); (c)=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); {c}=($a,$b); a,b -> (1,2)
<br>
・2重列挙の場合
<br>
clear; c=&lt;(1,2); (c,)=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); (,c)=($a,$b); a,b -> (0,1)
<br>
clear; c=&lt;(1,2); {c,}=($a,$b); a,b -> (1,2)
<br>
clear; c=&lt;(1,2); {,c}=($a,$b); a,b -> [MyErr]Invalid matching(vars)
<br>
・複数列挙の場合
<br>
clear; {($a,$b)=(1,2):($c,$d)=(3,4),(a,b,c,d)} -> (0,0:0,1,2,3,4)
<br>
・<a href="#span-out-RW">予約語</a>への代入不可
<br>
clear; $max || $$max || $$$max ->  [MyErr]Invalid max called
<br>
clear; ($max)=(2) -> [MyErr]Invalid max called
<br>
clear; ($$max)=(2) -> [MyErr]Invalid max called
<br>
clear; ($$$max)=(2) -> [MyErr]Invalid max called
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-eqns"></span>
式変数の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数へ代入・再代入方法は、式変数名=&lt;方程式または関数式とする
<br>
・式変数への代入を以降、式代入と呼ぶ
<br>
y=&lt;{a*x+b=0}; -> stored_eqn(y)
<br>
y=&lt;a*x+b=0; -> stored_eqn(y)
<br>
y=&lt;{a*x+b}; -> stored_eqn(y)
<br>
y=&lt;a*x+b; -> stored_eqn(y)
<br>
<br>
式変数から値を読出す方法は、式変数名=&gt;とする
<br>
式変数から<a href="#span-out-vars">変数</a>に値代入する方法は、式変数名=&gt;変数名とする
<br>
・式変数からの値読出しを以降、式読出しと呼ぶ
<br>
y=&lt;a*x+b; y=&gt; -> [MyErr]Invalid binary operation
<br>
y=&lt;a*x+b; y=&gt;y0 -> [MyErr]Invalid binary operation
<br>
<br>
関数式の<a href="#span-out-vars">変数</a>を定義して再度読出す
<br>
y=&lt;a*x+b; a=1; b=2; x=3; y=&gt; || 1*3+2 -> 5
<br>
y=&lt;a*x+b; a=1; b=2; x=3; y=&gt;y0; y0 -> 5
<br>
・式読出しを<a href="#span-out-BT">括弧</a>で括れば変数同様に扱える
<br>
2; y=&lt;ans; max(3,4(y=&gt;)2) || max(3,4*2*2) -> 16
<br>
2; y=&lt;ans; max(3,4(y=&gt;y0)2); y=&gt; -> 16
<br>
<br>
式変数と同名の変数が未定義の場合、直接、式読出し可
<br>
clear; y=&lt;a*x+b; a=1; b=2; x=3; 2y -> 10
<br>
clear; y=&lt;a*x+b; a=1; b=2; x=3; y0=2y; y0 -> 10
<br>
・ただし、式読出し記号=&gt;を明示する方が間違いが少ない
<br>
y=-1; y=&lt;a*x+b; a=1; b=2; x=3; 2y -> -2
<br>
y=-1; y=&lt;a*x+b; a=1; b=2; x=3; 2(y=&gt;) -> 10
<br>
・さらに、式変数名と変数名は区別する方が間違いが少ない
<br>
y=3; y=&lt;3y-1; 2y -> 6
<br>
y=3; y=&lt;3y-1; y=&gt;y; 2y -> 16
<br>
y0=3; y=&lt;3y0-1; y=&gt;y1; 2y1 -> 16
<br>
<br>
式変数名で明示して直接読出す方法も有り得る
<br>
clear; eqn_x=&lt;(a*x+b=0); a=1; b=2; x=3; 2eqn_x || 2*(-5) -> -10
<br>
<br>
以降、変数名と式変数名は被らない前提で式読出し記号=&gt;を省略する
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
式変数への
<br>
代入
<br>
入力仕様
    </th>
    <td>
<span id="span-out-substitution-equation"></span>
式変数への代入の入力仕様と付随する留意事項について記述する
<br>
<br>
式変数を循環参照した場合、error終了
<br>
・<a href="#span-out-FNh-RX">再帰高階関数</a>で代替のreccursive call非対応（call stackの独自実装無し）
<br>
clear; a=&lt;a; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a}; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;a=&gt;; a -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a=&gt;}; a -> [MyErr]Invalid circular(a)
<br>
・<a href="#span-out-config">strict-mode</a>の場合
<br>
clear; a=&lt;a=&gt;; a=&gt; -> [MyErr]Invalid circular(a)
<br>
clear; a=&lt;{a=&gt;}; a=&gt; -> [MyErr]Invalid circular(a)
<br>
<br>
Ver.2.19.6以降、<a href="#span-out-FN">関数</a>の参照渡しの仕様を廃止（無駄仕様と判断）
<br>
<del>
式変数名=&lt;関数名として関数名を任意に変更可（参照渡しを模擬）
<br>
clear; tr=&lt;trans; tr(1,2:3,4) || (tr=&gt;)(1,2:3,4) -> (1,3:2,4)
<br>
clear; htr=&lt;htrans; htr((htr(i,2i:3i,4i))[1]) -> (2i:4i)
<br>
clear; tr=&lt;trans; tr[2] -> [MyErr]Invalid FNm(transpose)
<br>
clear; trans=&lt;trans -> [MyErr]Invalid FNm(transpose)
<br>
・<a href="#span-out-FNh">高階関数</a>の場合
<br>
clear; d=&lt;_d -> [MyErr]Invalid FNh called
<br>
clear; dx=&lt;_dx; dx(=&lt;{x^2},1,2)
<br>
-> 3.999999999999929+3.5537737875913754e-14i+O(2e-11+1e-12i)
</del>
<br>
<br>
式代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=&lt;3) -> 0
<br>
<br>
式代入をcomma,またはcolon:で区切った場合、0を返す
<br>
clear; x=&lt;2,3x -> (0,6)
<br>
clear; x=&lt;2:3x -> (0:6)
<br>
<br>
詳細は<a href="#span-out-special">特殊仕様</a>参照
<br>
<br>
式変数を式代入可
<br>
・式変数の式代入を以降、通常の値渡しに対して式渡しと呼ぶ
<br>
・式読出し記号=&gt;を明示する場合
<br>
clear; eqn_x=&lt;3x; eqn_y=&lt;(eqn_x=&gt;); x=3; eqn_y=&gt; -> 9
<br>
・同名の変数未定義の前提で式読出し記号=&gt;を省略する場合
<br>
clear; eqn_x=&lt;3x; eqn_y=&lt;eqn_x; x=3; eqn_y -> 9
<br>
<br>
式渡しの仕様を列挙する
<br>
・式渡しの直接読出し
<br>
(=&lt;3)=&gt; -> 3
<br>
(=&lt;{3})=&gt; -> 3
<br>
({3})=&gt; -> [MyErr]Invalid mat([object Object])
<br>
(1,2,=&lt;3)=&gt; -> 3
<br>
(1,2,3)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
・一続きにまとめて変数値を読出す場合、最終要素となる引数を式渡し
<br>
・last<a href="#span-out-FNm">行列関数</a>は最終要素しか取り出せない
<br>
clear; (x=(1,2),=&lt;x)=&gt; -> (1,2)
<br>
clear; {x=(1,2:3,4),x=-x,=&lt;x}=&gt; -> (-1,-2:-3,-4)
<br>
clear; last(x=(1,2),x) -> 2
<br>
clear; last{x=(1,2:3,4),x=-x,x} -> -4
<br>
・<a href="#span-out-eqns">式変数</a>の場合も同様
<br>
clear; f=&lt;{x}; x=(1,2); f=&gt; -> (1,2)
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f)=&gt; -> (1,2)
<br>
clear; (f=&lt;{x},x=(1,2),f) -> (0,0,1,2)
<br>
clear; (f=&lt;{x},x=(1,2),f)=&gt; -> [MyErr]Invalid mat([object Object])
<br>
clear; last(f=&lt;{x},x=(1,2),f) -> 2
<br>
clear; last(f=&lt;{x},x=(1,2),=&lt;f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f=&lt;{x},x=(1,2),=&lt;f) -> [MyErr]Invalid BTe([object Object])
<br>
clear; (f=&lt;{x},x=(1,2),eqn_f=&lt;f); eqn_f -> (1,2)
<br>
・値渡しの場合、無条件に演算を実行するが、
<br>
・式渡しの場合、呼出しまで演算を実行しない
<br>
・本仕様は<a href="#span-out-BT">括弧</a>優先の<a href="#span-out-FNh">高階関数</a>の実装において必須
<br>
<br>
式代入のnestingを一例に示す
<br>
・式変数aのみが定義される
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); b -> [MyErr]Invalid REv(b)
<br>
clear; (a=&lt;(b={c=2})); b -> [MyErr]Invalid REv(b)
<br>
・式変数aとbを順番に実行することで式変数cが定義される
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,c -> [MyErr]Invalid REv(c)
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,b -> (0,0)
<br>
clear; (a=&lt;(b=&lt;{c=&lt;2})); a,b,c -> (0,0,2)
<br>
・式変数aを実行することで<a href="#span-out-vars">変数</a>bとcが定義される
<br>
clear; (a=&lt;(b={c=2})); a,c -> (0,2)
<br>
clear; (a=&lt;(b={c=2})); a,b -> (0,0)
<br>
clear; (a=&lt;(b={c=2})); a,b,c -> (0,0,2)
<br>
・以下、同様
<br>
clear; {a=&lt;((b=&lt;1),{c=&lt;2})}=(d=&lt;3)+1; a,b,c,d -> (0,0,1,2,3)
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)+d) -> [MyErr]Invalid binary operation
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)); d -> [MyErr]Invalid binary operation
<br>
clear; ({a=&lt;((b=&lt;1),{c=&lt;b+1})}=(d=&lt;c+1)); a,b,c,d -> (0,0,1,2,3)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; a -> [MyErr]Invalid REv(a)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,b -> [MyErr]Invalid REv(b)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,c -> [MyErr]Invalid REv(c)
<br>
clear; d=&lt;{a=&lt;{(b=&lt;1),{c=&lt;2}}}; d,a,b,c -> (0,0,1,2:0,0)
<br>
<br>
応用例は<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh"></span>
高階関数を列挙する
<br>
・<a href="#span-out-FNh-switch">switch高階関数</a>
<br>
・<a href="#span-out-FNh-SX">総和高階関数</a>
<br>
・<a href="#span-out-FNh-PX">総乗・総積高階関数</a>
<br>
・<a href="#span-out-FNh-RX">再帰高階関数</a>
<br>
・<a href="#span-out-FNh-DX">微分高階関数</a>
<br>
・<a href="#span-out-FNh-IX">積分高階関数</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
switch
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-switch"></span>
switch高階関数
<br>
・任意個数の条件分岐による処理を実行する
<br>
・条件文と成立時に実行する処理を対にしてcolon:区切りで引数を渡す
<br>
・引数の左から順番に条件文を判定する
<br>
・条件文が成立した場合、対の処理を実行して終了する
<br>
・条件文が不成立の場合、対の処理は実行されない
<br>
<br>
switch(第1引数,=&lt;第2引数:第3引数,=&lt;第4引数:...)
<br>
switch((第1引数,=&lt;第2引数):(第3引数,=&lt;第4引数):...)
<br>
switch({第1引数:=&lt;第2引数}:{第3引数:=&lt;第4引数}:...)
<br>
・引数
<br>
　・第奇数番引数: 0||0以外を返す条件文を値渡し
<br>
　・第偶数番引数: 条件文成立時に実行する処理を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・返値
<br>
　条件文成立時: 対の処理の演算結果を返す
<br>
　全条件文不成立時: 0を返す
<br>
<br>
値を返す場合
<br>
switch(第1引数,第2引数:第3引数,第4引数:...)
<br>
・引数
<br>
　・第奇数番引数: 0||0以外を返す条件文を値渡し
<br>
　・第偶数番引数: 条件文成立時の返却値を値渡し
<br>
・返値
<br>
　条件文成立時: 対の返却値を返す
<br>
　全条件文不成立時: 0を返す
<br>
<br>
次のNativeによるif文を一例に示す
<br>
if(x &gt;= 4) return 4;
<br>
else if(x &gt; 3) return 3;
<br>
else if(x &gt; 2) return 2;
<br>
else return -x;
<br>
・値渡しで記述する場合
<br>
x=2; switch(x&gt;=4,4:x&gt;3,3:x&gt;2,2:1,-x) -> -2
<br>
x=2; switch(ge(x,4),4:gt(x,3),3:gt(x,2),2:1,-x) -> -2
<br>
・値渡しの場合、行列要素の演算を実行後、次のswitch高階関数を実行する
<br>
x=2; switch(0,4:0,3:0,2:1,-2) -> -2
<br>
・<a href="#span-out-substitution-equation">式渡し</a>で記述する場合、条件文が成立した場合のみ対の処理を実行する
<br>
x=2; switch(x&gt;=4,=&lt;4:x&gt;3,=&lt;3:x&gt;2,=&lt;2:1,=&lt;{-x}) -> -2
<br>
x=2; switch(ge(x,4),=&lt;4:gt(x,3),=&lt;3:gt(x,2),=&lt;2:1,=&lt;{-x}) -> -2
<br>
<br>
未実装の論理演算子をbit演算子で代替する場合
<br>
・<a href="#span-out-prec-ope">演算子のprecedence</a>に応じて<a href="#span-out-BT">括弧</a>を明示する
<br>
・if(1==1 || 1==-1) return 1;のNG例
<br>
switch(1==1|1==-1,1) || switch(1==(1|1)==-1,1) -> 0
<br>
・if(1==1 || 1==-1) return 1;の一例
<br>
switch((1==1)|(1==-1),1) -> 1
<br>
・if(1==1 &amp;&amp; 1==-1) return 1;の一例
<br>
switch((1==1)&amp;(1==-1),1) -> 0
<br>
<br>
test caseを列挙する
<br>
switch(0) -> 0
<br>
switch(1) -> 0
<br>
switch(1,1) -> 1
<br>
switch(0,0:1,2:3,4) -> 2
<br>
switch(1,=&lt;{1}) -> 1
<br>
switch(0:1,=&lt;{1}) -> 1
<br>
switch(0,0:1,=&lt;{1}) || switch((0,0):(1,=&lt;{1})) || switch({0:0}:{1:=&lt;{1}}) -> 1
<br>
switch(0,0,1,=&lt;{1})  // NG -> 0
<br>
switch(0,0:0,0:0,0:1,=&lt;{1}:1,=&lt;{2}) -> 1
<br>
・実数の絶対値abs(real(x))を返す場合
<br>
x=1; switch(lt(real(x),0),=&lt;{-real(x)}:1,=&lt;{real(x)}) -> 1
<br>
x=-1; switch(lt(real(x),0),=&lt;{-real(x)}:1,=&lt;{real(x)}) -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
総和
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-SX"></span>
総和高階関数
<br>
・任意関数のdummy変数整数範囲[a,b]の総和を演算して返す
<br>
・_sdummy変数名symbolで呼出す
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_sdummy変数名symbol(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: dummy変数の範囲下限a（整数）を値渡し
<br>
・第3引数: dummy変数の範囲上限b（整数）を値渡し
<br>
option
<br>
・第4引数: dummy変数のstep（正の整数）を値渡し[省略時、1]
<br>
<br>
test caseを列挙する
<br>
・dummy変数n=1~10のnの総和
<br>
_sn(=&lt;{n},1,10) || 1+2+3+4+5+6+7+8+9+10 || (10+1)10/2 -> 55
<br>
・範囲反転を単なる逆順の演算で定義する
<br>
_Sn(=&lt;{n},10,1) || 10+9+8+7+6+5+4+3+2+1 -> 55
<br>
・dummy変数が負の場合も同様に定義する
<br>
_sn(=&lt;{n},-10,-1) || -10-9-8-7-6-5-4-3-2-1 -> -55
<br>
_Sn(=&lt;{n},-1,-10) || -1-2-3-4-5-6-7-8-9-10 -> -55
<br>
・以降、dummy変数に0を含めて記述する
<br>
・step=2の場合
<br>
_sn(=&lt;{n},0,10,2) || 0+2+4+6+8+10 -> 30
<br>
_Sn(=&lt;{n},10,0,2) || 10+8+6+4+2+0 -> 30
<br>
・step&lt;1の場合、暗黙で既定値に変換
<br>
_sn(=&lt;{n},0,10,0) || _sn(=&lt;{n},0,10,1) -> 55
<br>
・step&lt;0の場合、暗黙で絶対値に変換
<br>
_sn(=&lt;{n},0,10,-2) || _sn(=&lt;{n},0,10,2) -> 30
<br>
_Sn(=&lt;{n},10,0,-2) || _Sn(=&lt;{n},10,0,2) -> 30
<br>
・n=0~10の行列の総和
<br>
_sn(=&lt;{(n,2n:3n,4n)},N=2,5N) -> (55,110:165,220)
<br>
_Sn(=&lt;{(n,2n:3n,4n)},10,0) -> (55,110:165,220)
<br>
・2変数の多重総和
<br>
_sy(=&lt;{_sx(=&lt;{x+y},0,y)},0,2) || 0+1+2+2+3+4 -> 12
<br>
_Sy(=&lt;{_Sx(=&lt;{x+y},y,0)},2,0) || 4+3+2+2+1+0 -> 12
<br>
_sy(=&lt;{_Sx(=&lt;{x+y},y,0)},0,2) || 0+2+1+4+3+2 -> 12
<br>
_Sy(=&lt;{_sx(=&lt;{x+y},0,y)},2,0) || 0+2+3+4+1+2 -> 12
<br>
・総和を取るdummy変数はlocal変数から独立
<br>
x=-1; y=-2; _sy(=&lt;{_sx(=&lt;{x+y},0,y)},0,2); x+y -> -3
<br>
・<a href="#span-out-FNh">高階関数</a>の引数も関数同様に最終行vectorの左から順に参照
<br>
_sn(,is=0,:,ie=10,:=&lt;{n},is,ie) -> 55
<br>
・dummy変数は<a href="#span-out-vars">変数</a>の命名規則に準拠
<br>
_smax(=&lt;{0},1,2) -> [MyErr]Invalid max called
<br>
_spi(=&lt;{0},1,2) -> [MyErr]Invalid pi called
<br>
_s3(=&lt;{0},1,2) -> [MyErr]Invalid 3 called
<br>
_s3n(=&lt;{0},1,2) -> [MyErr]Invalid FNh called
<br>
<br>
応用例を示す
<br>
・1回試行で当たりの確率をPb[%]とする
<br>
・10回試行中、n回当たりの確率Pn[%]を<a href="#span-out-eqns">式変数</a>で定義する
<br>
storage cleared
<br>
Pb=3; Pn=&lt;{100combin(10,n)(Pb/100)^n((100-Pb)/100)^(10-n)};
<br>
n=0; Pn -> 73.74241268949281
<br>
n=1; Pn -> 22.806931759636946
<br>
n=2; Pn -> 3.1741606057226677
<br>
n=3; Pn -> 0.2617864417090862
<br>
n=4; Pn -> 0.014168853803842281
<br>
n=5; Pn -> 0.0005258543679776511
<br>
n=6; Pn -> 0.000013552947628290013
<br>
n=7; Pn -> 2.3952190212e-7
<br>
n=8; Pn -> 2.7779602049999973e-9
<br>
n=9; Pn -> 1.909250999999996e-11
<br>
n=10; Pn -> 5.904899999999982e-14
<br>
・10回試行中、N回以上当たりの確率[%]
<br>
N=10; _sn(=&lt;Pn,N,10) || 100(Pb/100)^N -> 5.904899999999982e-14
<br>
N=9; _sn(=&lt;Pn,N,10) -> 1.9151558999999963e-11
<br>
N=8; _sn(=&lt;Pn,N,10) -> 2.7971117639999973e-9
<br>
N=7; _sn(=&lt;Pn,N,10) -> 2.42319013884e-7
<br>
N=6; _sn(=&lt;Pn,N,10) -> 0.000013795266642174013
<br>
N=5; _sn(=&lt;Pn,N,10) -> 0.0005396496346198251
<br>
N=4; _sn(=&lt;Pn,N,10) -> 0.014708503438462106
<br>
N=3; _sn(=&lt;Pn,N,10) -> 0.27649494514754835
<br>
N=2; _sn(=&lt;Pn,N,10) -> 3.4506555508702164
<br>
N=1; _sn(=&lt;Pn,N,10) -> 26.257587310507166
<br>
N=0; _sn(=&lt;Pn,N,10) -> 99.99999999999999
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
総乗・総積
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-PX"></span>
総乗・総積高階関数
<br>
・任意関数のdummy変数整数範囲[a,b]の総乗・総積を演算して返す
<br>
・_pdummy変数名symbolで呼出す
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_pdummy変数名symbol(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: dummy変数の範囲下限a（整数）を値渡し
<br>
・第3引数: dummy変数の範囲上限b（整数）を値渡し
<br>
option
<br>
・第4引数: dummy変数のstep（正の整数）を値渡し[省略時、1]
<br>
<br>
test caseを列挙する
<br>
・dummy変数n=1~10のnの総乗
<br>
_pn(=&lt;{n},1,10) || 1*2*3*4*5*6*7*8*9*10 -> 3628800
<br>
・範囲反転を単なる逆順の演算で定義する
<br>
_Pn(=&lt;{n},10,1) || 10*9*8*7*6*5*4*3*2*1 -> 3628800
<br>
・dummy変数が負の場合も同様に定義する
<br>
_pn(=&lt;{n},-3,-1) || (-3)(-2)(-1) -> -6
<br>
_Pn(=&lt;{n},-1,-3) || (-1)(-2)(-3) -> -6
<br>
・step=2の場合
<br>
_pn(=&lt;{n},1,10,2) || 1*3*5*7*9 || 9!! -> 945
<br>
_Pn(=&lt;{n},10,1,2) || 10*8*6*4*2 || 10!! -> 3840
<br>
・step=3の場合
<br>
_pn(=&lt;{n},1,2,3) || 1 -> 1
<br>
_Pn(=&lt;{n},2,1,3) || 2 || 2!!! -> 2
<br>
・n=1~2の行列の総積
<br>
An=&lt;(n,2n:3n,4n); _pn(=&lt;{An},1,2) || (1,2:3,4)(2,4:6,8) -> (14,20:30,44)
<br>
An=&lt;(n,2n:3n,4n); _Pn(=&lt;{An},2,1) || (2,4:6,8)(1,2:3,4) -> (14,20:30,44)
<br>
・2変数の多重総乗
<br>
_py(=&lt;{_px(=&lt;{(x*y)},1,y)},1,3) || (1*1)(1*2)(2*2)(1*3)(2*3)(3*3) -> 1296
<br>
_Py(=&lt;{_Px(=&lt;{(x*y)},y,1)},3,1) || (3*3)(2*3)(1*3)(2*2)(1*2)(1*1) -> 1296
<br>
_py(=&lt;{_Px(=&lt;{(x*y)},y,1)},1,3) || (1*1)(2*2)(1*2)(3*3)(2*3)(1*3) -> 1296
<br>
_Py(=&lt;{_px(=&lt;{(x*y)},1,y)},3,1) || (1*3)(2*3)(3*3)(1*2)(2*2)(1*1) -> 1296
<br>
・任意行列Aの累乗
<br>
A=(1,2:3,4); N=2; _pn(=&lt;{A},1,N) -> (7,10:15,22)
<br>
A=(1,2:3,4); N=5; _pn(=&lt;{A},1,N) -> (1069,1558:2337,3406)
<br>
A=(1,2:3,4); N=5; _pn(=&lt;{trans(A)},1,N) -> (1069,2337:1558,3406)
<br>
・複素数の任意行列cAの累乗
<br>
cA=(e^{i(pi/4)},:,e^{i(-pi/4)}); N=4; _pn(=&lt;{cA},1,N)
<br>
-> (-1+2.7755575615628914e-16i,0:0,-1-2.7755575615628914e-16i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
再帰
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-RX"></span>
再帰高階関数
<br>
・任意処理の演算結果をdummy変数に代入する操作を再帰回数繰り返す
<br>
・最後の演算結果を返す
<br>
・_rdummy変数名symbolで呼出す
<br>
・dummy変数は無次元でlocal変数から独立する
<br>
<br>
_rdummy変数名symbol(=&lt;第1引数,第2引数,第3引数)
<br>
・第1引数: 任意処理を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: dummy変数の初期値を値渡し
<br>
・第3引数: 再帰回数（正の整数）を値渡し
<br>
<br>
test caseを列挙する
<br>
・再帰回数が0以下の場合、初期値を返す
<br>
・加算の漸化式
<br>
_rn(=&lt;{n+1},,0) -> 0
<br>
_rn(=&lt;{n+1},,1) -> 1
<br>
_rn(=&lt;{n+1},,2) -> 2
<br>
・同義
<br>
Pn=0; _rn(=&lt;{Pn=Pn+1},0,2); Pn -> 2
<br>
_rn(=&lt;{Pn=Pn+1},Pn=0,2); Pn -> 2
<br>
・初期値未定義の場合、error終了
<br>
clear; _rn(=&lt;{Pn=Pn+1},,2); Pn -> [MyErr]Invalid binary operation
<br>
・非同義（<a href="#span-out-substitution">変数への代入</a>は0が返る）
<br>
clear; _rn(=&lt;{n=n+1},,2)  // NG -> 0
<br>
clear; _rn(=&lt;{n=n+1},,2); n -> [MyErr]Invalid REv(n)
<br>
clear; _rn(=&lt;{n=n+1},n=0,2); n -> 0
<br>
・乗算の漸化式
<br>
_rn(=&lt;{n*2},1,0) -> 1
<br>
_rn(=&lt;{n*2},1,1) || 2^1 -> 2
<br>
_rn(=&lt;{n*2},1,2) || 2^2 -> 4
<br>
_rn(=&lt;{n*2},1,3) || 2^3 -> 8
<br>
・同義
<br>
Pn=1; _rn(=&lt;{Pn=Pn*2},0,3); Pn -> 8
<br>
_rn(=&lt;{Pn=Pn*2},Pn=1,3); Pn -> 8
<br>
・任意行列Aの累乗
<br>
An=(1,:,1); A=(1,2:3,4); N=2; _rn(=&lt;{An=An*A},,N); An -> (7,10:15,22)
<br>
_rn(=&lt;{An=An*(1,2:3,4)},An=(1,:,1),5); An -> (1069,1558:2337,3406)
<br>
・2変数の多重再帰
<br>
_ry(=&lt;{_rx(=&lt;{x+y},1,2)},1,2) || (1+(2+1))+3 -> 7
<br>
_Ry(=&lt;{_Rx(=&lt;{x+y+1},1,2)},1,2) -> 13
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
微分
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-DX"></span>
微分高階関数
<br>
・連続関数のdummy変数微分位置における微分係数を数値的に演算して返す
<br>
・精度優先で微分位置に応じた情報落ちを対策する
<br>
・数値誤差O(dx^4以上)を含み、演算結果に目安の解析誤差を表示する
<br>
・1階微分の差分刻み実数値dxDの既定値dxD=1e-3
<br>
・微分位置xでの差分刻みdxの既定値dx=max(1,abs(x))dxD(1+i)
<br>
・_ddummy変数名symbolで呼出す
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照するが、上書きしない
<br>
<br>
_ddummy変数名symbol(=&lt;第1引数[,第2引数[,第3引数[,第4引数]]])
<br>
・第1引数: dummy変数の関数式を<a href="#span-out-substitution-equation">式渡し</a>
<br>
option
<br>
・第2引数: 微分階数Ndash（正の整数）を値渡し[省略時、1]
<br>
・第3引数: 微分位置aを値渡し[省略時、local変数を参照]
<br>
・第4引数: 1階微分の差分刻みdx0を値渡し[省略時、dx既定値]
<br>
<br>
数値誤差に関する精度次数について記述する
<br>
・数値誤差は絶対誤差
<br>
・微分階数が1階上がる毎に差分刻み2倍を仮定
<br>
　stencilに応じたdx=dx0*2^(Ndash-1)
<br>
・微分階数が2階までは中心差分法による4次精度以下
<br>
・微分階数が3階以降は中心差分法による2次精度以下
<br>
<br>
詳細は<a href="#span-out-fdm-differential">微分の数値解法</a>参照
<br>
<br>
test caseを列挙する
<br>
・f(x)=(x+i)^5のx=1における微分を示す
<br>
x=1; dxD=1e-3; dx=max(1,abs(x))dxD(1+i); f=&lt;{(x+i)^5} -> stored_eqn(f)
<br>
・0階微分
<br>
_dx(=&lt;f,) || _dx(=&lt;f,0)
<br>
-> -4.000000000000002-4.000000000000001i
<br>
f -> -4.000000000000002-4.000000000000001i
<br>
・1階微分は4次精度
<br>
_dx(=&lt;f,1)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
_dx(=&lt;f)
<br>
-> -19.999999999980833-1.6714783492484858e-13i+O(1e-12+1e-12i)
<br>
・2階微分は4次精度以下
<br>
・差分刻みが異なる多重化とは完全には一致しない
<br>
_dx(=&lt;f,2)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
_dx(=&lt;{_dx(=&lt;f)})
<br>
-> -40.00000000012216+40.00000000037086i+O(7e-10+1e-12i)
<br>
・2階微分を4次精度1階微分で厳密に多重化する場合4次精度以下
<br>
_dx(=&lt;{_dx(=&lt;f,1,x,dx)},1,x,2dx)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
・3階微分以降は2次精度
<br>
・多重化は1階上がる毎に精度悪化
<br>
_dx(=&lt;f,3)
<br>
-> 2.6203811256259035e-11+120.00084001140233i+O(2e-2+2e-2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})
<br>
-> 4.378068605950494e-8+120.00000084539053i+O(2e-7+2e-7i)
<br>
・3階微分を4次精度1階微分で厳密に多重化する場合3次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)},1,x,2dx)},1,x,4dx)
<br>
-> -3.5859384520417787e-10+120.00000000321582i+O(3e-8+3e-8i)
<br>
・4階微分
<br>
_dx(=&lt;f,4)
<br>
-> 120.00000006268098+120.0000001718161i+O(1e+0+2e-2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})
<br>
-> 120.00001615650766+120.00019838028798i+O(1e-4+7e-7i)
<br>
・4階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)},1,x,2dx)},1,x,4dx)},1,x,8dx)
<br>
-> 119.99999887453464+120.00000028081901i+O(2e-6+1e-7i)
<br>
・5階微分
<br>
_dx(=&lt;f,5)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(2e+1+2e+1i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})
<br>
-> 119.18659727305976+0.3620753183716584i+O(5e-2+5e-2i)
<br>
・5階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(5e-5+5e-5i)
<br>
・6階微分
<br>
_dx(=&lt;f,6)
<br>
-> -0.0004498352662456228+0.0005560189878646384i+O(2e+2+4e+0i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})})
<br>
-> -322.002293591315+54.781879309774695i+O(3e+1+2e-1i)
<br>
・6階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)
<br>
-> -0.004201126114795549+0.005541058257682469i+O(1e-3+5e-5i)
<br>
・7階微分
<br>
_dx(=&lt;f,7)
<br>
-> -0.0007280114418273857+0.0030141311391229672i+O(9e+2+9e+2i)
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f)})})})})})})
<br>
-> -177398.93670986558-669172.3211788241i+O(1e+4+1e+4i)
<br>
・7階微分を4次精度1階微分で厳密に多重化する場合2次精度以下
<br>
_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;{_dx(=&lt;f,1,x,1dx)}
<br>
,1,x,2dx)},1,x,4dx)},1,x,8dx)},1,x,16dx)},1,x,32dx)},1,x,64dx)
<br>
-> -0.009902789205100404+0.05048924924402281i+O(5e-3+5e-3i)
<br>
・8階微分
<br>
_dx(=&lt;f,8)
<br>
-> 0.03950452954492218+0.04027593568552271i+O(4e+3+6e+1i)
<br>
・9階微分
<br>
_dx(=&lt;f,9)
<br>
-> -0.16566502311270223-0.015219989707358128i+O(4e+3+3e+3i)
<br>
・10階微分
<br>
_dx(=&lt;f,10)
<br>
-> 0.044163954487214524-0.06480605313760723i+O(3e+3+6e+1i)
<br>
・微分位置を大きくした場合
<br>
_dx(=&lt;{x^2},1,1e10)
<br>
-> 20000000000.027855-2.790277777777778e-12i+O(1e+28+1e-12i)
<br>
_dx(=&lt;{x^2},2,1e10)
<br>
-> 1.9999999995176474+9.657789228690995e-20i+O(2e+29+3e+10i)
<br>
_dx(=&lt;{x^2},3,1e10)
<br>
-> 1.894235601707095e-17-5.686908543633962e-27i+O(2e+15+5e-4i)
<br>
・微分位置を小さくした場合
<br>
_dx(=&lt;{x^2},1,1e-10)
<br>
-> 2.0000000041847774e-10+7.305374602696278e-19i+O(1e-12+1e-12i)
<br>
_dx(=&lt;{x^2},2,1e-10)
<br>
-> 2.0000000000000013+9.411477191714447e-16i+O(3e-10+2e-11i)
<br>
_dx(=&lt;{x^2},3,1e-10)
<br>
-> 1.5072697186506098e-13-7.131763305997033e-14i+O(2e-2+2e-2i)
<br>
・2変数の多重微分
<br>
_Dy(=&lt;{_Dx(=&lt;{x*y*y},1,0)},1,1)
<br>
-> 1.9999999999998288+1.8785308474662037e-13i+O(7e-10+1e-12i)
<br>
<br>
応用例を示す
<br>
・<a href="#span-out-non-linear">非線形方程式の解法</a>を使用
<br>
・微分方程式(x^3)"+x-7(1+i)=0の解析解x=1+iの求解
<br>
storage cleared
<br>
f=&lt;{_dx(=&lt;{x^3},2)+x-7(1+i)=0};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ri] 2.3549912261033786e-10+O(8e+0)
<br>
x -> infoLost[ri] 0.9999999999877383+1.0000000000273828i+O(1e-5+9e-6i)
<br>
・normが<a href="#span-out-epsilon">Machine epsilon</a>まで収束困難のため、一定回数の反復で打切る
<br>
・次に数値解の一例を示す
<br>
storage cleared
<br>
f=&lt;{2x*_dx(=&lt;{x*exp(3x)})=i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> 3.844899655887233e-14+O(8e+0)
<br>
x -> -0.17989326929739397-0.5079280004968542i+O(2e-1+5e-1i)
<br>
・続けて厳密解同等の数値解を示す
<br>
storage cleared
<br>
f=&lt;{2x*(1*exp(3x)+x*exp(3x)3)=i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{x}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[r ] 3.3306690738754696e-16
<br>
x -> infoLost[r ] -0.17989326929046887-0.5079280004963925i
<br>
・連立方程式の解析解{x0,x1}={1,1}の求解
<br>
storage cleared
<br>
f0=&lt;{1*x0^2+x1};
<br>
f1=&lt;{i*x1^3+x0};
<br>
x=&lt;{x0,x1};
<br>
f=&lt;{x0+x1=2,_dx0(=&lt;{f0})+_dx1(=&lt;{f1},2)=2+6i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[ri] 3.236567392072123e-11+O(7e+0)
<br>
x ->
<br>
(
<br>
infoLost[ri] 1.000000000003112+3.106688703682062e-12i+O(6e-5+5e-5i):
<br>
infoLost[ri] 0.9999999999968879-3.106688703682063e-12i+O(1e-5+2e-5i)
<br>
)
<br>
・同じく<a href="#span-out-ope">実数演算</a>の場合
<br>
storage cleared
<br>
f0=&lt;{1*x0^2+x1};
<br>
f1=&lt;{i*x1^3+x0};
<br>
x=&lt;{x0,x1};
<br>
f=&lt;{x0+x1=2,_dx0(=&lt;{f0})+_dx1(=&lt;{f1},2)=2+6i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> 7.724854831493598e-14+O(7e+0)
<br>
x -> (1.000000000000009+O(3e-5):0.9999999999999909+O(3e-5))
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
積分
<br>
高階関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNh-IX"></span>
積分高階関数
<br>
・連続関数のdummy変数積分範囲[a,b]における定積分を数値的に演算して返す
<br>
・数値誤差O(dxI^4以上)を含み、演算結果に目安の解析誤差を表示する
<br>
・積分範囲の分割数の既定値NI=100
<br>
・積分の差分刻みdxI=(b-a)/NI
<br>
・_idummy変数名symbolで呼出す
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照するが、上書きしない
<br>
<br>
_idummy変数名symbol(=&lt;第1引数,第2引数,第3引数[,第4引数])
<br>
・第1引数: dummy変数の関数式を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: dummy変数の積分下限aを値渡し
<br>
・第3引数: dummy変数の積分上限bを値渡し
<br>
option
<br>
・第4引数: 積分範囲の分割数（正の偶数）を値渡し[省略時、NI既定値]
<br>
<br>
数値誤差に関する精度次数について記述する
<br>
・数値誤差は絶対誤差
<br>
・既定で合成Simpson公式による4次精度
<br>
・台形公式による2次精度を<a href="#span-in-options">内部option</a>で選択可
<br>
<br>
詳細は<a href="#span-out-fdm-integral">積分の数値解法</a>参照
<br>
<br>
test caseを列挙する
<br>
・f(x)=x^4の積分範囲[0,1+i]における定積分を示す
<br>
a=0; b=1+i; ab=[a,b]; f=&lt;{x^4} -> stored_eqn(f)
<br>
・分割数100
<br>
_ix(=&lt;f,ab) || _ix(=&lt;f,a,b)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数10
<br>
_ix(=&lt;f,ab,10)
<br>
-> -0.8000533333333335-0.8000533333333333i+O(1e-4+1e-4i)
<br>
・分割数1000
<br>
_ix(=&lt;f,ab,1000)
<br>
-> -0.8000000000005332-0.800000000000533i+O(1e-12+1e-12i)
<br>
・積分範囲を反転
<br>
_ix(=&lt;f,[b,a]) || _ix(=&lt;f,b,a)
<br>
-> 0.8000000053333336+0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が奇数の場合、暗黙で+1して偶数に変換される
<br>
_ix(=&lt;f,ab,99) || _ix(=&lt;f,ab,99+1)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・分割数が負の場合、暗黙で絶対値に変換される
<br>
_ix(=&lt;f,ab,-100)
<br>
-> -0.8000000053333336-0.8000000053333334i+O(1e-8+1e-8i)
<br>
・2次精度選択の場合（参考）
<br>
_ix(=&lt;f,ab)
<br>
-> -0.8001333320000001-0.8001333319999999i+O(1e-4+1e-4i)
<br>
・2変数の多重積分
<br>
_iy(=&lt;{_ix(=&lt;{x^2*y},0,y)},0,2) -> 2.1333333475555563+O(2e-7)
<br>
_iy(=&lt;{y^4/3},0,2) -> 2.1333333475555563+O(2e-7)
<br>
・微分・積分
<br>
_ix(=&lt;{_dx(=&lt;{x^3})},1,2)
<br>
-> 7.000000000000061-3.369899113923336e-14i+O(1e-8+1e-14i)
<br>
_Ix(=&lt;{_Dx(=&lt;{sin(x)},1,0)},-pi,pi)
<br>
-> 6.283185307180439+2.010557877134426e-14i+O(2e-5+8e-14i)
<br>
・積分・微分
<br>
_dx(=&lt;{_ix(=&lt;{x^3},0,x)},1,2)
<br>
-> 7.999999999998895+5.517384388870678e-13i+O(4e-5+2e-5i)
<br>
<br>
応用例を示す
<br>
・<a href="#span-out-non-linear">非線形方程式の解法</a>を使用
<br>
・f(x)=x^2のx=[0,b]の定積分=3^3/3となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f=&lt;{_ix(=&lt;{x^2},0,b)=3^3/3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{b},=&lt;{1}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,12) -> infoLost[ i] 1.3839478914652153e-28+O(8e-7)
<br>
b -> infoLost[ri] 2.9999999999999996+4.613167602434132e-34i+O(1e-1+2e-1i)
<br>
・2次関数の積分の場合、補間多項式に一致するため、数値誤差が出ない
<br>
_ix(=&lt;{x^2},0,3,2) -> 9+O(5e+0)
<br>
_ix(=&lt;{x^2},0,3,10) -> 8.999999999999998+O(8e-3)
<br>
_ix(=&lt;{x^2},0,3,100) -> 8.999999999999998+O(8e-7)
<br>
_ix(=&lt;{x^2},0,3,1000) -> 8.999999999999998+O(8e-11)
<br>
・f(x)=x^4のx=[0,b]の定積分=3^5/5となる積分方程式の解析解b=3の求解
<br>
storage cleared
<br>
f=&lt;{_ix(=&lt;{x^4},0,b)=3^5/5};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;{b},=&lt;{1}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,20) -> 1.4210854715508634e-14+O(8e-7)
<br>
b -> infoLost[r ] 2.9999999959999992-1.15251646351758e-21i+O(2e-2+2e-2i)
<br>
・高次の関数の積分の場合、収束までの反復回数が増える
<br>
・得られる近似解の精度は分割数に依存する
<br>
_ix(=&lt;{x^4},0,3,2) -> 50.62499999999998+O(5e+0)
<br>
_ix(=&lt;{x^4},0,3,10) -> 48.60323999999998+O(8e-3)
<br>
_ix(=&lt;{x^4},0,3,100) -> 48.60000032400001+O(8e-7)
<br>
_ix(=&lt;{x^4},0,3,1000) -> 48.60000000003241+O(8e-11)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh"></span>
高階行列関数を列挙する
<br>
・<a href="#span-out-FNmh-jacobian">Jacobi高階行列関数</a>
<br>
・<a href="#span-out-FNmh-newtonian">Newton高階行列関数</a>
<br>
・<a href="#span-out-FNmh-OX">ODE高階行列関数</a>
<br>
・<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Jacobi
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-jacobian"></span>
Jacobi高階行列関数
<br>
・Jacobi行列を数値的に演算して返す
<br>
・数値的安定性・収束性を最優先
<br>
　精度を上げると不必要にNewton法の収束速度が悪化する
<br>
　微分位置に応じて差分刻みを可変すると収束速度が悪化する
<br>
・1次精度の数値誤差O(dx)を含むが、目安の解析誤差を評価・表示しない
<br>
・1階偏微分の差分刻み実数値dxJの既定値dxJ=1e-5
<br>
・微分位置xでの差分刻みdxの既定値dx=dxJ(1+i)
<br>
・未知変数のlocal変数を参照するが、上書きしない
<br>
<br>
Jacobi(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数]])
<br>
・第1引数: 方程式または関数式の列vectorを<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: 未知変数名symbolの列vectorを<a href="#span-out-substitution-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vectorを<a href="#span-out-substitution-equation">式渡し</a>[省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: 偏微分の差分刻みdxを値渡し[省略時、dx既定値]
<br>
<br>
xの1次方程式の偏微分係数を求める場合
<br>
clear; Jacobi(=&lt;{3x-3=0},=&lt;{x},=&lt;{0})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
clear; Jacobi(=&lt;{3x-3=0},=&lt;{x})
<br>
-> -3.0000000000098264+9.826647183188544e-12i
<br>
・右辺に移項した関数=-3x+3のx=0周辺の傾き-3を返す
<br>
<br>
xの2次関数の偏微分係数を求める場合
<br>
clear; Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{1})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
・1階偏微分の解析解=4xよりx=1周辺の傾き4を返す
<br>
<br>
微分位置を大きくした場合
<br>
clear; Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{1e10})  // NG
<br>
-> 19999999999.999996+19999999999.999996i
<br>
clear; a=1e10; h=max(1,abs(a))1e-5(1+i); Jacobi(=&lt;{2x^2},=&lt;{x},=&lt;{a},h)  // OK
<br>
-> 40000200000.65538+199999.3446694911i
<br>
・情報落ちの対策が必要
<br>
・1階偏微分の解析解=4xよりx=1e10周辺の傾き4e10を返す
<br>
<br>
未知変数のlocal変数を参照するが、上書きしない
<br>
storage cleared
<br>
x=1;
<br>
Jacobi(=&lt;{2x^2},=&lt;{x})
<br>
-> 4.0000200000131025+0.000019999986898147652i
<br>
x -> 1
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Newton
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-newtonian"></span>
Newton高階行列関数
<br>
・Newton法による反復1回の演算結果を返す
<br>
・引数は<a href="#span-out-FNmh-jacobian">Jacobi高階行列関数</a>に同じ
<br>
・返値は符号付の解の修正vector
<br>
・未知変数のlocal変数を参照、上書きする
<br>
<br>
Newton(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数]])
<br>
・第1引数: 方程式または関数式の列vectorを<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: 未知変数名symbolの列vectorを<a href="#span-out-substitution-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vectorを<a href="#span-out-substitution-equation">式渡し</a>[省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: 偏微分の差分刻みdxを値渡し[省略時、dx既定値]
<br>
<br>
応用例は<a href="#span-out-linear">連立方程式の解法</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
ODE
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-OX"></span>
ODE高階行列関数
<br>
・dummy変数を媒介する常微分方程式の1step定積分を数値的に演算して返す
<br>
・数値誤差O(dt^4以上)を含み、演算結果に目安の解析誤差を表示する
<br>
・1階常微分の差分刻み実数値dxTの既定値dxT=1e-3
<br>
・_odummy変数名symbolで呼出す
<br>
・dummy変数は無次元
<br>
・dummy変数と同名のlocal変数を参照、上書きする
<br>
・未知変数のlocal変数を参照、上書きする
<br>
<br>
_odummy変数名symbol(=&lt;第1引数,=&lt;第2引数[,=&lt;第3引数[,第4引数[,第5引数]]])
<br>
・第1引数: 1階常微分方程式右辺の関数式を<a href="#span-out-substitution-equation">式渡し</a>
<br>
・第2引数: 未知変数名symbolの列vectorを<a href="#span-out-substitution-equation">式渡し</a>
<br>
option
<br>
・第3引数: 未知変数初期値の列vectorを<a href="#span-out-substitution-equation">式渡し</a>[省略時、zeros-vector]
<br>
　第3引数は未知変数未定義時のみ有効
<br>
・第4引数: dummy変数初期値t0を値渡し[省略時、0]
<br>
　第4引数はdummy変数と同名のlocal変数未定義時のみ有効
<br>
・第5引数: 常微分の差分刻みdtを値渡し[省略時、dxT既定値]
<br>
<br>
数値誤差に関する精度次数について記述する
<br>
・数値誤差は絶対誤差
<br>
・既定で陽的Runge-Kutta法による4次精度
<br>
・陽的improved Euler法による2次精度を<a href="#span-in-options">内部option</a>で選択可
<br>
<br>
応用例は<a href="#span-out-evolution">時間発展の解法</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
symbolic
<br>
高階行列関数
<br>
入力仕様
    </th>
    <td>
<span id="span-out-FNmh-EX"></span>
symbolic高階行列関数
<br>
・未知変数名symbol連番0~のm行n列の<a href="#span-out-mat">行列</a>を<a href="#span-out-eqns">式変数</a>に<a href="#span-out-eqns">式代入</a>して0を返す
<br>
・_e式変数名symbol(=&lt;{未知変数名symbol},m,n)で呼出す
<br>
<br>
test caseを列挙する
<br>
・x=&lt;(x0,x1,x2,x3)
<br>
clear; _ex(=&lt;{x},1,4) -> 0
<br>
clear; _ex(=&lt;{x},1,4); x -> [MyErr]Invalid REv(x0)
<br>
clear; _ex(=&lt;{x},1,4); ($x0,$x1:$x2,$x3)=identity2; x -> (1,0,0,1)
<br>
clear; x=&lt;(x0,x1,x2,x3); ($x0,$x1:$x2,$x3)=identity2; x -> (1,0,0,1)
<br>
・x=&lt;(x0:x1:x2:x3)
<br>
clear; _ex(=&lt;{x},4,1); ($x0,$x1:$x2,$x3)=identity2; x -> (1:0:0:1)
<br>
clear; x=&lt;(x0:x1:x2:x3); ($x0,$x1:$x2,$x3)=identity2; x -> (1:0:0:1)
<br>
・x=&lt;(x0,x1:x2,x3)
<br>
clear; _ex(=&lt;{x},2,2); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
clear; x=&lt;(x0,x1:x2,x3); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
・symbol名は最終要素を参照
<br>
clear; _ex(=&lt;{test,test:x},2,2); x -> [MyErr]Invalid REv(test0)
<br>
clear; _ex(=&lt;{test,test:test,x},2,2); x -> [MyErr]Invalid REv(x0)
<br>
clear; _ex(=&lt;{test,test:test,x},2,2); ($x0,$x1,$x2,$x3)=(1,2,3,4); x -> (1,2:3,4)
<br>
・引数不正の場合、error終了
<br>
clear; _ex(=&lt;{x},2,0) -> [MyErr]Invalid matrix size
<br>
clear; _ex(=&lt;{x},2) -> [MyErr]Invalid EX arguments
<br>
<br>
応用例は<a href="#span-out-inverse">逆行列の解法</a>参照
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
行列積
<br>
の解法
    </th>
    <td>
<span id="span-out-mat-product"></span>
通常の行列積LR=L*Rのalgorithmについて記述する
<br>
<br>
通常の行列積LR=L*Rの定義を次に示す
<br>
・Lの列sizeとRの行sizeが一致する場合のみ、積を定義する
<br>
・内積
<br>
(1,2){3,4} -> 11
<br>
・cross積
<br>
{1,2}(3,4) -> (3,4:6,8)
<br>
・正方行列の累乗
<br>
(1,2:0,0)(1,2:0,0) -> (1,2:0,0)
<br>
(3,4:0,0)(3,4:0,0) -> (9,12:0,0)
<br>
<br>
行列sizeの異なる次のLとRを一例に示す
<br>
L=(1,2:3:4,5:6);
<br>
R=(1,2:3,4,5);
<br>
・演算子による行列積L*R
<br>
L*R -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
・行列size
<br>
sizer(L) -> 4
<br>
sizec(L) -> 2
<br>
sizer(R) -> 2
<br>
sizec(R) -> 3
<br>
sizer(L*R) -> 4
<br>
sizec(L*R) -> 3
<br>
・行列sizeについて次の関係が成立する
<br>
sizer(L*R)=sizer(L) -> 0
<br>
sizec(L*R)=sizec(R) -> 0
<br>
<br>
以上より、行列積のalgorithmを以下に示す
<br>
・L指定行とR指定列の内積を取る<a href="#span-out-eqns">式変数</a>productを定義する
<br>
・さらに、行列積LRを返す<a href="#span-out-eqns">式変数</a>LpRを定義する
<br>
LpR=&lt;{product=&lt;last{LR[ir][ic]=ttL[ir]trans((trans(ttR))[ic])},
<br>
ttL=trans(trans(L)),
<br>
ttR=trans(trans(R)),
<br>
LR=zeros(sizer(ttL),sizec(ttR)),
<br>
_sir(=&lt;{_sic(=&lt;product,0,sizec(ttR)-1)},0,sizer(ttL)-1),
<br>
=&lt;LR}=&gt;;
<br>
・演算子による行列積L*Rでは1回の転置trans(R)に最適化される
<br>
・また、この転置時にRの抜け要素を埋める
<br>
trans(R) -> (1,3:2,4:0,5)
<br>
・さらに、Lの抜け要素の部分はRと内積を取らない（自明の演算は行わない）
<br>
<br>
行列積L*Rの演算量を多少減らすために抜け要素を許容する
<br>
・N次下三角行列Lの場合、最高効率で演算量が半減する
<br>
・行列積の乗算回数を以下に比較して示す
<br>
・抜け要素を許容しない場合
<br>
N=4; N*N*N -> 64
<br>
N=10; N*N*N -> 1000
<br>
・抜け要素を許容する場合
<br>
N=4; _sn(=&lt;{n*n},1,N) -> 30
<br>
N=10; _sn(=&lt;{n*n},1,N) -> 385
<br>
・4次下三角行列Lの行列積
<br>
L=(1:2,3:4,5,6:7,8,9,10);
<br>
R=identity4;
<br>
LpR -> (1,0,0,0:2,3,0,0:4,5,6,0:7,8,9,10)
<br>
L*R -> (1,0,0,0:2,3,0,0:4,5,6,0:7,8,9,10)
<br>
<br>
test caseを列挙する
<br>
・上記例
<br>
L=(1,2:3:4,5:6);
<br>
R=(1,2:3,4,5);
<br>
LpR -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
L*R -> (7,10,10:3,6,0:19,28,25:6,12,0)
<br>
・定義できない行列積
<br>
L=(1,2);
<br>
R=(1,2);
<br>
LpR -> [MyErr]Invalid matrix operation
<br>
L*R -> [MyErr]Invalid matrix operation
<br>
・内積
<br>
L=(1+i,1);
<br>
R={1-i,1};
<br>
LpR -> 3
<br>
L*R -> 3
<br>
・cross積
<br>
L={1-i,1};
<br>
R=(1+i,1);
<br>
LpR -> (2,1-i:1+i,1)
<br>
L*R -> (2,1-i:1+i,1)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
有限
<br>
差分法
    </th>
    <td>
<span id="span-out-fdm"></span>
有限差分法の解法を列挙する
<br>
・<a href="#span-out-fdm-differential">微分の数値解法</a>
<br>
・<a href="#span-out-fdm-integral">積分の数値解法</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
微分
<br>
の数値解法
    </th>
    <td>
<span id="span-out-fdm-differential"></span>
有限差分による微分の数値解法について記述する
<br>
<br>
差分刻みをhとして連続関数f(x)のx周辺の2次打切りTaylor級数より
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+O(h^3)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+O(h^3)
<br>
・1階微分の2次精度中心差分
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O(h^2)
<br>
・2階微分の2次精度中心差分
<br>
f"(x)=(f(x+h)-2f(x)+f(x-h))/(h^2)+O(h^2)
<br>
<br>
2次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(f'(x+h)-f'(x-h))/(2h)=(f(x+2h)-f(x)-f(x)+f(x-2h))/(2h)^2+O(h)
<br>
・本来、2階微分の精度次数が落ちるが、H=2hとすれば精度次数が落ちない
<br>
f"(x)=(f(x+H)-2f(x)+f(x-H))/(H^2)+O(H^2)
<br>
・よって微分階数が1階上がる毎に差分刻み2倍の関係が成立すると仮定して
<br>
・3階微分以降も同様に、再帰的に多重化する
<br>
f'(x)=(f(x+h)-f(x-h))/(2h)+O((h)^2)
<br>
f"(x)=(f'(x+2h)-f'(x-2h))/(4h)+O((2h)^2)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+8h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
<br>
<br>
続いて4次打切りTaylor級数より
<br>
f(x-2h)=f(x)+f'(x)(-2h)+f"(x)(-2h)^2/2!+f"'(x)(-2h)^3/3!+f""(x)(-2h)^4/4!+O(h^5)
<br>
f(x-h)=f(x)+f'(x)(-h)+f"(x)(-h)^2/2!+f"'(x)(-h)^3/3!+f""(x)(-h)^4/4!+O(h^5)
<br>
f(x+h)=f(x)+f'(x)(h)+f"(x)(h)^2/2!+f"'(x)(h)^3/3!+f""(x)(h)^4/4!+O(h^5)
<br>
f(x+2h)=f(x)+f'(x)(2h)+f"(x)(2h)^2/2!+f"'(x)(2h)^3/3!+f""(x)(2h)^4/4!+O(h^5)
<br>
・次の3階微分を消去すれば
<br>
f(x+2h)-f(x-2h)=f'(x)(4h)-f"'(x)(2h)^3/3+O(h^5)
<br>
f(x+h)-f(x-h)=f'(x)(2h)-f"'(x)(h)^3/3+O(h^5)
<br>
・1階微分の4次精度中心差分
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
<br>
さらに、5次打切りTaylor級数より
<br>
・次の4階微分を消去すれば
<br>
f(x+2h)+f(x-2h)=2f(x)+f"(x)(2h)^2+f""(x)(2h)^4/12+O(h^6)
<br>
f(x+h)+f(x-h)=2f(x)+f"(x)(h)^2+f""(x)(h)^4/12+O(h^6)
<br>
・2階微分の4次精度中心差分
<br>
f"(x)=(16(f(x+h)+f(x-h))-(f(x+2h)+f(x-2h))-30f(x))/(12h^2)+O(h^4)
<br>
<br>
4次精度の1階微分を多重化して2階微分を導出する
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
・2次精度の場合と異なり、必要な離散点数が増えるが、
<br>
f'(x+h)=(8(f(x+2h)-f(x))-(f(x+3h)-f(x-h)))/(12h)
<br>
f'(x-h)=(8(f(x)-f(x-2h))-(f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)=(8(f(x+3h)-f(x+h))-(f(x+4h)-f(x)))/(12h)
<br>
f'(x-2h)=(8(f(x-h)-f(x-3h))-(f(x)-f(x-4h)))/(12h)
<br>
・stencilが2倍に広がる点は変わらない
<br>
f'(x+h)-f'(x-h)=(8(f(x+2h)-2f(x)+f(x-2h))-(f(x+3h)-f(x-h)+f(x+h)-f(x-3h)))/(12h)
<br>
f'(x+2h)-f'(x-2h)=(8(f(x+3h)-f(x+h)-f(x-h)+f(x-3h))-(f(x+4h)-2f(x)+f(x-4h)))/(12h)
<br>
・よって再帰的に多重化した場合、微分階数が上がる毎に精度が悪化する
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+h)-f'(x-h))-(f'(x+2h)-f'(x-2h)))/(12h)+O(h^3)
<br>
f"'(x)=(8(f"(x+h)-f"(x-h))-(f"(x+2h)-f"(x-2h)))/(12h)+O(h^2)
<br>
f""(x)=(8(f"'(x+h)-f"'(x-h))-(f"'(x+2h)-f"'(x-2h)))/(12h)+O(h)
<br>
...
<br>
<br>
2階微分の演算結果を示す
<br>
_dx(=&lt;{(x+i)^5},2,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
　・1階微分を多重化して再帰的に微分階数を上げる際、
<br>
　・拡張無しは差分刻み一定
<br>
　・拡張有りは1階上がる毎に差分刻み2倍の関係を仮定
<br>
-> -40.000079995027676+40.000100045239535i+O(5e-4+1e-6i)
<br>
-> -40.000199999917704+40.00019999969536i+O(2e-4+4e-6i)
<br>
-> -40.00000000012216+40.00000000037086i+O(7e-10+1e-12i)
<br>
-> -39.99999999980588+39.99999999944028i+O(3e-10+2e-11i)
<br>
・2階微分までは拡張の有無は大差ない
<br>
<br>
5階微分の演算結果を示す
<br>
_dx(=&lt;{(x+i)^5},5,1)
<br>
・上から順に、2次精度、2次精度拡張、4次精度、4次精度拡張
<br>
-> -2376.9807493302333+2495.6629047556085i+O(2e+4+2e+4i)
<br>
-> 120.00007406068326-0.0000085816675963221i+O(2e+1+2e+1i)
<br>
-> 119.18659727305976+0.3620753183716584i+O(5e-2+5e-2i)
<br>
-> 120.00037113527502-0.000050238369357712915i+O(5e-5+5e-5i)
<br>
・3階微分以降は拡張必須
<br>
<br>
以上より、微分階数が2階までは4次精度拡張、それ以降は2次精度拡張とする
<br>
・3階微分以降は精度より演算速度を優先
<br>
・非線形性が強い<a href="#span-out-FN">関数</a>・<a href="#span-out-series">級数</a>・<a href="#span-out-limit">極限</a>の演算結果は当てにならない
<br>
f'(x)=(8(f(x+h)-f(x-h))-(f(x+2h)-f(x-2h)))/(12h)+O(h^4)
<br>
f"(x)=(8(f'(x+2h)-f'(x-2h))-(f'(x+4h)-f'(x-4h)))/(24h)+O(h^3)
<br>
f"'(x)=(f"(x+4h)-f"(x-4h))/(8h)+O((4h)^2)
<br>
f""(x)=(f"'(x+4h)-f"'(x-8h))/(16h)+O((8h)^2)
<br>
...
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
積分
<br>
の数値解法
    </th>
    <td>
<span id="span-out-fdm-integral"></span>
有限差分による積分の数値解法について記述する
<br>
<br>
前提を列挙する
<br>
・2項演算子はleft-<a href="#span-out-associativity">associativity</a>を前提に記述する
<br>
・除算より<a href="#span-out-BRmo">記号省略乗算</a>優先を前提に記述する
<br>
・<a href="#span-out-FNm">行列</a>は本manualの構文を前提に記述する
<br>
・総和をΣ&lt;変数=開始値,終了値&gt;で記述する
<br>
・線形結合をvectorの内積で記述する
<br>
<br>
公式を導出する
<br>
・連続関数f(x)の積分範囲[a,b]をN等分割して差分刻みをhとする
<br>
h=(b-a)/N
<br>
・分割した離散点xiに対する関数の離散点f[i]を定義する
<br>
xi:=x[i]=a+i*h, i=0~N
<br>
f[i]=f(xi)
<br>
・分割した微小区間の面積dS[i]と全区間の面積Sを定義する
<br>
dS[i], i=0~N-1
<br>
S=Σ&lt;i=0,N-1&gt;dS[i]
<br>
・各変数は列vectorとして添字iで各要素の離散点を参照する
<br>
<br>
微小区間の関数fを線形補間する場合、2次精度の台形公式
<br>
・微小区間の台形の面積の総和を取ることで
<br>
dS[0]=(f[0]+f[1])h/2+O(h^3)
<br>
dS[i]=(f[i]+f[i+1])h/2+O(h^3)
<br>
S=Σ&lt;i=0,N-1&gt;dS[i]=Σ&lt;i=0,N-1&gt;(f[i]+f[i+1])h/2+O(h^2)
<br>
・次の台形公式が導出される
<br>
S=(f[0]+2Σ&lt;i=1,N-1&gt;f[i]+f[N])h/2+O(h^2)
<br>
・両端を除く離散点f[i]は2回足されて2倍
<br>
・全区間の離散化誤差のOrderは微小区間の正方形面積h*h
<br>
・総和によって微小区間の離散化誤差が積算されて精度次数が1次落ちる
<br>
<br>
微小区間の関数fを1次多項式で補間する場合も同様
<br>
・1次の補間多項式P1(x)を定義する
<br>
P1(x)=(1,x)(l:m)
<br>
・独立する2点の離散点xiに対する離散点f[i]から
<br>
P1(x0)=(1,x0)(l:m)=f[0]
<br>
P1(x1)=(1,x1)(l:m)=f[1]
<br>
・次の連立線形方程式V1*y1=r1を解くことで
<br>
V1=(1,x0:1,x1)
<br>
y1=(l:m)
<br>
r1=(f[0]:f[1])
<br>
・P1(x)の係数vector y1が求まる
<br>
・VはVandermonde行列
<br>
・離散点がすべて独立であればVの逆行列が一意に存在する
<br>
・予め逆行列を解いた方が丸め誤差の影響を受けにくい
<br>
・その形式に変形したLagrange基底の補間多項式を導出する
<br>
m=(f[0]-f[1])/(x0-x1)
<br>
l=f[0]-(f[0]-f[1])/(x0-x1)*x0
<br>
(l:m)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))(f[0]:f[1])
<br>
・y1=inverse(V1)*r1より
<br>
・V1の逆行列inverse(V1)
<br>
inverse(V1)=(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
・P1(x)=(1,x)(l:m)=(1,x)*inverse(V1)*(f[0]:f[1])より
<br>
・1次のLagrange基底多項式のvector L1=(1,x)*inverse(V1)
<br>
L1=(1,x)(-x1/(x0-x1),x0/(x0-x1):1/(x0-x1),-1/(x0-x1))
<br>
=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・1次のLagrange型の補間多項式
<br>
P1(x)=L1*(f[0]:f[1])
<br>
L1=((x-x1)/(x0-x1),(x-x0)/(x1-x0))
<br>
・P1(x)の不定積分integral(P1(x))
<br>
h=x1-x0
<br>
L1=(1/h)(-(x-x1),(x-x0))
<br>
integral(P1(x))=(1/2h)(-(x-x1)^2+C[0],(x-x0)^2+C[1])(f[0]:f[1])
<br>
・C[i]は積分定数
<br>
・P1(x)の微小区間[x0,x1]における定積分
<br>
dS[0]=(1/2h)(h^2,h^2)(f[0]:f[1])=(h/2)(1,1)(f[0]:f[1])=(f[0]+f[1])h/2
<br>
・以上より、次の台形公式が導出される
<br>
S=(f[0]+2Σ&lt;i=1,N-1&gt;f[i]+f[N])h/2+O(h^2)
<br>
<br>
微小区間の関数fを2次多項式で補間する場合、4次精度の合成Simpson公式
<br>
・2次の補間多項式P2(x)を定義する
<br>
P2(x)=(1,x,x^2)(l:m:n)
<br>
・独立する3点の離散点xiに対する離散点f[i]から
<br>
P2(x0)=(1,x0,x0^2)(l:m:n)=f[0]
<br>
P2(x1)=(1,x1,x1^2)(l:m:n)=f[1]
<br>
P2(x2)=(1,x2,x2^2)(l:m:n)=f[2]
<br>
・次の連立線形方程式V2*y2=r2を解くことで
<br>
V2=(1,x0,x0^2:1,x1,x1^2:1,x2,x2^2)
<br>
y2=(l:m:n)
<br>
r2=(f[0]:f[1]:f[2])
<br>
・P2(x)の係数vector y2が求まる
<br>
・以下、1次の場合同様に導出
<br>
・2次のLagrange型の補間多項式
<br>
P2(x)=L2*(f[0]:f[1]:f[2])
<br>
L2=(
<br>
(x-x1)(x-x2)/(x0-x1)(x0-x2),
<br>
(x-x0)(x-x2)/(x1-x0)(x1-x2),
<br>
(x-x0)(x-x1)/(x2-x0)(x2-x1))
<br>
・P2(x)の不定積分integral(P2(x))
<br>
h=x1-x0=x2-x1
<br>
L2=(1/(2h^2))((x-x1)(x-x2),-2(x-x0)(x-x2),(x-x0)(x-x1))
<br>
integral(P2(x))=(1/(2h^2))(
<br>
x^3/3-(x1+x2)x^2/2+x1*x2*x+C[0],
<br>
-2(x^3/3-(x0+x2)x^2/2+x0*x2*x+C[1]),
<br>
x^3/3-(x0+x1)x^2/2+x0*x1*x+C[2])(f[0]:f[1]:f[2])
<br>
・C[i]は積分定数
<br>
・P2(x)の微小2区間[x0,x2]における定積分
<br>
・1列目のみ示す
<br>
x0=x1-h
<br>
x2=x1+h
<br>
(x2^3-x0^3)/3-(x1+x2)(x2+x0)(x2-x0)/2+x1*x2(x2-x0)
<br>
=((x1+h)^3-(x1-h)^3)/3-(2x1+h)(2x1)h+x1(x1+h)2h
<br>
=(3x1^2+h^2)2h/3-(2x1+h)(x1)2h+x1(x1+h)2h
<br>
=(3x1^2+h^2-(2x1+h)(x1)3+x1(x1+h)3)2h/3
<br>
=(h^2)2h/3
<br>
・2列目以降も同様
<br>
・以上より、次のSimpson公式が導出される
<br>
dS[0]+dS[1]=(h/3)(1,4,1)(f[0]:f[1]:f[2])+O(h^5)
<br>
・さらに、分割数Nは正の偶数を前提として総和を取ることで
<br>
S=Σ&lt;k=0,N/2-1&gt;(dS[2k]+dS[2k+1])+O(h^4)
<br>
=(h/3)(Σ&lt;k=0,N/2-1&gt;((1,4,1)(f[2k]:f[2k+1]:f[2k+2])))+O(h^4)
<br>
・次の合成Simpson公式が導出される
<br>
S=(f[0]+4Σ&lt;k=0,N/2-1&gt;f[2k+1]+2Σ&lt;k=1,N/2-1&gt;f[2k]+f[N])h/3+O(h^4)
<br>
・両端を除く偶数の離散点f[2k]は2回足されて2倍
<br>
・全区間の離散化誤差のOrderは微小区間の正方形面積h*hの2乗
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
時間発展
<br>
の解法
    </th>
    <td>
<span id="span-out-evolution"></span>
時間発展（時間積分）の解法について記述する
<br>
<br>
球の空気抵抗Cd_sphereを考慮する2次元の運動方程式を一例に示す
<br>
・vector演算を<a href="#span-out-com">複素数</a>演算で代替
<br>
・t=0の複素数zの初期値
<br>
　・初期位置z_x0=0
<br>
　・初速z_v0=20+20i
<br>
・時間刻みdtの微小区間を積分する<a href="#span-out-eqns">式変数</a>stepを定義
<br>
・時間tの区間を積分する<a href="#span-out-eqns">式変数</a>evolutionを定義
<br>
・step毎に位置z_xと速度z_vの連立方程式fの近似解を反復法で求解
<br>
・時間微分を1次精度の有限差分で離散化する場合
<br>
　・右辺を既知関数とするEuler前進差分の陽解法explicit Euler method
<br>
f=&lt;{(z_x-z_x0)/dt=z_v0,m((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v0};
<br>
　・右辺を未知関数とするEuler後退差分の陰解法implicit Euler method
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
・速度の時間微分が0（抵抗と重力が平衡）となる終端速度terminal velocity
<br>
0=m*z_a-Cd_sphere*z_v_terminal
<br>
z_v_terminal=(m/Cd_sphere)*z_a
<br>
・implicit Euler methodによる1次精度の数値誤差O(dt)を含む近似解を以下に示す
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{(z_x-z_x0)/dt=z_v,m((z_v-z_v0)/dt)=m*z_a-Cd_sphere*z_v};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
/*step=&lt;last{_rn(=&lt;run,,3),z_x0=z_x,z_v0=z_v};*/
<br>
step=&lt;last{_rn(=&lt;run,,3),{$z_x0,$z_v0}=x};
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
・t=0の位置z_x0, 速度z_v0
<br>
t=0; evolution;
<br>
z_x0 -> 0
<br>
z_v0 -> 20+20i
<br>
・t=1の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 11.111111111111112+6.7555555555555555i
<br>
z_v0 -> infoLost[r ] 8.88888888888889+3.444444444444444i
<br>
・t=2の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 16.049382716049386+4.31358024691358i
<br>
z_v0 -> infoLost[ri] 3.9506172839506175-3.9135802469135803i
<br>
・t=3の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 18.244170096021953-2.216186556927298i
<br>
z_v0 -> infoLost[ri] 1.755829903978052-7.183813443072703i
<br>
・t=4の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.21963115378754-10.562749580856577i
<br>
z_v0 -> infoLost[ri] 0.7803688462124675-8.637250419143424i
<br>
・t=5の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.653169401683353-19.716777591491812i
<br>
z_v0 -> infoLost[ri] 0.3468305983166522-9.28322240850819i
<br>
・t=6の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.845853067414826-29.22967892955192i
<br>
z_v0 -> infoLost[ri] 0.15414693258517875-9.570321070448085i
<br>
・t=7の位置z_x0, 速度z_v0
<br>
t=1; evolution;
<br>
z_x0 -> infoLost[ri] 19.931490252184368-38.902079524245295i
<br>
z_v0 -> infoLost[ri] 0.068509747815635-9.697920475754705i
<br>
・t=10の位置z_x0, 速度z_v0
<br>
t=3; evolution;
<br>
z_x0 -> infoLost[ri] 19.99398542680357-68.20896171406268i
<br>
z_v0 -> infoLost[ri] 0.006014573196434349-9.791038285937313i
<br>
・terminal velocityに収束
<br>
z_v_terminal=(m/Cd_sphere)*z_a; z_v_terminal -> -9.8i
<br>
<br>
近似解の収束判定条件を設ける場合、stepの一例を示す
<br>
・上記の線形方程式の場合、反復3回で十分収束するため、固定値を設定
<br>
orderT=1;
<br>
Nmax=10;
<br>
epsf=max(eps*1e3,pow(dt,orderT));
<br>
step_pre=&lt;{normf=max_value};
<br>
step_iteration=&lt;_rn(=&lt;{switch(normf>epsf,=&lt;{normf=run})},,Nmax);
<br>
step_post=&lt;{{$z_x0,$z_v0}=x};
<br>
step=&lt;last{step_pre,step_iteration,step_post};
<br>
t=20; evolution; x ->
<br>
(
<br>
infoLost[ i] 19.99999819124547-166.20000269504428i:
<br>
infoLost[ i] 0.0000018087545367633257-9.79999730495574i
<br>
)
<br>
<br>
<a href="#span-out-FNmh-OX">ODE高階行列関数</a>を使用する場合、stepを陽的に解くため、収束演算不要
<br>
・実軸の時間積分の場合、目安の解析誤差は実数のみ表示される（仕様）
<br>
g=-9.8;
<br>
z_a=0+g*i;
<br>
z_v0=20+20i;
<br>
z_x0=0;
<br>
dt=0.5;
<br>
m=1;
<br>
Cd_sphere=1;
<br>
x=&lt;{z_x,z_v};
<br>
x_initial=&lt;{z_x0,z_v0};
<br>
f=&lt;{z_v,z_a-(Cd_sphere/m)*z_v};
<br>
step=&lt;{x_next=_otdummy(=&lt;f,=&lt;x,=&lt;x_initial,tdummy=0,dt)};
<br>
evolution=&lt;_rn(=&lt;step,N=round(t/dt),N);
<br>
{$z_x,$z_v}=x_initial;
<br>
・t=0
<br>
t=0; evolution; x ->
<br>
(
<br>
0:
<br>
20+20i
<br>
)
<br>
・t=1
<br>
t=1; evolution; x ->
<br>
(
<br>
12.636583116319443+9.028508843315972i+O(6e-2):
<br>
7.363416883680557+1.171491156684028i+O(6e-2)
<br>
)
<br>
・t=2
<br>
t=1; evolution; x ->
<br>
(
<br>
17.289004589856408+6.160616838886046i+O(6e-2):
<br>
2.710995410143594-5.760616838886047i+O(6e-2)
<br>
)
<br>
・t=3
<br>
t=1; evolution; x ->
<br>
(
<br>
19.001890531268412-1.0871831084100707i+O(6e-2):
<br>
0.9981094687315916-8.312816891589929i+O(6e-2)
<br>
)
<br>
・t=4
<br>
t=1; evolution; x ->
<br>
(
<br>
19.63252519430902-9.947537460479563i+O(6e-2):
<br>
0.36747480569098157-9.252462539520439i+O(6e-2)
<br>
)
<br>
・t=5
<br>
t=1; evolution; x ->
<br>
(
<br>
19.86470649057239-19.40158732904714i+O(6e-2):
<br>
0.1352935094276103-9.598412670952861i+O(6e-2)
<br>
)
<br>
・t=6
<br>
t=1; evolution; x ->
<br>
(
<br>
19.950188874421418-29.074218577112084i+O(6e-2):
<br>
0.049811125578583-9.725781422887913i+O(6e-2)
<br>
)
<br>
・t=7
<br>
t=1; evolution; x ->
<br>
(
<br>
19.981660995845978-38.827325116189485i+O(6e-2):
<br>
0.018339004154023522-9.772674883810506i+O(6e-2)
<br>
)
<br>
・t=10
<br>
t=3; evolution; x ->
<br>
(
<br>
19.999084783315336-68.20136367286014i+O(6e-2):
<br>
0.0009152166846619435-9.798636327139855i+O(6e-2)
<br>
)
<br>
・2次精度選択の場合（参考）
<br>
・t=10
<br>
t=10; evolution; x ->
<br>
(
<br>
19.998345638774897-68.20246499822541i+O(3e-1):
<br>
0.0016543612251060553-9.797535001774593i+O(3e-1)
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-linear"></span>
連立線形方程式の解法について記述する
<br>
<br>
連立方程式の解法には直接法と反復法の2種類が存在し、特徴を列挙する
<br>
・直接法は解を厳密に解くため、線形方程式のみ適用可
<br>
・反復法は解の修正を繰り返して近似的に解くため、非線形方程式に拡張可
<br>
<br>
full-rank2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
<br>
直接法
<br>
・pivot選択の前処理付きGaussの消去法を用いる
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
x=Gauss(A,b); x -> (-3.9999999999999982:4.499999999999999)
<br>
・解の二重check
<br>
A(x) -> (5:6.000000000000002)
<br>
・行列操作を駆使して演算内容を以下に示す
<br>
・pivot選択
<br>
A=(1,2:3,4); A=(A[1]:A[0]); A -> (3,4:1,2)
<br>
b={5,6}; b=(b[1]:b[0]); b -> (6:5)
<br>
・前進消去
<br>
k=A[1][0]/A[0][0]; k -> 0.3333333333333333
<br>
・行vectorの左から無次元係数kを積
<br>
A[1]=A[1]-k(A[0]); A -> (3,4:0,0.6666666666666667)
<br>
b[1]=b[1]-k(b[0]); b -> (6:3)
<br>
・後退代入
<br>
x={,}; x -> (0:0)
<br>
x[1]=b[1]/A[1][1]; x -> (0:4.499999999999999)
<br>
x[0]=(b[0]-A[0]x)/A[0][0]; x -> (-3.9999999999999982:4.499999999999999)
<br>
・<a href="#span-out-eqns">式変数</a>を使用して上記algorithmを一般化する
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1),
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp});
<br>
cond=&lt;{ir&lt;&gt;ir_pivot};
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w};
<br>
pivotting=&lt;{ir_comp=ir+1,ir_pivot=ir,compare,switch(cond,=&lt;proc),ir=ir+1,=&lt;A}=&gt;;
<br>
ir=0;
<br>
pivotting -> (3,4:1,2)
<br>
pivotting -> [MyErr]Invalid reference of array
<br>
forward=&lt;{ir=ir+1,k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic]),=&lt;A}=&gt;;
<br>
ic=0; ir=ic;
<br>
forward -> (3,4:0,0.6666666666666667)
<br>
forward -> [MyErr]Invalid reference of array
<br>
ic=ic+1; ir=ic;
<br>
forward -> [MyErr]Invalid reference of array
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir],ir=ir-1,=&lt;x}=&gt;;
<br>
ir -> 1
<br>
backward -> (0:4.499999999999999)
<br>
backward -> (-3.9999999999999982:4.499999999999999)
<br>
backward -> [MyErr]Invalid reference of array
<br>
・実際には自明の演算は行わないが、ここでは簡潔に記述する
<br>
・さらに、<a href="#span-out-FNh-SX">総和高階関数</a>を使用して反復処理を記述する
<br>
・dummy変数を使用するだけで総和は無次元の0を返す
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1),
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp});
<br>
cond=&lt;{ir&lt;&gt;ir_pivot};
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w};
<br>
pivotting=&lt;last{ir_pivot=ir,compare,switch(cond,=&lt;proc)};
<br>
_sir(=&lt;{_sir_comp(=&lt;pivotting,ir+1,sizeA-1)},0,sizeA-2);
<br>
A -> (3,4:1,2)
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A -> (3,4:0,0.6666666666666667)
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
_sir(=&lt;backward,sizeA-1,0);
<br>
x -> (-3.9999999999999982:4.499999999999999)
<br>
・最後に、一連のalgorithmを一般化した<a href="#span-out-eqns">式変数</a>solvexを定義する
<br>
・pivot選択有りの場合
<br>
storage cleared
<br>
solvex_pivotting=&lt;{
<br>
compare=&lt;switch(abs(A[ir][ir])&lt;abs(A[ir_comp][ir]),=&lt;{ir_pivot=ir_comp}),
<br>
cond=&lt;{ir&lt;&gt;ir_pivot},
<br>
proc=&lt;{w=A[ir],A[ir]=A[ir_pivot],A[ir_pivot]=w,w=b[ir],b[ir]=b[ir_pivot],b[ir_pivot]=w},
<br>
pivotting=&lt;last{ir_pivot=ir,compare,switch(cond,=&lt;proc)},
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])},
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]},
<br>
sizeA=size(A),
<br>
x=zeros(sizeA,1),
<br>
_sir(=&lt;{_sir_comp(=&lt;pivotting,ir+1,sizeA-1)},0,sizeA-2),
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0),
<br>
=&lt;x}=&gt;;
<br>
・pivot選択無しの場合
<br>
storage cleared
<br>
solvex_no_pivotting=&lt;{
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])},
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]},
<br>
sizeA=size(A),
<br>
x=zeros(sizeA,1),
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2),
<br>
_sir(=&lt;backward,sizeA-1,0),
<br>
=&lt;x}=&gt;;
<br>
・続けてtest caseを示す
<br>
・pivot選択有りの場合
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
solvex_pivotting -> (-3.9999999999999982:4.499999999999999)
<br>
・pivot選択無しの場合（参考）
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
solvex_no_pivotting -> (-4:4.5)
<br>
<br>
反復法
<br>
・連立方程式と未知変数初期値（以降、初期値と省略する）を定義する
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
b={5,6};
<br>
x0=0;
<br>
x1=0;
<br>
x=&lt;{x0,x1}; x_initial=&lt;{x0,x1};
<br>
・連立方程式を展開しない場合
<br>
f=&lt;{A(x)=b}; || f=&lt;{=b-A(x)}; || f=&lt;{b-A(x)};
<br>
・連立方程式を展開する場合
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
・いずれの結果も以下に同じ
<br>
・続けて以降の処理を反復する
<br>
J=Jacobi(=&lt;f,=&lt;x,=&lt;x_initial);
<br>
dx=Gauss(J,-f);
<br>
x_next=x+dx;
<br>
x0=x_next[0];
<br>
x1=x_next[1];
<br>
normf=max(norm(f),norm(-dx));
<br>
・反復3回目のnormと近似解を示す
<br>
normf -> infoLost[ri] 2.2204460494935903e-15
<br>
x0 -> infoLost[ri] -3.999999999999999-3.362471994400586e-26i
<br>
x1 -> infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
・normが<a href="#span-out-epsilon">Machine epsilon</a>に収束すれば収束判定条件を満たす
<br>
・その場合、近似解は厳密解にほぼ一致する
<br>
・線形方程式の場合、即座に解付近に飛ぶため、収束が速い
<br>
<br>
上記の線形・非線形の連立方程式を一般化する解法について記述する
<br>
・近似解の列vector{x}の各要素を表す添字をjとする
<br>
・方程式の列vector{f}の各要素を表す添字をiとする
<br>
・これより方程式の全微分dfを次のtensorで表記する
<br>
{df[i]}=(df[i]/dx[j]){dx[j]}
<br>
・左辺の全微分を単純に仮定すると（Jacobi行列に高精度を求めない理由）
<br>
{df[i]}={0-f[i]}
<br>
・Ax=bの連立線形方程式に一般化されたNewton法が導出される
<br>
・ここで符号はzeros行列との差分またはScalar倍で定義される
<br>
(df[i]/dx[j]){dx[j]}={-f[i]}
<br>
A=(df[i]/dx[j])
<br>
x={dx[j]}
<br>
b={-f[i]}
<br>
・Jacobi行列Aがfull-rankであれば求解の必要十分条件を満たす
<br>
・直接法で求解した解の修正vector dxを用いて近似解を修正する
<br>
<br>
上記の反復1回の処理をまとめた<a href="#span-out-FNmh-newtonian">Newton高階行列関数</a>について記述する
<br>
・引数は<a href="#span-out-FNmh-jacobian">Jacobi高階行列関数</a>に同じとする
<br>
・Scalar倍の符号位置を変えて次の連立線形方程式を直接法で解く
<br>
A=(df[i]/dx[j])
<br>
x={-dx[j]}
<br>
b={f[i]}
<br>
・さらに、得られた符号付の解の修正vectorをmdxとして
<br>
・近似解のvectorを一度に修正する（local変数を上書きする）
<br>
x=x-mdx
<br>
・関数の返値はmdxとする
<br>
<br>
以上より、反復1回の処理を簡潔にまとめる
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{0,0};
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
・実行用の<a href="#span-out-eqns">式変数</a>runを定義してnormのみ表示する
<br>
<br>
反復を実行
<br>
run -> 6.020797289251035
<br>
run -> 2.0548659974995737e-10
<br>
・反復3回目のnormと近似解は先述の通り一致する
<br>
run -> infoLost[ri] 2.2204460494935903e-15
<br>
x ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
)
<br>
<br>
<a href="#span-out-FNh-RX">再帰高階関数</a>を使用して反復を実行
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{0,0};
<br>
f=&lt;{x0+2x1=5,3x0+4x1=6};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.2204460494935903e-15
<br>
x ->
<br>
(
<br>
infoLost[ri] -3.999999999999999-3.362471994400586e-26i:
<br>
infoLost[ri] 4.499999999999999+6.466216308756395e-26i
<br>
)
<br>
<br>
rank落ち3元⇒実質2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
・Aの2行目を2倍して3行目を引くと1行目になる
<br>
・この場合、3階から2階へのrank落ちと呼ぶ
<br>
・rank落ちの場合、逆行列が不定で多くの場合、解が発散するが、
<br>
・本例では右辺bも成立するため、解が偶然見つかる
<br>
<br>
直接法
<br>
・解はalgorithmに従って一意に求まる
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=Gauss(A,b); x -> (-25.333333333333332:41.666666666666664:-16)
<br>
A(x) -> (10i:10.999999999999986i:12i)
<br>
・algorithmを以下に示す
<br>
・pivot選択は行列操作で示す
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i); A=(A[2]:A[1]:A[0]);
<br>
b={10i,11i,12i}; b=(b[2]:b[1]:b[0]);
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1);
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A ->
<br>
(
<br>
7i,8i,9i:
<br>
0,0.4285714285714288i,0.8571428571428577i:
<br>
0,-1.1102230246251565e-16i,-2.220446049250313e-16i
<br>
)
<br>
・前進消去後、rank落ちの対角要素は限りなく0に近づく
<br>
・よって多くの場合、次の後退代入で解が発散する
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
_sir(=&lt;backward,sizeA-1,0);
<br>
x -> (-25.333333333333332:41.666666666666664:-16)
<br>
・先述の<a href="#span-out-eqns">式変数</a>solvexを使用
<br>
・pivot選択有りの場合
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
solvex_pivotting -> (-25.333333333333332:41.666666666666664:-16)
<br>
・pivot選択無しの場合（参考）
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
solvex_no_pivotting -> [MyErr]FN isNaN
<br>
・前進消去後、rank落ちの対角要素が0になる
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
sizeA=size(A);
<br>
x=zeros(sizeA,1);
<br>
forward=&lt;last{k=A[ir][ic]/A[ic][ic],A[ir]=A[ir]-k(A[ic]),b[ir]=b[ir]-k(b[ic])};
<br>
_sic(=&lt;{_sir(=&lt;forward,ic+1,sizeA-1)},0,sizeA-2);
<br>
A -> (i,2i,3i:0,-3i,-6i:0,0,0)
<br>
・よって次の後退代入で解が発散する
<br>
backward=&lt;{x[ir]=(b[ir]-A[ir]x)/A[ir][ir]};
<br>
ir=sizeA-1; A[ir][ir] -> 0
<br>
backward -> [MyErr]FN isNaN
<br>
<br>
反復法
<br>
・解が不定のため、偶然得られる近似解は初期値によって大きく異なる
<br>
・初期値がzeros-vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;{0,0,0};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.000002904400992198821
<br>
x ->
<br>
(
<br>
338886.6528089325-469606.73307464283i:
<br>
-677782.3056178652+939213.4661492857i:
<br>
338895.986142266-469606.7330746428i
<br>
)
<br>
A(x) -> (-2.3283064365386963e-10+10.000000000116415i:11i:12i)
<br>
・初期値が虚数単位vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;{i,i,i};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.000011389894276669376
<br>
x ->
<br>
(
<br>
-6.91661370055543-4.416691871261055i:
<br>
4.833227401110859+8.83338374252211i:
<br>
2.4167196327779044-4.416691871261055i
<br>
)
<br>
A(x) -> (10.000000000000002i:11.000000000000005i:12.000000000000007i)
<br>
・初期値が直接法による厳密解の場合
<br>
・rank落ちの場合、近似解が厳密解に近づくとは限らない
<br>
・Jacobi行列の数値誤差が初期値の厳密解に上乗せして残る
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12i};
<br>
x=&lt;{x0,x1,x2}; x_initial=&lt;(-25.333333333333332:41.666666666666664:-16);
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> 0.00013856472352298855
<br>
x ->
<br>
(
<br>
-25.33341533331434-0.00008200052251608464i:
<br>
41.66683066662869+0.0001640010450321693i:
<br>
-16.000081999981045-0.00008200052251608478i
<br>
)
<br>
A(x) ->
<br>
(
<br>
3.2526065174565133e-19+9.999999999999915i:
<br>
6.505213034913027e-19+10.999999999999844i:
<br>
9.75781955236954e-19+11.999999999999773i
<br>
)
<br>
<br>
続けてrank落ち3元⇒実質2元1次の連立線形方程式Ax=bを一例に示す
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
・本例では右辺bが成立しないため、解が発散する
<br>
<br>
直接法
<br>
・解が17桁を超えて発散する
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
x=Gauss(A,b);
<br>
x ->
<br>
(
<br>
infoLost[r ] 54043195528445890+54043195528445910i:
<br>
-108086391056891790-108086391056891840i:
<br>
54043195528445900+54043195528445930i
<br>
)
<br>
A(x) -> (infoLost[r ] -32+32i:infoLost[r ] 64i:infoLost[r ] -64)
<br>
<br>
反復法
<br>
・初期値に依らず、解が発散する
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
b={10i,11i,12};
<br>
x=&lt;{x0,x1,x2};
<br>
f=&lt;{A(x)=b};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
run -> 234013055737.99323
<br>
run -> 44.17305431734149
<br>
run -> [MyErr]FN isNaN
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
逆行列
<br>
の解法
    </th>
    <td>
<span id="span-out-inverse"></span>
逆行列の反復解法について記述する
<br>
<br>
任意の正方行列Aについて
<br>
Ainv*A=単位行列identity(size(A))となるAの逆行列Ainvを反復法で求解する
<br>
<br>
full-rank2階の場合
<br>
storage cleared
<br>
A=(1,2:3,4);
<br>
Ainv=&lt;(x0,x1:x2,x3);
<br>
x=&lt;{x0,x1,x2,x3};
<br>
・連立方程式を展開しない場合
<br>
f=&lt;{Ainv*A=identity2}; || f=&lt;{=identity2-Ainv*A}; || f=&lt;{identity2-Ainv*A};
<br>
・連立方程式を展開する場合
<br>
f=&lt;{x0+3x1=1,2x0+4x1=0,x2+3x3=0,2x2+4x3=1};
<br>
・いずれの結果も以下に同じ
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 4.965068306494841e-16
<br>
Ainv ->
<br>
(
<br>
infoLost[ri] -2-1.405479820560668e-34i,
<br>
infoLost[ri] 1+7.02739910280334e-35i:
<br>
infoLost[ i] 1.5000000000000002+2.2201233082568935e-28i,
<br>
infoLost[ i] -0.5000000000000001+5.05296129055519e-28i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ri] 1+7.02739910280334e-35i,
<br>
infoLost[ri] 0:
<br>
infoLost[ i] -2.220446049250313e-16+1.7379007179922464e-27i,
<br>
infoLost[ i] 1+2.4652091778734548e-27i
<br>
)
<br>
<br>
<a href="#span-out-FNmh-EX">symbolic高階行列関数</a>を使用
<br>
・逆行列Ainvと未知変数ベクトルxを一般化して記述する
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8) || _eAinv(=&lt;{x},3,3) -> 0
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8} || _ex(=&lt;{x},3*3,1) -> 0
<br>
・逆行列を解く<a href="#span-out-eqns">式変数</a>solveAinvを定義する
<br>
solveAinv=&lt;{
<br>
sizeA=size(A),
<br>
_eAinv(=&lt;{x},sizeA,sizeA),
<br>
_ex(=&lt;{x},sizeA*sizeA,1),
<br>
f=&lt;{Ainv*A=identity(sizeA)},
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx))),
<br>
_rn(=&lt;run,,3),
<br>
=&lt;Ainv}=&gt;;
<br>
<br>
full-rank3階の場合
<br>
storage cleared
<br>
A=(i,2,3i:4,5i,6:7i,8,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 3.4546432349907805e-16
<br>
Ainv ->
<br>
・<a href="#span-out-eqns">式変数</a>solveAinvを使用
<br>
A=(i,2,3i:4,5i,6:7i,8,9i); solveAinv ->
<br>
(
<br>
infoLost[ri] -1.8979941071411976e-27+0.7750000000000002i,
<br>
infoLost[ri] 0.05-4.672139890674269e-28i,
<br>
infoLost[ri] 4.304317789445746e-28-0.22500000000000006i:
<br>
infoLost[ri] 0.05000000000000003+8.567561244782949e-29i,
<br>
infoLost[ri] 3.393936952792186e-29-0.1i,
<br>
infoLost[ri] 0.05+8.5354798231355e-30i:
<br>
infoLost[ri] 2.8820733759262382e-36-0.5583333333333333i,
<br>
infoLost[ri] 0.05+4.64802404929633e-38i,
<br>
infoLost[ri] -9.847979430502188e-37+0.10833333333333334i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ri] 1.0000000000000002-7.538276107988833e-28i,
<br>
infoLost[ri] 1.983535962611336e-27,
<br>
infoLost[ri] -4.623380245326983e-27i:
<br>
infoLost[ri] -9.666493098090539e-30+5.551115123125783e-17i,
<br>
infoLost[ri] 1+4.093319111203523e-28i,
<br>
infoLost[ri] -1.302099385841768e-28:
<br>
infoLost[ri] -3.82559126345344e-36i,
<br>
infoLost[ri] -2.3466379950140902e-36,
<br>
infoLost[ri] 1+6.192008328452557e-38i
<br>
)
<br>
<br>
full-rank4階の場合
<br>
storage cleared
<br>
A=(i+1,2-i,3i,4:5i,6-i,7,8i:9-5i,10i,-11+3i,12-5i:-13,14i,-15,16i);
<br>
Ainv=&lt;(x0,x1,x2,x3:x4,x5,x6,x7:x8,x9,x10,x11:x12,x13,x14,x15);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15};
<br>
f=&lt;{Ainv*A=identity4};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,3) -> infoLost[ri] 2.9893669801409083e-16
<br>
Ainv ->
<br>
・<a href="#span-out-eqns">式変数</a>solveAinvを使用
<br>
A=(i+1,2-i,3i,4:5i,6-i,7,8i:9-5i,10i,-11+3i,12-5i:-13,14i,-15,16i); solveAinv ->
<br>
(
<br>
0.06841552622694629+0.2755281676127789i,
<br>
infoLost[r ] 0.017370056945596502+0.04070708231511685i,
<br>
0.03704852337184109+0.014871122300002907i,
<br>
infoLost[r ] -0.0771427485472948+0.029183958646809872i:
<br>
infoLost[r ] -0.2463189713572816+0.22391026429285282i,
<br>
0.03674146878053252-0.07376715131162677i,
<br>
infoLost[ i] 0.011750959713282166-0.06258676545881785i,
<br>
infoLost[r ] -0.023736051458965405-0.035441311604425964i:
<br>
0.042729078026869684-0.37565683291263197i,
<br>
infoLost[ri] 0.10071161649924316+0.02655781643708819i,
<br>
0.018188177584406696+0.012939541975857932i,
<br>
0.039537548991770054+0.015088101343933952i:
<br>
infoLost[ i] 0.08721745526741176-0.29156760696583045i,
<br>
infoLost[ i] 0.025823672107836676-0.04398405433866421i,
<br>
0.013931517721997284+0.007610078051463436i,
<br>
infoLost[ri] 0.05862610643706584-0.005876821331234674i
<br>
)
<br>
Ainv*A ->
<br>
(
<br>
infoLost[r ] 1+5.551115123125783e-17i,
<br>
infoLost[r ] 5.551115123125783e-17-2.220446049250313e-16i,
<br>
infoLost[r ] 2.220446049250313e-16+5.551115123125783e-17i,
<br>
infoLost[r ] 1.1102230246251565e-16+2.220446049250313e-16i:
<br>
infoLost[ri] -5.551115123125783e-17-5.551115123125783e-17i,
<br>
infoLost[ri] 1+1.1102230246251565e-16i,
<br>
infoLost[ri] -1.1102230246251565e-16+1.1102230246251565e-16i,
<br>
infoLost[ri] -1.1102230246251565e-16+5.551115123125783e-17i:
<br>
infoLost[ri] -1.1102230246251565e-16+5.551115123125783e-17i,
<br>
infoLost[ri] -2.7755575615628914e-17+1.1102230246251565e-16i,
<br>
infoLost[ri] 0.9999999999999998,
<br>
infoLost[ri] 0:
<br>
infoLost[ri] -4.163336342344337e-17i,
<br>
infoLost[ri] -1.1102230246251565e-16i,
<br>
infoLost[ri] 2.220446049250313e-16-1.3877787807814457e-17i,
<br>
infoLost[ri] 1-1.1102230246251565e-16i
<br>
)
<br>
<br>
rank落ち3階⇒実質2階の場合
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
・rank落ちの場合、逆行列が一意に定まらず、不定となる
<br>
・また、行列式は限りなく0に近づく
<br>
・よって多くの場合、逆行列を求める過程で発散する
<br>
・初期値がzeros-vectorの場合
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
f=&lt;{
<br>
x0(i)+x1(4i)+x2(7i)=1,x0(2i)+x1(5i)+x2(8i)=0,x0(3i)+x1(6i)+x2(9i)=0,
<br>
x3(i)+x4(4i)+x5(7i)=0,x3(2i)+x4(5i)+x5(8i)=1,x3(3i)+x4(6i)+x5(9i)=0,
<br>
x6(i)+x7(4i)+x8(7i)=0,x6(2i)+x7(5i)+x8(8i)=0,x6(3i)+x7(6i)+x8(9i)=1
<br>
};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x),max(norm(f),norm(mdx)));
<br>
run -> infoLost[ i] 2787964185176708
<br>
run -> [MyErr]FN isNaN
<br>
・初期値を変えてもnormが収束することはない
<br>
storage cleared
<br>
A=(i,2i,3i:4i,5i,6i:7i,8i,9i);
<br>
Ainv=&lt;(x0,x1,x2:x3,x4,x5:x6,x7,x8);
<br>
x=&lt;{x0,x1,x2,x3,x4,x5,x6,x7,x8};
<br>
h=(-i);
<br>
x_initial=&lt;{h,h,h,h,h,h,h,h,h};
<br>
f=&lt;{Ainv*A=identity3};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
run -> infoLost[ i] 23884062379.765785
<br>
run -> infoLost[ i] 3.9299189118519258
<br>
run -> infoLost[ i] 3.5355470563991256
<br>
Ainv*A ->
<br>
(
<br>
infoLost[ i] 1.00262451171875-0.20006942749023438i,
<br>
infoLost[ i] 0.22774887084960938-0.0094451904296875i,
<br>
infoLost[ i] -0.547119140625+0.18117904663085938i:
<br>
infoLost[ i] -0.042938232421875-0.18405914306640625i,
<br>
infoLost[ i] 0.2579803466796875+0.04792022705078125i,
<br>
infoLost[ i] 0.55889892578125+0.2799072265625i:
<br>
infoLost[ i] 0.149261474609375+0.017391204833984375i,
<br>
infoLost[ i] 0.5675315856933594+0.01317596435546875i,
<br>
infoLost[ i] 0.9858055114746094+0.008953094482421875i
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
連立
<br>
非線形方程式
<br>
の解法
    </th>
    <td>
<span id="span-out-non-linear"></span>
連立非線形方程式の反復解法について記述する
<br>
<br>
虚数単位を求めるfull-rank1元2次の方程式を一例に示す
<br>
x0^2+1=0
<br>
・解を2個示す
<br>
x0=i; x0^2+1=0 -> -1.2246467991473532e-16i
<br>
x0=-i; x0^2+1=0 -> 1.2246467991473532e-16i
<br>
・非線形方程式を定義する
<br>
storage cleared
<br>
x=&lt;{x0};
<br>
f=&lt;{x0^2+1=0};
<br>
<br>
初期値を1+2iとした反復6回目の近似解を示す
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;{1+2i}),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> 4.848187063331881e-11
<br>
x -> 6.918085522901255e-17+0.9999999999999997i
<br>
<br>
初期値を1-2iとした反復6回目の近似解を示す
<br>
・上記演算に続けてClear実行しない場合、初期値を直接更新して実行
<br>
x0=1-2i;
<br>
_rn(=&lt;run,,6) -> 4.2544881989018353e-11
<br>
x -> -5.067058578678027e-17-1.0000000000000002i
<br>
・方程式または関数の次数に応じて収束までの反復回数が増える
<br>
<br>
<a href="#span-out-ope">実数演算</a>の場合、解が存在しないため、収束しない
<br>
・2次の方程式の場合、右辺に移項した関数の極値周辺を右往左往する
<br>
storage cleared
<br>
x=&lt;{x0};
<br>
f=&lt;{real(x0)^2+1=0}; || f=&lt;{-(real(x0)^2+1)};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;{1}),max(norm(f),norm(mdx)));
<br>
run -> 1.414206491330789
<br>
run -> 2500010689.1876636
<br>
run -> 625005364.923743
<br>
run -> 156251267.10125032
<br>
run -> 39062798.523787886
<br>
run -> 9765710.483364047
<br>
run -> 2441427.7048029117
<br>
run -> 610357.137491086
<br>
run -> 152589.53659088546
<br>
run -> 38147.63324071567
<br>
<br>
以上の結果をまとめる
<br>
・解が複数存在する場合、得られる近似解は初期値に依存する
<br>
・解が存在しない場合、解が収束しないか解が無限大に発散する
<br>
・高次の方程式または関数の場合、解が存在しても初期値によっては発散する
<br>
<br>
次に関数を使用したfull-rank2元の連立非線形方程式を一例に示す
<br>
・連立非線形方程式と初期値を定義する
<br>
・反復6回目の近似解を示す
<br>
storage cleared
<br>
x=&lt;{x0,x1}; x_initial=&lt;{1+i,1-i};
<br>
f=&lt;{x0^i-2x1=3i,3x0+exp(x1)=5i};
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ i] 2.2368035825474494e-16
<br>
x ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
<br>
<br>
同じく引数の列vectorに丸括弧()を使用する場合
<br>
・連立非線形方程式と初期値を定義する
<br>
・反復6回目の近似解を示す
<br>
storage cleared
<br>
x=&lt;(x0:x1); x_initial=&lt;(1+i:1-i);
<br>
f=&lt;(x0^i-2x1=3i:3x0+exp(x1)=5i);
<br>
run=&lt;last(mdx=Newton(=&lt;f,=&lt;x,=&lt;x_initial),max(norm(f),norm(mdx)));
<br>
_rn(=&lt;run,,6) -> infoLost[ i] 2.2368035825474494e-16
<br>
x ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
<br>
<br>
同じく引数の列vectorを直接<a href="#span-out-substitution-equation">式渡し</a>する場合
<br>
・mdxのnormを返す<a href="#span-out-eqns">式変数</a>runを定義して反復6回目の近似解を示す
<br>
storage cleared
<br>
run=&lt;last(
<br>
mdx=Newton(=&lt;(x0^i-2x1=3i:3x0+exp(x1)=5i),=&lt;(x0:x1),=&lt;(1+i:1-i)),
<br>
norm(mdx));
<br>
_rn(=&lt;run,,6) -> 2.2368035825474494e-16
<br>
{x0,x1} ->
<br>
(
<br>
infoLost[ i] -0.04901921620544653+2.023423045158351i:
<br>
0.07726186556052178-1.434248862158042i
<br>
)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
級数展開
<br>
の解法
    </th>
    <td>
<span id="span-out-series"></span>
級数展開の解法を列挙する
<br>
・<a href="#span-out-series-Taylor">Taylor級数・Maclaurin級数の解法</a>
<br>
・<a href="#span-out-series-Fourier">Fourier級数の解法</a>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Taylor・
<br>
Maclaurin
<br>
級数の解法
    </th>
    <td>
<span id="span-out-series-Taylor"></span>
Taylor級数・Maclaurin級数の解法について記述する
<br>
・Computer Algebra System未実装で得られる解は数値解
<br>
・<a href="#span-out-FNh-DX">微分高階関数</a>の精度に依存
<br>
・3階微分以降、既定の2次精度では精度不足
<br>
<br>
Taylor級数・Maclaurin級数
<br>
・0の0乗の定義
<br>
0^0 || 0**0 || pow(0,0) -> 1
<br>
・f(x)のx=a周辺のN次打切りTaylor級数TaylorN
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
・f(x)のx=0周辺のN次打切りMaclaurin級数MaclaurinN
<br>
MaclaurinN=&lt;_sn(=&lt;{_dx(=&lt;f,n,0)x^n/n!},0,N);
<br>
・f(x)=exp(x)の場合
<br>
f=&lt;exp(x);
<br>
x=2; f -> 7.38905609893065
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
MaclaurinN=&lt;_sn(=&lt;{_dx(=&lt;f,n,0)x^n/n!},0,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=3; TaylorN || MaclaurinN -> 6.3333380025161095+O(4e-2)
<br>
N=5; TaylorN || MaclaurinN -> 7.266696174805806+O(2e+1)
<br>
N=7; TaylorN || MaclaurinN -> 7.381056210596976+O(2e+2)
<br>
・<a href="#span-out-com">複素数</a>演算の場合
<br>
TaylorN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},0,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=3; TaylorN -> 6.333333332137665+0.00000933215700063301i+O(2e-2+2e-2i)
<br>
N=5; TaylorN -> 7.266666317607307+0.000058921777380024245i+O(4e+0+4e+0i)
<br>
N=7; TaylorN -> 7.38095752867692+0.00014973248523188646i+O(2e+1+2e+1i)
<br>
<br>
収束性
<br>
・Taylor級数のN次の項TN
<br>
TN=&lt;_sn(=&lt;{_dx(=&lt;f,n,a)(x-a)^n/n!},N,N);
<br>
f=&lt;exp(x);
<br>
x=2;
<br>
a=0;
<br>
N=0; TN -> 1
<br>
N=1; TN -> 2.000000000000264+3.199902245182912e-15i+O(2e-12+2e-12i)
<br>
N=2; TN -> 2.0000000000047273-3.0553419555181785e-12i+O(7e-10+3e-11i)
<br>
N=3; TN -> 1.3333333321326732+0.000009332160052775064i+O(2e-2+2e-2i)
<br>
N=4; TN -> 0.6666667002412976+0.000018888944812360706i+O(7e-1+1e-2i)
<br>
N=5; TN -> 0.26666628522834573+0.00003070067556703053i+O(4e+0+4e+0i)
<br>
N=6; TN -> 0.0888888278111036+0.000037059768491892605i+O(2e+1+3e-1i)
<br>
N=7; TN -> 0.025402383258507955+0.00005375093935996962i+O(2e+1+2e+1i)
<br>
N=8; TN -> 0.006352708017224355+0.00004619914542548148i+O(2e+1+4e-1i)
<br>
N=9; TN -> 0.0014113419838348632+0.000038423321810908794i+O(5e+0+5e+0i)
<br>
N=10; TN -> 0.000280289701751799+0.00003279136299319164i+O(1e+0+2e-2i)
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
Fourier
<br>
級数の解法
    </th>
    <td>
<span id="span-out-series-Fourier"></span>
Fourier級数の解法について記述する
<br>
・Computer Algebra System未実装で得られる解は数値解
<br>
・<a href="#span-out-FNh-IX">積分高階関数</a>の精度に依存
<br>
・既定で4次精度の積分範囲100分割
<br>
<br>
Fourier級数
<br>
・周期関数f(x)のN次打切りFourier級数FourierN
<br>
FourierN=&lt;_sn(=&lt;{cn*e^(i(n)x)},-N,N);
<br>
cn=&lt;_it(=&lt;{ft*e^(-i(n)t)},-pi,pi)/(2pi);
<br>
・f(x)=e^(i(2.5)x)の場合
<br>
fx=&lt;e^(i(2.5)x);
<br>
ft=&lt;e^(i(2.5)t);
<br>
x=2;
<br>
fx -> 0.28366218546322625-0.9589242746631385i
<br>
N=1; FourierN
<br>
-> infoLost[ri] 0.2534807789507349-0.1102612365002427i+O(2e-6+2e-6i)
<br>
N=3; FourierN
<br>
-> infoLost[ri] 0.3468103654284403-0.7325756973228494i+O(2e-6+2e-6i)
<br>
N=5; FourierN
<br>
-> infoLost[ri] 0.29934712994045387-1.0833440107828247i+O(2e-6+2e-6i)
<br>
・三角波
<br>
ft=&lt;asin(sin(t));
<br>
・矩形波
<br>
ft=&lt;sign(asin(sin(t))); || ft=&lt;sign(sin(t));
<br>
・のこぎり波
<br>
ft=&lt;atan(tan(t));
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
極限の解法
    </th>
    <td>
<span id="span-out-limit"></span>
極限の解法について記述する
<br>
・Computer Algebra System未実装で得られる解は限定的な数値解
<br>
・L'Hôpitalの定理を使用する場合、<a href="#span-out-FNh-DX">微分高階関数</a>の精度に依存
<br>
<br>
<a href="#span-out-com">複素数</a>演算の場合、次の極限演算不可
<br>
1/0 -> [MyErr]FN isNaN
<br>
・0割の演算未定義のため、次の反則が発生
<br>
0*Infinity -> [MyErr]FN isNaN
<br>
<br>
complex uncheckedの<a href="#span-out-ope">実数演算</a>
<br>
1/0 -> Infinity
<br>
MIN_VALUE -> 5e-324
<br>
1/(-MIN_VALUE) -> -Infinity
<br>
1/(+MIN_VALUE) -> Infinity
<br>
1/Infinity || 1/Inf || 1/pInf -> 0
<br>
-Infinity+1 || nInf+1 -> infoLost[r ] -Infinity
<br>
Infinity-Infinity -> [MyErr]BRsa isNaN
<br>
<br>
極限値演算のtest caseを列挙する
<br>
x=MIN_VALUE; x -> 5e-324
<br>
sin(x)/x  // OK -> 1
<br>
sin(-x)/(-x)  // OK -> 1
<br>
ln(1+x)/x  // NG -> infoLost[r ] 0
<br>
・L'Hôpitalの定理
<br>
・<a href="#span-out-com">複素数</a>演算の場合
<br>
_dx(=&lt;{ln(1+x)})/_dx(=&lt;{x})  // OK
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(3e-24i)
<br>
_dx(=&lt;{ln(1-x)})/_dx(=&lt;{-x})  // OK
<br>
-> 1.0000000000031541+4.602212346748365e-14i+O(2e-16+3e-24i)
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{-x},2)  // NG -> [MyErr]FN isNaN
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{(-x)^2},2)  // OK
<br>
-> -0.500000000135999+3.0923761182676057e-12i+O(3e-10+1e-11i)
<br>
・<a href="#span-out-ope">実数演算</a>の場合
<br>
_dx(=&lt;{ln(1+x)})/_dx(=&lt;{x})  // OK -> 0.9999999999991271
<br>
_dx(=&lt;{ln(1-x)})/_dx(=&lt;{-x})  // OK -> 0.9999999999991271
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{-x},2)  // NG -> -Infinity+O(Infinity)
<br>
_dx(=&lt;{ln(1-x)},2)/_dx(=&lt;{(-x)^2},2)  // OK -> -0.4999999999659258+O(3e-10)
<br>
・無限大の極限は自明の演算以外は演算不可
<br>
y=pInf -> y=Infinity
<br>
(1/y)/y  // OK -> 0
<br>
y*y  // OK -> Infinity
<br>
y/(y*y)  // NG -> [MyErr]FN isNaN
<br>
_dy(=&lt;{y})/_dy(=&lt;{y*y})  // NG -> [MyErr]BRsa isNaN
<br>
_dy(=&lt;{1/(y*y)})/_dy(=&lt;{1/y})  // NG -> [MyErr]FN isNaN
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
特殊仕様
    </th>
    <td>
<span id="span-out-special"></span>
最後に一般的でない可能性のある仕様について記述する
<br>
<br>
前置単項の符号の扱いについて記述する
<br>
・単項の符号は同種の2項演算子と区別せず、<a href="#span-out-associativity">associativity</a>に従って演算する
<br>
・この時、符号の左側には0が存在すると仮定する
<br>
左結合既定時　+3-5+7-9 || ((((0+3)-5)+7)-9) -> -4
<br>
右結合選択時　+3-5+7-9 || (0+(3-(5+(7-9)))) -> 0
<br>
・<a href="#span-out-mat">行列</a>も同様に単項の符号はzeros行列との差分またはScalar倍として扱う
<br>
-(1,2:3,4) || (,:,)-(1,2:3,4) || (-1,:,-1)(1,2:3,4) -> (-1,-2:-3,-4)
<br>
・よって実用しないが、符号が連続する場合、右結合選択時のみ演算可
<br>
左結合既定時　--(1,i) || (-)-(1,i) -> Invalid binary operation
<br>
右結合選択時　--(1,i) || (,)-((,)-(1,i)) || (-1)((-1)(1,i)) -> (1,i)
<br>
左結合既定時　---(1,i) || ((-)-)-(1,i) -> Invalid binary operation
<br>
右結合選択時　---(1,i) || (,)-((,)-((,)-(1,i))) || (-1)((-1)((-1)(1,i))) -> (-1,-i)
<br>
<br>
次にequal記号=の扱いについて記述する
<br>
・代入と判別されないequal記号=は、右辺移行の2項演算子として扱う
<br>
・2項の<a href="#span-out-associativity">associativity</a>に依存するが、単体使用を前提とする
<br>
-3=5 || (0-3)=5 || =5+3 -> 8
<br>
(1,2:3,4)=(,:,) || =(,:,)-(1,2:3,4) -> (-1,-2:-3,-4)
<br>
(1,2:3,4)=(,) || =(,)-(1,2:3,4) -> [MyErr]Invalid matrix operation
<br>
・単項の場合、符号同様に左辺には0またはzeros行列が存在すると仮定する
<br>
=8 || 0=8 || =8-0 -> 8
<br>
=(1,2:3,4) || (,:,)=(1,2:3,4) || =(1,2:3,4)-(,:,) -> (1,2:3,4)
<br>
・本仕様は<a href="#span-out-eqns">式変数</a>への方程式の代入で以下の構文を許容する
<br>
f=&lt;{x0^2+1=0} || f=&lt;{=-(x0^2+1)} || f=&lt;{-(x0^2+1)}
<br>
f=&lt;{A(x)=b} || f=&lt;{=b-A(x)} || f=&lt;{b-A(x)}
<br>
f=&lt;{Ainv*A=identity2} || f=&lt;{=identity2-Ainv*A} || f=&lt;{identity2-Ainv*A}
<br>
<br>
<a href="#span-out-mat">行列</a>を扱う上での演算都合上の仕様について記述する
<br>
・代入を<a href="#span-out-BT">括弧</a>で括った場合、0を返す
<br>
(x=3) || (3=3) -> 0
<br>
・代入後は0が残ると仮定して演算する
<br>
2(x=3) || 2(3=3) || 2(=3-3) || 2(0) -> 0
<br>
・代入をcomma,またはcolon:で区切った場合、0を返す
<br>
max(x=3,-1,-2) || max(0,-1,-2) -> 0
<br>
clear; (1,2:3,4:x=5,x) -> (1,2:3,4:0,5)
<br>
・ただし、<a href="#span-out-mat">行列</a>を代入しても次元は残らない
<br>
(x=(1,2:3,4)) -> 0
<br>
clear; x=(1,2),x || 0,(1,2) -> (0,1,2)
<br>
clear; max(x=(-1,-2),min(x)) || max(0,-2) -> 0
<br>
vector={1,2,3}:trans(vector)vector -> (0:14)
<br>
・<a href="#span-out-matching">行列要素pattern matching</a>による代入も同様
<br>
(($a,$b)=(1,2)) -> 0
<br>
・<a href="#span-out-substitution-equation">式変数への代入</a>も同様
<br>
(x=&lt;(a,b,c,d,e)) -> 0
<br>
・<a href="#span-out-vars">変数</a>への<a href="#span-out-eqns">式読出し</a>は読出し値が残る
<br>
clear; y=&lt;3x-1,x=3,y=&gt;,y=&gt;y0,y0 -> (0,0,8,8,8)
<br>
<br>
<a href="#span-out-eqns">式変数</a>について記述する
<br>
・<a href="#span-out-eqns">式変数</a>、<a href="#span-out-eqns">式代入</a>、<a href="#span-out-eqns">式読出し</a>、<a href="#span-out-substitution-equation">式渡し</a>の仕様は呼び名含めて一般的でない
<br>
・連立方程式をscript-inputから解くために独自に定義している
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
application
    </th>
    <td>
<span id="span-out-application"></span>
applicationについて記述する
<br>
<br>
Painter's SVG-path||pattern||filter||gradation生成
<br>
<br>
Circuit Simulator's arbitrary non-linear||impedance element
<br>
・Arrhenius equationのnon-dimensionalized<a href="#span-out-eqns">式変数</a>fの一例
<br>
　回路要素電流Iに対する未知電圧Vを解く場合
<br>
f=&lt;last{I=1,E=0,k=1,I=exp(k*(V-E))-exp(-k*(V-E))}
<br>
　回路要素電圧Vに対する未知電流Iを解く場合
<br>
f=&lt;last{V=1,E=0,k=1,I=exp(k*(V-E))-exp(-k*(V-E))}
<br>
<br>
上記数値解の演算速度を優先するため、Computer Algebra System未実装
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
残課題
    </th>
    <td>
<span id="span-out-remain"></span>
残課題について記述する
<br>
<br>
Ver.2.19.6以降、
<a href="#span-out-substitution-equation">関数の参照渡しの仕様を廃止</a>
して解決
<br>
<del>
<a href="#span-out-FN">関数</a>の参照を返値に指定した場合、予期せぬerror終了
<br>
(,trans) || (trans)=&gt; -> Unexpected error
<br>
・<a href="#span-out-SR">区切り文字</a>の演算時に型checkが必要
<br>
・現状、<a href="#span-out-FNh">高階関数</a>で代替可（関数の参照渡しの必要性が少ない）
<br>
・関数名を短縮する参照渡しを廃止すれば解決
</del>
<br>
<br>
<a href="#span-out-plot2d-command">plot2d-command入力仕様</a>参照
<br>
<del>
plot2d-commandの実装
<br>
・予め演算した結果をplotする場合の仕様が必要
<br>
・<a href="#span-out-command">命令文</a>よりも最上位で単独のcommand仕様が必要
</del>
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

<div>
<table>
<caption><span id="span-in">内部仕様</span></caption>
<thead>
  <tr>
    <th>
項目
    </th>
    <th>
source抜粋
    </th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
単位tree構造
    </th>
    <td>
<span id="span-in-tree"></span>
演算単位となる単位tree構造を以下に示す
<br>
<br>
これに基づく演算仕様について記述する
<br>
・i行j列の行列要素は2次元配列arr[i][j]を参照する
<br>
・<a href="#span-out-FN">関数</a>の引数vectorはarr[arr.length-1]を参照する
<br>
・<a href="#span-out-ope">無次元</a>の演算や定義できない<a href="#span-out-mat">行列</a>演算はarrの最終要素を参照する
<br>
<pre><code>
            j-th sentence
  trees2d: [j][i]{tag || num}
  trees1d,     i-th token
    trees: [i]{}
  trees0d,
     tree: {}
      tag: {"name": {val: val}}
      num: {mat:    {arr: arr}}
      1+i: arr [0] [0] {com: {r: 1, i: 1}}
   matrix:     row col {complex number   }
(i,2:3,4): arr [0] [0] {com: {r: 0, i: 1}}
               [0] [1] {com: {r: 2, i: 0}}
               [1] [0] {com: {r: 3, i: 0}}
               [1] [1] {com: {r: 4, i: 0}}
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
option
    </th>
    <td>
<span id="span-in-options"></span>
command-line実行で必要な内部のoption項目について記述する
<br>
<br>
全objectはglobal scopeから見えないMy_entryで始まる
<br>
<br>
My_entry.parserに渡すdata objectを示す
<br>
var data = {options:{}, vars:{}, eqns:{}};
<br>
<br>
内部optionに相当するdata.optionsのpropertyを以下に列挙する
<br>
<br>
・makeLog: 演算終了後にlog出力用の文字列を作成するflag
<br>
　makeLog=true設定で整形無しのlogを作成
<br>
　makeLog=2設定で行列を整形表示するlogを作成
<br>
　command-lineからlogを見る場合、flagを立てる
<br>
　一例を次に示す（以降のflagも同様）
<pre><code>
var data = new My_entry.DATA().data();
data.in = "2*3";
new My_entry.parser().run(data);
data.out -> [Array(1)]  // 上記の単位tree構造が返却される
data.log -> undefined
data.options.makeLog = true;
new My_entry.parser().run(data);
data.log -> "6"
data.logh -> "2*3\n6"
data.logo -> "makeLog=true"
</code></pre>
・<a href="#span-out-ope">useComplex</a>: 複素数を使用するflag
<br>
<br>
・<a href="#span-out-ope">useMatrix</a>: 行列を使用するflag
<br>
<br>
以降、省略で既定値
<br>
<br>
・<a href="#span-out-config">useStrict</a>: strict-modeを使用するflag
<br>
<br>
・isRightAssociativityBR: 2項演算子の<a href="#span-out-associativity">associativity</a>を右結合に変更するflag
<br>
<br>
・isDIVprior2OMUL: <a href="#span-out-BRmo">記号省略乗算</a>より除算を優先するflag
<br>
<br>
・expDigit: 演算結果を表示する指数表記の桁数
<br>
<br>
・<a href="#span-out-config">checkError</a>: 情報落ちの発生や微分・積分の数値誤差を評価するflag
<br>
<br>
・<a href="#span-out-config">precedence</a>: comma,区切りで演算子の<a href="#span-in-prec">tag名</a>を列挙した文字列
<br>
<br>
・<a href="#span-out-FNm">matSizeMax</a>: 行列size指定の上限値
<br>
<br>
・<a href="#span-out-FNmh-jacobian">dxJ</a>: Jacobi行列演算時の1階偏微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNh-DX">dxD</a>: 有限差分による1階微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNh-DX">orderD</a>: 有限差分による微分の精度次数
<br>
<br>
・<a href="#span-out-FNmh-OX">dxT</a>: 有限差分による1階常微分の差分刻み実数値
<br>
<br>
・<a href="#span-out-FNmh-OX">orderT</a>: 有限差分による常微分の精度次数
<br>
<br>
・<a href="#span-out-FNh-IX">NI</a>: 有限差分による積分範囲の分割数
<br>
<br>
・<a href="#span-out-FNh-IX">orderI</a>: 有限差分による積分の精度次数
<br>
<br>
以降、command-line実行は無効
<br>
<br>
・useWorker: Workerを使用するflag
<br>
<br>
browserから実行する場合、URLのGET入力で既定値を上書き可
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
変数・関数・
<br>
区切り文字・
<br>
演算子の
<br>
precedence
    </th>
    <td>
<span id="span-in-prec"></span>
<a href="#span-out-vars">変数</a>・<a href="#span-out-FN">関数</a>・<a href="#span-out-SR">区切り文字</a>・<a href="#span-out-prec-ope">演算子のprecedence</a>について記述する
<br>
<br>
配列要素の定義順でprecedenceを動的に変更可能とする
<br>
<br>
operation.js抜粋
<pre><code>
  precedence: [
                 // comments and white-spaces are removed by parser
    [
      [
        /* following delimiter */
                 // SeparatoR semi-colon; are removed by parser
        "SRr",   // SeparatoR colon:
        "SRt"    // SeparatoR comma,
      ],
      [
        /* following store */
        "SEe"    // StorE obvious equation including bracket
      ],
      [
        /* following delimiter */
        "BT2",   // BrackeT {
        "BT1",   // BrackeT (
        "BT0"    // BrackeT [
      ],
      [
        /* following restore */
        "REe",   // RestorE obvious equation
        "REv"    // RestorE variable first, equation second
      ],
      [
        /* following function */
        "FNmh",  // FunctioN for matrix high-order
        "FNm",   // FunctioN for matrix
        "FNh",   // FunctioN high-order
        "FN",    // FunctioN 1~4-arguments
        "FNn"    // FunctioN n-arguments
      ]
    ],
    [
      [
        /* following operator */
        "URi",   // post-Unary operatoR imaginary unit i
        "URf"    // factorial mark ! || !!... operand is only natural number
      ],
      [
        "BRp",   // Binary operatoR ** || ^ -&gt; pow(left, right)
        "BRr"    // Binary operatoR %       -&gt; mod(left, right)
      ],
      [
        "BRmo"   // omitted multiplication sign
      ],
      [
        "BRdm"   // Binary operatoR / || *
      ],
      [
        "BRsa"   // Binary operatoR - || + including Pre-Unary operator - || +
      ],
      [
        "BRbs",  // Binary operatoR bit shift &lt;&lt; || &gt;&gt; || &gt;&gt;&gt;
        "BRba",  // Binary operatoR bit   and &amp;
        "BRbx",  // Binary operatoR bit   xor @
        "BRbo"   // Binary operatoR bit    or |
      ],
      [
        "BRcn",  // Binary operatoR comparison &lt; || &lt;= || &gt;= || &gt;
        "BRrl"   // Binary operatoR relational == || &lt;&gt;
      ]
    ],
    [
      [
        "BRe"    // Binary operatoR = including Pre-Unary operator =
      ],
      [
        /* following store */
        "SEv"    // StorE variable
      ]
    ]
  ],
</code></pre>
    </td>
  </tr>
  <tr>
    <th>
<a href="#span-index">
目次
</a>
<br>
定義済みの
<br>
関数・予約語
    </th>
    <td>
<span id="span-in-FN"></span>
定義済みの<a href="#span-out-FN">関数</a>・<a href="#span-out-RW">予約語</a>について記述する
<br>
<br>
予約語は大文字・小文字・全角・半角を区別しない
<br>
<br>
parser.js抜粋
<pre><code>
      // reserved word
      // variable
      case "ans":
        tree = DATA.tree_tag("REv", token_lower);
        break;
      // command
      case "clear":
      case "store":
      case "restore":
      case "stop":
        throw "Invalid "+token+" called";
        break;
      // "FNhn"
      case "switch":
        tree = DATA.tree_tag("FNh", {key: token_lower});
        break;
      // "FN2"
      // only real number
      // relational
      case "eq":
      case "ne":
      // comparison
      case "lt":
      case "le":
      case "gt":
      case "ge":
      // complex number
      // relational
      case "ceq":
      case "cne":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FNmh"
      case "jacobi":
      case "jacobian":
        tree = DATA.tree_tag("FNmh", "jacobian");
        break;
      case "newton":
      case "newtonian":
        tree = DATA.tree_tag("FNmh", "newtonian");
        break;
      // "FNm"
      // "FNm0"
      case "vector2r":
      case "vector3r":
      case "vector4r":
      case "vector2c":
      case "vector3c":
      case "vector4c":
      case "zeros2":
      case "zeros3":
      case "zeros4":
      case "ones2":
      case "ones3":
      case "ones4":
      case "identity2":
      case "identity3":
      case "identity4":
        tree = DATA.tree_mat(math_mat[token_lower]());
        break;
      // "FNm1"
      case "vectorr":
      case "vectorc":
      case "identity":
      case "first":
      case "last":
      case "rotationx":
      case "rotationy":
      case "rotationz":
      case "sizer":
      case "normalizer":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      case "size":
      case "sizec":
        tree = DATA.tree_tag("FNm", "sizec");
        break;
      case "normalize":
      case "normalizec":
        tree = DATA.tree_tag("FNm", "normalizec");
        break;
      case "trans":
      case "transpose":
        tree = DATA.tree_tag("FNm", "transpose");
        break;
      case "htrans":
      case "htranspose":
      case "hermitian":
        tree = DATA.tree_tag("FNm", "hermitian");
        break;
      case "norm":
      case "euclidean":
        tree = DATA.tree_tag("FNm", "euclidean");
        break;
      // "FNm2"
      case "scalars":
      case "zeros":
      case "ones":
        tree = DATA.tree_tag("FNm", token_lower);
        break;
      case "gauss":
      case "gaussian":
        tree = DATA.tree_tag("FNm", "gaussian");
        break;
      // "CT"
      // JavaScript defined
      case "epsilon":
      case "min_safe_integer":
      case "max_safe_integer":
        tree = DATA.tree_num(self.entry.math.config[token_upper], 0);
        break;
      case "min_value":
      case "max_value":
      case "positive_infinity":
      case "negative_infinity":
        tree = DATA.tree_num(Number[token_upper], 0);
        break;
      // My defined
      case "eps":
        tree = DATA.tree_num(self.entry.math.config["EPSILON"], 0);
        break;
      case  "inf":
      case  "infinity":
      case "pinf":
      case "pinfinity":
        tree = DATA.tree_num(Number.POSITIVE_INFINITY, 0);
        break;
      case "ninf":
      case "ninfinity":
        tree = DATA.tree_num(Number.NEGATIVE_INFINITY, 0);
        break;
      case  "infi":
      case  "infinityi":
      case "pinfinityi":
      case "pinfi":
        tree = DATA.tree_num(0, Number.POSITIVE_INFINITY);
        break;
      case "ninfinityi":
      case "ninfi":
        tree = DATA.tree_num(0, Number.NEGATIVE_INFINITY);
        break;
      // JavaScript defined
      case "ln2":
      case "ln10":
      case "log2e":
      case "log10e":
      case "sqrt1_2":
      case "sqrt2":
      // "FN0orCT"
      // Both defined
      case "e":
      case "pi":  // pi || PI() in Excel
        tree = DATA.tree_num(Math[token_upper], 0);
        break;
      // "FN0"
      // JavaScript defined
      case "random":
      // Excel defined
      case "rand":
        tree = DATA.tree_num(Math.random(), 0);
        break;
      // "FN1"
      case "ln":
        tree = DATA.tree_tag("FN", "log");
        break;
      case "int":
        tree = DATA.tree_tag("FN", "floor");
        break;
      // JavaScript defined
      case "ceil":
      case "floor":
      case "round":
      case "log":
      // Excel defined
      case "sinh":
      case "cosh":
      case "tanh":
      case "asinh":
      case "acosh":
      case "atanh":
      case "sign":
      case "fact":
      case "degrees":
      case "radians":
      // Both defined
      case "abs":
      case "sqrt":
      case "exp":
      case "sin":
      case "cos":
      case "tan":
      case "asin":
      case "acos":
      case "atan":
      case "log10":
      // My defined
      case "sin_deg":
      case "cos_deg":
      case "tan_deg":
      case "deg_asin":
      case "deg_acos":
      case "deg_atan":
      case "deg2rad":
      case "rad2deg":
      case "ecomp":
      case "ecomplex":
      case "real":
      case "imag":
      case "imaginary":
      case "conj":
      case "conjugate":
      case "arg":
      case "argument":
      case "deg_arg":
      case "deg_argument":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN1or2"
      // Excel defined
      case "log_ex":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FN2"
      case "power":
        tree = DATA.tree_tag("FN", "pow");
        break;
      // JavaScript defined
      case "pow":
      case "atan2":
      case "imul":
      // Excel defined
      case "combin":
      case "combination":
      // My defined
      case "permut":
      case "permutation":
      case "deg_atan2":
      case "atan2_ex":  // Excel spec
      case "deg_atan2_ex":
      case "comp":
      case "complex":
      case "pcomp":
      case "pcomplex":
      case "kdelta":
      case "mod":
      case "fmod":
      // "FN3or4"
      // My defined
      case "star":
      case "poly":
      case "polygon":
        tree = DATA.tree_tag("FN", token_lower);
        break;
      // "FNn" n&lt;256 in Excel
      // Excel defined
      case "lcm":
      case "gcd":
      // Both defined
      case "min":
      case "max":
        tree = DATA.tree_tag("FNn", token_lower);
        break;
      default:
        /* Ver.2.24.12 -> */
        if(token.charAt(0) === "$"){
          self.check_varName(token.substr(1), re);
        }
        /* -> Ver.2.24.12 */
        tree = DATA.tree_tag("REv", token);
        break;
</code></pre>
    </td>
  </tr>
</tbody>
</table>
</div>
<hr>

  </div>
</body>

</html>
